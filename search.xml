<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[将对象转化为数组]]></title>
    <url>%2F2018%2F07%2F15%2F%E5%B0%86%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[将对象转化为数组 方法一: 1234567let obj=&#123;a:1,b:2&#125;let arr = []let x=Object.entries(obj)//[[&quot;a&quot;, 1],[&quot;b&quot;, 2]]arr=x.map(item=&gt;&#123; return item[1]&#125;)console.log(arr)//[1,2] 方法二: 1234567let obj=&#123;a:1,b:2&#125;let arr = []for (let i in obj) &#123; arr.push(obj[i]); //属性 //arr.push(obj[i]); //值&#125;console.log(arr);//[1,2]]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>对象转数组</tag>
        <tag>entries</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令]]></title>
    <url>%2F2018%2F07%2F15%2Fhexo%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[hexo安装123npm install hexo -g //安装npm update hexo -g //升级hexo init //初始化 hexo命令1234567891011121314151617181920212223hexo n &quot;我的博客&quot; //新建文章-简写hexo new &quot;我的博客&quot; //新建文章hexo new page &quot;title&quot; //新建页面hexo new post &quot;title&quot; //写作hexo new photo &quot;My Gallery&quot; //模版hexo p //草稿-简写hexo publish [layout] &lt;title&gt; //草稿hexo g //生成静态页面至public目录 使用 Hexo 生成静态文件快速而且简单 -简写hexo generate //生成静态页面至public目录 使用 Hexo 生成静态文件快速而且简单hexo generate --watch //监视文件变动hexo s //启动服务预览/开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）-简写hexo server //启动服务预览/开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo d //开始部署，将.deploy目录部署到GitHub-简写hexo deploy //将.deploy目录部署到GitHubhexo server //Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s //静态模式hexo server -g //完成后部署hexo server -p 5000 //更改端口为5000hexo server -i 192.168.1.1 //自定义 IPhexo clean //清除缓存 网页正常情况下可以忽略此条命令hexo generate --deploy //完成后部署hexo deploy --generate //完成后部署hexo d -g //完成后部署-简写]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组降维成一维数组]]></title>
    <url>%2F2018%2F07%2F15%2F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E9%99%8D%E7%BB%B4%E6%88%90%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[把[[2,5],[7,3]]降维成[2,5,7,3] 方法一:12let arr=[[2,5],[7,3]];arr.toString().split //[2,5,7,3] 方法二:12345678function fn(arr)&#123; let a=[]; arr.map(item=&gt;&#123; a=[...a,...item] &#125;); return a&#125;fn([[2,5],[7,3]]) //[2,5,7,3]]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>数组</tag>
        <tag>二维数组</tag>
        <tag>一维数组</tag>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序模块化/组件化开发]]></title>
    <url>%2F2018%2F02%2F11%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97%E5%8C%96-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[将公用组件抽离出来 把一些内容抽取到一个公有的页面中 首先我们要知道，在home下可以共用模板 1.在home文件夹下新建个目录(list-tmpl) 模板中只能放两种文件:css、wxml;不支持js和json 模板的标志template标签 模板要给他起个名字，就是我们要调用这个模板的时候要用的名字&lt;template name=&#39;name&#39;&gt;&lt;/template&gt; 可以放多个模板，但每个模板都要有自己的名字 同样css样式也要公有化 2.导入模板(使用相对路径) &lt;import src=&#39;list-tmpl/list-tmpl.wxml&#39;/&gt; is-&gt;模板名字,data-&gt;传入数据;&lt;template is=&#39;list&#39; data=&#39;&#39;&gt;&lt;/template&gt; 此时home.wxml文件123456789&lt;import src=&apos;list-tmpl/list-tmpl.wxml&apos;/&gt;&lt;swiper autoplay=&apos;&#123;&#123;true&#125;&#125;&apos; interval=&apos;1000&apos; indicator-dots=&apos;&#123;&#123;true&#125;&#125;&apos; circular=&apos;&#123;&#123;true&#125;&#125;&apos;&gt; &lt;swiper-item wx:for=&apos;&#123;&#123;imgs&#125;&#125;&apos;&gt; &lt;image src=&apos;&#123;&#123;item&#125;&#125;&apos;&gt;&lt;/image&gt; &lt;/swiper-item&gt;&lt;/swiper&gt;&lt;block wx:for=&quot;&#123;&#123;lists&#125;&#125;&quot;&gt; &lt;template is=&apos;list&apos; data=&apos;&#123;&#123;item&#125;&#125;&apos;&gt;&lt;/template&gt;&lt;/block&gt; 3.引入css样式,此时home.wxss文件1234567@import &apos;list-tmpl/list-tmpl.wxss&apos;;swiper&#123; height: 400rpx;&#125;swiper image&#123; width: 100%;&#125; 点击跳转详情页 事件不能直接绑在template标签上，因为在编译的过程中，最终会直接用一个模板将template替换掉。 解决方案:在template标签外面包一层view标签，在view标签上绑定bindtap点击事件]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>模块化开发</tag>
        <tag>组件化开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序]]></title>
    <url>%2F2018%2F02%2F10%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[app文件 app.json全局的配置样式 app.wxss全局的css样式 app.js全局的js样式 app.json 在该文件中不能使用‘//’来注释信息，否则报错 12345678910111213&#123; &quot;pages&quot;: [ &quot;pages/welcome/welcome&quot; ], &quot;window&quot;: &#123; &quot;navigationBarBackgroundColor&quot;: &quot;#b0b0b0&quot;, //导航条的颜色 &quot;navigationBarTextStyle&quot;: &quot;#fff&quot;, //文字的样式 &quot;navigationBarTitleText&quot;: &quot;Welcome&quot;, //标题 &quot;backgroundColor&quot;: &quot;#eeeeee&quot;, //下拉样式的背景色 &quot;backgroundTextStyle&quot;: &quot;light&quot;, //light和dark两个值，下拉样式中三个点的颜色，dark代表白色，light代表黑色 &quot;enablePullDownRefresh&quot;: true //是否可见下拉刷新 &#125;&#125; pages的第一个参数就是默认打开的页面 微信开发者工具，一个开发者只能一次打开一个页面，不能同时开多个页面 welcome.wxml view替代div，view相当于一个盒子、一个视图框、一个容器 text标签替换span/p标签，text标签是我们所谓的文本标签 image标签，图片标签，src图片路径可以使用绝对路径/相对路径 文本不套text标签，在手机端是无法被选中的(无法复制) 12345&lt;view class=&apos;container&apos;&gt; &lt;image src=&apos;../../images/touxiang.jpg&apos; class=&apos;avatar&apos;&gt;&lt;/image&gt; &lt;text class=&apos;title&apos;&gt;one&lt;/text&gt; &lt;text class=&apos;content&apos;&gt;hello world&lt;/text&gt;&lt;/view&gt; 1.事件(https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html) 事件分为冒泡事件和非冒泡事件： 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。 bindtap 绑定点击事件 会冒泡 非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。 catchtap 不会冒泡 WXML的冒泡事件列表： 类型 触发条件 最低版本 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchcancel 手指触摸动作被打断，如来电提醒，弹窗 touchend 手指触摸动作结束 tap 手指触摸后马上离开 longpress 手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发 1.5.0 longtap 手指触摸后，超过350ms再离开（推荐使用longpress事件代替） transitionend 会在 WXSS transition 或 wx.createAnimation 动画结束后触发 animationstart 会在一个 WXSS animation 动画开始时触发 animationiteration 会在一个 WXSS animation 一次迭代结束时触发 animationend 会在一个 WXSS animation 动画完成时触发 注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如&lt;form/&gt;的submit事件，&lt;input/&gt;的input事件，&lt;scroll-view/&gt;的scroll事件，(详见各个组件) welcome.wxss 小程序开发文档地址：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html，WXSS样式中有介绍 目前支持的选择器有： 选择器 样例 样例描述 .class .intro 选择所有拥有 class=”intro” 的组件 #id #firstname 选择拥有 id=”firstname” 的组件 element view 选择所有 view 组件 element,element view, checkbox 选择所有文档的 view 组件和所有的 checkbox 组件 ::after view::after 在 view 组件后边插入内容 ::before view::before 在 view 组件前边插入内容 支持flex布局 不以px为单位，因为要支持适配各种尺寸手机，用rpx为单位 1rpx=2px(在iphone6下) 宽度(iphone6) 750rpx=100% 高度一般采用rpx 线条 1px(仍然是实际的高度); 尺寸单位 rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 设备 rpx换算px(屏幕宽度/750) px换算rpx (750/屏幕宽度) iPhone5 1rpx = 0.42px 1px = 2.34rpx iPhone6 1rpx = 0.5px 1px = 2rpx iPhone6 Plus 1rpx = 0.552px 1px = 1.81rpx 建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。 注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。 app.wxss中设置公用样式(如字体)点击跳转页面1.welcome.js1234567891011121314151617181920212223242526// pages/welcome/welcome.jsPage(&#123; /*页面的初始数据*/ data: &#123; &#125;, bindToHome()&#123; //关闭当前页面,跳转到应用内的某个页面，所有的方法都是异步的 //redirectTo 重定向 跳到下页，下页无返回按钮 wx.redirectTo(&#123; url: &apos;../home/home&apos;, success:function()&#123; &#125;, fail:function()&#123; &#125;, complete:function()&#123; &#125; &#125;); //navigateTo保留当前页面，跳转到应用内的某个页面 只适合导航跳转 wx.navigateTo(&#123; url: &apos;../home/home&apos;, &#125;) &#125;&#125;) 2.welcome.wxml12345&lt;view class=&apos;container&apos;&gt; &lt;image src=&apos;../../images/touxiang.jpg&apos; class=&apos;avatar&apos; bindtap=&apos;bindToHome&apos;&gt;&lt;/image&gt; &lt;text class=&apos;title&apos;&gt;one&lt;/text&gt; &lt;text class=&apos;content&apos;&gt;hello world&lt;/text&gt;&lt;/view&gt; 更改子级页面的title 内部/子级页面没有pages属性，只有window属性1.home.json 子页面不需要写window了12345&#123; &quot;navigationBarBackgroundColor&quot;: &quot;green&quot;, &quot;navigationBarTextStyle&quot;: &quot;yellow&quot;, &quot;navigationBarTitleText&quot;: &quot;主页&quot;&#125; 主页的tab键1.app.json tabBar配置文档地址https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html tabBar(tab的列表最少2个，最多5个)“当tab列表不足2个的时候会报错” tabBar列表有两个 12345678910111213141516&quot;tabBar&quot;: &#123; &quot;borderStyle&quot;: &quot;white&quot;,//tab盒子的border-top，有两个值black（黑色）、white（白色） &quot;color&quot;: &quot;red&quot;,//字体颜色 &quot;selectedColor&quot;: &quot;orange&quot;,//激活的字体颜色 &quot;list&quot;: [&#123; &quot;pagePath&quot;: &quot;pages/home/home&quot;,//页面路径(跳转的对应路径)，只能使用相对路径 &quot;text&quot;: &quot;首页&quot;, &quot;iconPath&quot;: &quot;images/anhoo.png&quot;,//页面默认的icon路径，只能使用相对路径 &quot;selectedIconPath&quot;: &quot;images/anhoo1.png&quot; &#125;,&#123; &quot;pagePath&quot;: &quot;pagePath&quot;, &quot;text&quot;: &quot;text&quot;, &quot;iconPath&quot;: &quot;images/anhoo.png&quot;, &quot;selectedIconPath&quot;: &quot;selectedIconPath&quot; &#125;] &#125; 此处有坑 升级到1.2版本后，如果有tabBar，只能使用switchTab方式切换123456789//保留当前页面，跳转到应用内的某个页面 navigateTo只适合导航跳转 // wx.navigateTo(&#123; // url: &apos;../home/home&apos;, // &#125;); //跳转到tabBar页面,并关闭其他所有非tabBary页面 //如果有tabBar，只能使用switchTab方式切换 wx.switchTab(&#123; url: &apos;&apos;, &#125;) 此时app.json文件 1234567891011121314151617181920212223242526272829&#123; &quot;pages&quot;: [ &quot;pages/welcome/welcome&quot;, &quot;pages/home/home&quot;, &quot;pages/notes/notes&quot;, &quot;pages/event/event&quot; ], &quot;window&quot;: &#123; &quot;navigationBarBackgroundColor&quot;: &quot;#b0b0b0&quot;, &quot;navigationBarTextStyle&quot;: &quot;green&quot;, &quot;navigationBarTitleText&quot;: &quot;Welcome&quot; &#125;, &quot;tabBar&quot;: &#123; &quot;borderStyle&quot;: &quot;white&quot;, &quot;color&quot;: &quot;red&quot;, &quot;selectedColor&quot;: &quot;orange&quot;, &quot;list&quot;: [&#123; &quot;pagePath&quot;: &quot;pages/home/home&quot;, &quot;text&quot;: &quot;首页&quot;, &quot;iconPath&quot;: &quot;images/anhoo1.png&quot;, &quot;selectedIconPath&quot;: &quot;images/anhoo.png&quot; &#125;,&#123; &quot;pagePath&quot;: &quot;pages/notes/notes&quot;, &quot;text&quot;: &quot;笔记&quot;, &quot;iconPath&quot;: &quot;images/anhoo1.png&quot;, &quot;selectedIconPath&quot;: &quot;images/anhoo.png&quot; &#125;] &#125;&#125; 主页banner制作 为了开发方便，将app.json中的pages配置调换一下位置，将home文件的配置放在最上面 123456&quot;pages&quot;: [ &quot;pages/home/home&quot;, &quot;pages/notes/notes&quot;, &quot;pages/event/event&quot;, &quot;pages/welcome/welcome&quot; ] 此时默认打开的就是首页 1.home.wxml 不能使用jQuery等，因为微信小程序中没有dom swiper内置的组件，滑动插件 autoplay=&#39;true&#39;自动播放，默认false; 此处有坑:不能写成autoplay=&#39;true&#39;或者autoplay=&#39;false&#39;，这样写是字符串，默认转为布尔类型，即使设置为false，&#39;false&#39;转为布尔类型也是true，也会自动播放，所以一定要加双大括号 interval自动切换间隔时间 indicator-dots=&#39;true&#39;轮播图对应的小点 同autoplay，一定要加双大括号 circular=&#39;true&#39;循环轮播 同autoplay，一定要加双大括号 vertical=&#39;true&#39; 轮播图上下滚动 此处有坑:设置banner图的高，不能给swiper-item标签设置，要给他的父级swiper标签设置123456789101112131415161718//设置banner图的高为600rpx,此处的style不需要加`双大括号`&lt;swiper autoplay=&apos;&#123;&#123;true&#125;&#125;&apos; interval=&apos;1000&apos; indicator-dots=&apos;&#123;&#123;true&#125;&#125;&apos; circular=&apos;&#123;&#123;true&#125;&#125;&apos; vertical=&apos;&#123;&#123;true&#125;&#125;&apos; style=&apos;height:600rpx;&apos;&gt; &lt;swiper-item&gt; &lt;image src=&apos;/images/banner1.jpg&apos;&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src=&apos;/images/banner2.jpg&apos;&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src=&apos;/images/banner3.jpg&apos;&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src=&apos;/images/banner4.jpg&apos;&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src=&apos;/images/banner5.jpg&apos;&gt;&lt;/image&gt; &lt;/swiper-item&gt;&lt;/swiper&gt; 绑定动态数据 数据是单向绑定，数据改动了可以渲染视图，但是视图改动了不会刷新数据 wx:key 静态遍历不需要 1.home.js 123456789data:&#123; imgs:[ &apos;/images/banner1.jpg&apos;, &apos;/images/banner2.jpg&apos;, &apos;/images/banner3.jpg&apos;, &apos;/images/banner4.jpg&apos;, &apos;/images/banner5.jpg&apos; ]&#125; wx:for=&#39;&#39; 2.home.wxml 12345&lt;swiper autoplay=&apos;&#123;&#123;true&#125;&#125;&apos; interval=&apos;1000&apos; indicator-dots=&apos;&#123;&#123;true&#125;&#125;&apos; circular=&apos;&#123;&#123;true&#125;&#125;&apos;&gt; &lt;swiper-item wx:for=&apos;&#123;&#123;imgs&#125;&#125;&apos;&gt; &lt;image src=&apos;&#123;&#123;item&#125;&#125;&apos;&gt;&lt;/image&gt; &lt;/swiper-item&gt;&lt;/swiper&gt; wx:for-item=&#39;num&#39;可指定item叫什么名字，这里的item就叫num 2.home.wxml 12345&lt;swiper autoplay=&apos;&#123;&#123;true&#125;&#125;&apos; interval=&apos;1000&apos; indicator-dots=&apos;&#123;&#123;true&#125;&#125;&apos; circular=&apos;&#123;&#123;true&#125;&#125;&apos;&gt; &lt;swiper-item wx:for=&apos;&#123;&#123;imgs&#125;&#125;&apos; wx:for-item=&apos;num&apos;&gt; &lt;image src=&apos;&#123;&#123;num&#125;&#125;&apos;&gt;&lt;/image&gt; &lt;/swiper-item&gt;&lt;/swiper&gt; 注意:wx:for-item=&#39;num&#39;,num不加双大括号]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML特殊符号总结]]></title>
    <url>%2F2018%2F01%2F26%2FHTML%E4%B8%AD%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[HTML特殊符号总结 —— 符号 —— 符号 —— 符号 —— 符号 —— &amp;aacute; &aacute; &amp;hArr; &hArr; &amp;para; &para; &amp;yacute; &yacute; &amp;Aacute; &Aacute; &amp;harr; &harr; &amp;part; &part; &amp;yen; &yen; &amp;Acirc; &Acirc; &amp;hearts; &hearts; &amp;permil; &permil; &amp;yuml; &yuml; &amp;acirc; &acirc; &amp;hellip; &hellip; &amp;perp; &perp; &amp;Yacute; &Yacute; &amp;acute; &acute; &amp;phi; &phi; &amp;Yuml; &Yuml; &amp;AElig; &AElig; &amp;pi; &pi; &amp;aelig; &aelig; &amp;piv; &piv; &amp;Agrave; &Agrave; &amp;plusmn; &plusmn; &amp;agrave; &agrave; &amp;pound; &pound; &amp;alefsym; &alefsym; &amp;prime; &prime; &amp;alpha; &alpha; &amp;prod; &prod; &amp;Alpha; &Alpha; &amp;prop; &prop; &amp;amp; &amp; &amp;psi; &psi; &amp;and; &and; &amp;Phi; &Phi; &amp;ang; &ang; &amp;Pi; &Pi; &amp;aring; &aring; &amp;Prime; &Prime; &amp;Aring; &Aring; &amp;Psi; &Psi; &amp;bdquo; &bdquo; &amp;iacute; &iacute; &amp;quot; &quot; &amp;zeta; &zeta; &amp;beta; &beta; &amp;icirc; &icirc; &amp;zwj; &zwj; &amp;brvbar; &brvbar; &amp;iexcl; &iexcl; &amp;zwnj; &zwnj; &amp;bull; &bull; &amp;igrave; &igrave; &amp;Zeta; &Zeta; &amp;Beta; &Beta; &amp;image; &image; &amp;infin; &infin; &amp;int; &int; &amp;iota; &iota; &amp;iquest; &iquest; &amp;isin; &isin; &amp;iuml; &iuml; &amp;Iacute; &Iacute; &amp;Icirc; &Icirc; &amp;Igrave; &Igrave; &amp;Iota; &Iota; &amp;Iuml; &Iuml; &amp;clubs; &clubs; &amp;kappa; &kappa; &amp;radic; &radic; &amp;cap; &cap; &amp;Kappa; &Kappa; &amp;rang; &rang; &amp;ccedil; &ccedil; &amp;lambda; &lambda; &amp;raquo; &raquo; &amp;cedil; &cedil; &amp;rarr; &rarr; &amp;cent; &cent; &amp;rArr; &rArr; &amp;chi; &chi; &amp;rceil; &rceil; &amp;circ; &circ; &amp;rdquo; &rdquo; &amp;clubs; &clubs; &amp;real; &real; &amp;cong; &cong; &amp;reg; &reg; &amp;copy; &copy; &amp;rfloor; &rfloor; &amp;crarr; &crarr; &amp;rho; &rho; &amp;cup; &cup; &amp;rlm; &rlm; &amp;curren; &curren; &amp;rsaquo; &rsaquo; &amp;Ccedil; &Ccedil; &amp;rsquo; &rsquo; &amp;Chi; &Chi; &amp;Rho; &Rho; &amp;dagger; &dagger; &amp;lang; &lang; &amp;sbquo; &sbquo; &amp;dArr; &dArr; &amp;laquo; &laquo; &amp;scaron; &scaron; &amp;darr; &darr; &amp;lArr; &lArr; &amp;sdot; &sdot; &amp;deg; &deg; &amp;larr; &larr; &amp;sect; &sect; &amp;delta; &delta; &amp;lceil; &lceil; &amp;shy; &shy; &amp;divide; &divide; &amp;ldquo; &ldquo; &amp;sigma; &sigma; &amp;Dagger; &Dagger; &amp;le; &le; &amp;sigmaf; &sigmaf; &amp;Delta; &Delta; &amp;lfloor; &lfloor; &amp;sim; &sim; &amp;lowast; &lowast; &amp;spades; &spades; &amp;loz; &loz; &amp;sub; &sub; &amp;lrm; &lrm; &amp;sube; &sube; &amp;lsaquo; &lsaquo; &amp;sum; &sum; &amp;lsquo; &lsquo; &amp;sup1; &sup1; &amp;lt; &lt; &amp;sup2; &sup2; &amp;Lambda; &Lambda; &amp;sup3; &sup3; &amp;sup; &sup; &amp;supe; &supe; &amp;szlig; &szlig; &amp;Scaron; &Scaron; &amp;Sigma; &Sigma; &amp;eacute; &eacute; &amp;macr; &macr; &amp;tau; &tau; &amp;ecirc; &ecirc; &amp;mdash; &mdash; &amp;there4; &there4; &amp;egrave; &egrave; &amp;micro; &micro; &amp;theta; &theta; &amp;empty; &empty; &amp;middot; &middot; &amp;thetasym; &thetasym; &amp;emsp; &emsp; &amp;minus; &minus; &amp;thinsp; &thinsp; &amp;ensp; &ensp; &amp;mu; &mu; &amp;thorn; &thorn; &amp;epsilon; &epsilon; &amp;Mu; &Mu; &amp;tilde; &tilde; &amp;equiv; &equiv; &amp;times; &times; &amp;eta; &eta; &amp;trade; &trade; &amp;eth; &eth; &amp;Tau; &Tau; &amp;euml; &euml; &amp;Theta; &Theta; &amp;euro; &euro; &amp;THORN; &THORN; &amp;exist; &exist; &amp;Eacute; &Eacute; &amp;Ecirc; &Ecirc; &amp;Egrave; &Egrave; &amp;Epsilon; &Epsilon; &amp;Eta; &Eta; &amp;ETH; &ETH; &amp;Euml; &Euml; &amp;fnof; &fnof; &amp;nabla; &nabla; &amp;uacute; &uacute; &amp;forall; &forall; &amp;nbsp; &nbsp; &amp;uarr; &uarr; &amp;frac12; &frac12; &amp;ndash; &ndash; &amp;uArr; &uArr; &amp;frac14; &frac14; &amp;ne; &ne; &amp;ucirc; &ucirc; &amp;frac34; &frac34; &amp;ni; &ni; &amp;ugrave; &ugrave; &amp;frasl; &frasl; &amp;not; &not; &amp;uml; &uml; &amp;notin; &notin; &amp;upsih; &upsih; &amp;nsub; &nsub; &amp;upsilon; &upsilon; &amp;ntilde; &ntilde; &amp;uuml; &uuml; &amp;nu; &nu; &amp;Uacute; &Uacute; &amp;Ntilde; &Ntilde; &amp;Ucirc; &Ucirc; &amp;Nu; &Nu; &amp;Ugrave; &Ugrave; &amp;Upsilon; &Upsilon; &amp;Uuml; &Uuml; &amp;gamma; &gamma; &amp;oacute; &oacute; &amp;weierp; &weierp; &amp;ge; &ge; &amp;ocirc; &ocirc; &amp;gt; &gt; &amp;oelig; &oelig; &amp;Gamma; &Gamma; &amp;ograve; &ograve; &amp;oline; &oline; &amp;xi; &xi; &amp;omega; &omega; &amp;Xi; &Xi; &amp;omicron; &omicron; &amp;oplus; &oplus; &amp;or; &or; &amp;ordf; &ordf; &amp;ordm; &ordm; &amp;oslash; &oslash; &amp;otilde; &otilde; &amp;otimes; &otimes; &amp;ouml; &ouml; &amp;Oacute; &Oacute; &amp;Ocirc; &Ocirc; &amp;OElig; &OElig; &amp;Ograve; &Ograve; &amp;Omega; &Omega; &amp;Omicron; &Omicron; &amp;Oslash; &Oslash; &amp;Oslash; &Oslash; &amp;Otilde; &Otilde; &amp;Ouml; &Ouml;]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html特殊符号</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactNative环境搭建]]></title>
    <url>%2F2018%2F01%2F24%2FReactNative%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[官方中文文档地址’https://reactnative.cn/docs/0.51/getting-started.html‘ 如果是ios并不长，如果是安卓相对繁琐一些 操作系统分为:macOS/Linux/Windows 在macOS下可以开发ios和安卓的，但是Linux/Windows只能开发安卓的(如果工作中老板要你用ReactNative，你尽量和老板申请个mac本) 步骤 1.安装Node.js/Homebrew 百度搜索Node.js Mac环境(百度搜索Homebrew) 1-1.Node.js安装 安装后需要配置一下环境变量(我的电脑-属性-高级系统设置-环境变量(path中的数据新增nodejs路径)) 1-1-1.nodejs安装提示 window配置环境变量参考:https://jingyan.baidu.com/article/f3e34a128dc9aff5eb6535dc.html ReactNative和很多开发工具一样，会大量使用命令行工具，建议学习一些基本windows/unix/linux指令(mac和linux下是比较相似的，在windows下是不一样的) 参考:windows下的.bat文件、unix/linux下的.sh文件(dir/ls 列出文件;copy/cp 拷贝;cd/cd 切换目录) 1-1-2.关于Node.js版本(建议使用6以上的版本) 1-1-3.npm的作用和package.json npm是nodejs的包管理器，nodejs是一个开源的环境，所谓包管理器就是取之于开源贡献者的代码，用之于开发者，这样一个桥梁的一个作用。 包管理器主要源自于国外，国内做的比较好的就是淘宝(淘宝镜像)。 1-1-4.关于淘宝镜像的问题 有时候会有一定的同步问题，如果npm install的时候非常慢，建议安装，安装后先移除项目目录下node_modules文件夹12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/list --global 1-2.Homebrew安装 macOS需要安装Homebrew，前提是有Ruby，一般mac自带Ruby(可参考reactnative.cn官方中文文档) 通常情况下Homebrew已经有了，不需要安装 1-3.JDK安装 安卓的版是需要JAVA的，所以要安装JDK 1-3-1.JDK小贴士 目前jdk有两个版本(OPENJDK/Oracle Java JDK)，使用Android Studio开发需要JDK 1-3-2.注意事项 版本差别不大，1.7/1.8应该都可以 JAVA安装成功之后通常需要设置一个JAVA_HOME的环境变量，window参考:https://jingyan.baidu.com/article/f3e34a128dc9aff5eb6535dc.html;MacOS/Linux/Unix通常需要export JAVA_HOME=(java路径) 具体可以百度下。 2.开发工具 2-1.安装Xcode、Android Studio Mac(Xcode):开发ios用Xcode，必须用Mac开发。 Android Studio比较麻烦一些 官方做法：https://developer.android.com (在不翻墙的情况下到该地址下载Android Studio) 非官方做法：百度Android Studio，即可下载 2-2.工具任意以下其中之一 webstore(推荐使用，代码跟踪、代码提示做的比较好) Visual Studio Code Atom 2-3.语法设置 会用react的人都知道，react是使用JSX语法，而ReactNative也是使用JSX语法，在webstore中需要设置成react JSX，否则会有很多报错“webstore打开设置窗口”“JSX语法设置” 2-4.推荐使用Vim编辑器 可结合webstore/Visual Studio Code/Atom 这三款工具使用，特点就是快。 3.难点 3-1.什么是Android SDK 3-2.SDK安装步骤 1) 在AndroidStudio中点开偏好 2) 在搜索框中输入Android SDK 3) 然后勾选需要安装的SDK工具 4) 在SDK Platforms窗口中，选择Show Package Details,然后在Android6.0(Marshmallow)中勾选Google Apis、Android SDK Platform 23、Intel x86 Atom64 System Image以及Google APIs intel x86 Atom64 System Image 5) 在SDK Tools窗口中，选择Show Package Details，然后在Android SDK Build Tools中勾选Android SDK Build-Tools 23.0.1 6) 配置ANDROID_HOME环境变量 在MacOS下，在~/.bash_profile中添加 123export ANDROID_HOME=~/Library/Android/sdkexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/toolsexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-tools 在Linux下需要在.bashrc中添加相应内容 在windows下参考https://jingyan.baidu.com/article/f3e34a128dc9aff5eb6535dc.html 3-3.Android模拟器 建议使用Genymotion(建议) 建议使用Genymotion官网注册一个账号(注意:qq邮箱不好使，他不认数字的邮箱，必须是字母的) 下载一个genymotion软件 个人版是免费的，企业版收费 Genymotio实际用的是virtualbox Android Studio自带的AVD(不建议) 如果要在Android Studio中使用AVD必须安装HAXM否则会慢，可以在Android Studio中配置，首先需要安装(配置过程及其复杂) 大概需要安装的有:Android SDK、Android SDK Platform、Performance (Intel &reg; HAXM)、Android Virtual Device 3-4.windows下配置特别提醒 windows下配置较为困难，如果配置完成后发现红屏幕，有各种各样的原因，其中在windows7下通常需要设置Virtualbox的网络最为棘手]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>ReactNative环境搭建</tag>
        <tag>rn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器的跨域问题以及解决方案(转载)]]></title>
    <url>%2F2017%2F10%2F07%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[解决跨域一:Cookie如何实现跨域 Cookie是服务器写入浏览器的一段信息，只有同源的网页才能共享，但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置document.domain共Cookie。 举例来说，A网站是:http:weibo.qq.com;B网站是:http:lol.qq.com;那么只需设置相同的document.domain,两个网页就可共享Cookie。 1document.domain = &apos;qq.com&apos;; 现在，A网页通过脚本设置一个Cookie。 1document.Cookie = &quot;test1=hello&quot;; B网页就能读到这个Cookie。 1var getCookie = document.cookie; 注意：这种方法只适用于Cookie和iframe窗口，LocalStorage和IndexDB无法通过这种方法规避，而要使用下文将介绍的PostMessage API。另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名,比如：.qq.com 1Set-Cookie:key=value;domain=&lt;span style=&quot;color:#cc0000;&quot;&gt;.qq.com&lt;/span&gt;;path=/ 这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。 解决跨域问题二:如何跨域获取DOM。 如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。 比如,父窗口运行下面的命令，如果iframe窗口不是同源将会报错。 1document.getElementById(&quot;iframe&quot;).contentWindow.document 上面命令中，父窗口想获取子窗口的DOM，应为跨源导致报错。反之亦然，子窗口获取主窗口的DOM也会报错。 1window.parent.document.body 如果两个窗口一级域名相同，只是二级域名不同，那么设置4-1介绍的document.domain属性，就可规避同源政策，拿到DOM。 对于完全不相同的网站，目前有三种方法，可以解决跨域窗口的通信问题。 (1)片段识别符(fragment identifier) (2)window.name (3)跨文档通信API(Cross-document messaging) 1)片段识别符 片段识别符指的是，URL的#号后面的部分，比如http://qq.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面将不会重新刷新、父窗口可以把信息，写入子窗口的片段标识符。 12var src = originURL+&apos;#&apos;+data;document.getElementById(&apos;iframe&apos;).src = src; 子窗口通过监听hashchange事件得到通知 12345window.onhashchange = checkMessage; function checkMessage()&#123; var message = window.location.hash; //... &#125; 同样的，子窗口也可以改变父窗口的片段标识符。 1parent.location.href = target+&quot;#&quot;+hash; 2)window.name 浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置这个属性，后一个网页就可以读取它。 父窗口先发开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。 1window.name = data; 接着，子窗口跳回一个与主窗口同域的网址。 1location = &apos;http://parent.url.com/xxx.html&apos;; 然后，主窗口就可以读取子窗口的window.name了。 1var data = document.getElementById(&apos;iframe&apos;).contentWindow.name; 优点 window.name容量很大，可以防止非常长的字符串；缺点 必须监听子窗口window.name属性的变化，会影响网页性能。 3)跨文档消息传输window.postMessage： 上面两种方法都属于破解，HTML5为解决这个问题，引入一个全新的API：跨文档消息传输Cross Document Messaging。 下一代浏览器都将支持这个功能:Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 。 Facebook已经使用了这个功能，用postMessage支持基于web的实时消息传递。 使用方法 otherWindow.postMessage(message, targetOrigin); otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性;window.open的返回值；通过name或下标从window.frames取到的值。 message: 具体的信息内容，string类型。targetOrigin: 接受消息的窗口的源(origin)，即“协议+域名+端口”。也可以设为“*”，表示不限制域名，向所有窗口发送。 message事件的事件对象event，提供一下三个属性: (1).event.source:发送消息的窗口 (2).event.origin:消息发向的网站 (3).event.data:消息内容 具体实例： a.com/index.html中的代码： 123456789&lt;iframe id=&quot;ifr&quot; src=&quot;b.com/index.html&quot;&gt;&lt;/iframe&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.onload = function() &#123; var ifr = document.getElementById(&apos;ifr&apos;); var targetOrigin = &apos;http://b.com&apos;; // 若写成&apos;http://b.com/c/proxy.html&apos;效果一样 // 若写成&apos;http://c.com&apos;就不会执行postMessage了 ifr.contentWindow.postMessage(&apos;I was there!&apos;, targetOrigin);&#125;;&lt;/script&gt; b.com/index.html中的代码： 12345678910&lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener(&apos;message&apos;, function(event)&#123; // 通过origin属性判断消息来源地址 if (event.origin == &apos;http://a.com&apos;) &#123; alert(event.data); // 弹出&quot;I was there!&quot; alert(event.source); // 对a.com、index.html中window对象的引用 // 但由于同源策略，这里event.source不可以访问window对象 &#125; &#125;, false);&lt;/script&gt; 如何解决跨域LocalStorage。 通过window.postMessage,读写其他窗口的LocalStorage也成为了可能。下面是一个例子，主窗口写入iframe子窗口的LocalStorage。 1234567window.onmessage = function(e)&#123; if(e.origin !== &apos;http://bbb.com&apos;)&#123; return ; &#125; var payload = JSON.parse(e.data); localStorage.setItem(payload.key,JSON.stringify(payload.data));&#125;; 上面代码中，子窗口将父窗口发送来的消息，写入自己的LocalStorage。 父窗口发送消息的代码如下. 123var win = document.getElementsByTagName(&apos;iframe&apos;)[0].contentWindow;var obj = &#123;name:&apos;Jack&apos;&#125;;win.postMessage(JSON.stringify(&#123;key:&apos;storage&apos;,data:obj&#125;),&apos;http://bbb.com&apos;); 加强版的子窗口接受消息的代码如下。 1234567891011121314151617window.onmessage = function(e) &#123; if (e.origin !== &apos;http://bbb.com&apos;) return; var payload = JSON.parse(e.data); switch (payload.method) &#123; case &apos;set&apos;: localStorage.setItem(payload.key, JSON.stringify(payload.data)); break; case &apos;get&apos;: var parent = window.parent; var data = localStorage.getItem(payload.key); parent.postMessage(data, &apos;http://aaa.com&apos;); break; case &apos;remove&apos;: localStorage.removeItem(payload.key); break; &#125;&#125;; 加强版的父窗口发送消息代码如下: 1234567891011var win = document.getElementsByTagName(&apos;iframe&apos;)[0].contentWindow;var obj = &#123; name: &apos;Jack&apos; &#125;;// 存入对象win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, method: &apos;set&apos;, data: obj&#125;), &apos;http://bbb.com&apos;);// 读取对象win.postMessage(JSON.stringify(&#123;key: &apos;storage&apos;, method: &quot;get&quot;&#125;), &quot;*&quot;);window.onmessage = function(e) &#123; if (e.origin != &apos;http://aaa.com&apos;) return; // &quot;Jack&quot; console.log(JSON.parse(e.data).name);&#125;; 如何解决AJAX的跨域： 同源政策规定，AJAX请求只能发给同源的网址，否则就报错。 除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。 (1)JSONP (2)WebSocket (3)CORS 1)JSONP解决AJAX跨域问题： JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。 它的基本思想是，网页通过添加一个&lt;script&gt;元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 首先，网页动态插入&lt;script&gt;元素，由它向跨源网址发出请求。 1234567891011121314function addScriptTag(src) &#123; var script = document.createElement(&apos;script&apos;); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag(&apos;http://example.com/ip?callback=foo&apos;);&#125;function foo(data) &#123; console.log(&apos;Your public IP address is: &apos; + data.ip);&#125;; 上面代码通过动态添加&lt;script&gt;元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。 服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。 123foo(&#123; &quot;ip&quot;: &quot;8.8.8.8&quot;&#125;); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 2)通过webSocket解决AJAX跨域 WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自维基百科）。 12345678GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com 上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。 12345HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat 3)通过CORS解决AJAX跨域 CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。定义 CORS其实出现时间不短了，它在维基百科上的定义是：跨域资源共享（CORS）是一种网络浏览器的技术规范，它为Web服务器定义了一种方式，允许网页从不同的域访问其资源。而这种访问是被同源策略所禁止的。CORS系统定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。 它是一个妥协，有更大的灵活性，但比起简单地允许所有这些的要求来说更加安全。而W3C的官方文档目前还是工作草案，但是正在朝着W3C推荐的方向前进。 简言之，CORS就是为了让AJAX可以实现可控的跨域访问而生的。 以往的解决方案： 以前要实现跨域访问，可以通过JSONP、Flash或者服务器中转的方式来实现，但是现在我们有了CORS。 CORS与JSONP相比，无疑更为先进、方便和可靠。 1.JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。 2.使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。 3.JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS（这部分会在后文浏览器支持部分介绍）。详细内容： 要使用CORS，我们需要了解前端和服务器端的使用方法。 1.前端 以前我们使用Ajax，代码类似于如下的方式：123var xhr = new XMLHttpRequest();xhr.open(&quot;GET&quot;, &quot;/relativeHref&quot;, true);xhr.send(); 这里的“/relativeHref”是本域的相对路径。 如果我们要使用CORS，相关Ajax代码可能如下所示： 123var xhr = new XMLHttpRequest();xhr.open(&quot;GET&quot;, &quot;http://blog.csdn.net/hfahe&quot;, true);xhr.send(); 请注意，代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。 我们还必须提供浏览器回退功能检测和支持，避免浏览器不支持的情况。1234567891011121314151617181920212223function createCORSRequest(method, url) &#123; var xhr = new XMLHttpRequest(); if (&quot;withCredentials&quot; in xhr) &#123; // 此时即支持CORS的情况 // 检查XMLHttpRequest对象是否有“withCredentials”属性 // “withCredentials”仅存在于XMLHTTPRequest2对象里 xhr.open(method, url, true); &#125; else if (typeof!= &quot;undefined&quot;) &#123; // 否则检查是否支持XDomainRequest，IE8和IE9支持 // XDomainRequest仅存在于IE中，是IE用于支持CORS请求的方式 xhr = new XDomainRequest(); xhr.open(method, url); &#125; else &#123; // 否则，浏览器不支持CORS xhr = null; &#125; return xhr;&#125;var xhr = createCORSRequest(&apos;GET&apos;, url);if (!xhr) &#123; throw new Error(&apos;CORS not supported&apos;);&#125; 原文链接http://blog.csdn.net/u013084331/article/details/51114288]]></content>
      <categories>
        <category>跨域问题</category>
      </categories>
      <tags>
        <tag>跨域问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB启动与连接]]></title>
    <url>%2F2017%2F10%2F06%2FMongoDB%E5%90%AF%E5%8A%A8%E4%B8%8E%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[什么是MongoDB MongoDB是一个基于分布式文件存储的开源数据库系统 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 MongoDB安装 windows安装 Windows官方安装指南 绿色版就是解压之后就可以用 mongodb32位绿色版 http://pan.baidu.com/s/1pLe3vM7 MongoDB64位绿色版 http://pan.baidu.com/s/1cMM9oq mongo客户端绿色版 http://pan.baidu.com/s/1kUIQlUZ Mac官方安装指南 1.先安装homebrew Homebrew简称brew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件 1http://brew.sh/ Homebrew的安装非常简单，打开终端复制、粘贴以下命令，回车，搞定 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2.使用brew安装mongodb 1brew install mongodb 3.创建数据存放目录 1sudo mkdir -p /data/db 如果提示输入密码请输入正确的密码 4.启动mongodb1sudo mongod &amp; Mac可视化工具可安装Robomongomongodb启动与连接1.windows启动服务器端 1).找到mongodb安装目录,一般是 C:\Program Files\MongoDB 2.6 Standard\bin (这里我下载到了C:\Users\Gao\Downloads\数据库\MongoDB这个目录) 2).按下Shift+鼠标右键,选择在此处打开命令窗口 3)在除C盘外的盘符新建一个空目录,例如 D:\Mongodb\data(由于我的电脑没有分盘,所以我就建在C盘下了) 在命令行中输入mongod –dbpath=刚创建的空目录,如 1mongod --dbpath=C:\data 注意：–dbpath后的值表示数据库文件的存储路径,而且后面的路径必须事先创建好，必须已经存在，否则服务开启失败 如果是windows32的系统用户，请加参数 –storageEngine=mmapv1 如 mongod --dbpath=C:\data --storageEngine=mmapv1 4)再按回车键 如果出现waiting for connections on port 27017就表示启动成功,已经在27017端口上监听了客户端的请求 注意：这个命令窗体绝对不能关,关闭这个窗口就相当于停止了mongodb服务 如果mongoVUE客户端报错 “MongoDB.Bson.BsonObjectId”的类型初始值设定项引发异常 解决方案如下：在window中打开功能里输入regedit,回车打开注册器。然后进入如下路径中 HKEY_LOCAL_MACHINE\system\CurrentControlSet\Control\Lsa\FipsAlgorithmPolicy 将enable设置为0 即可。 2.启动客户端连接服务器 1)找到mongodb安装目录,一般是 C:\Program Files\MongoDB 2.6 Standard\bin 2)按下Shift+鼠标右键,选择在此处打开命令窗口 3)命令窗体中输入 mongo –host=127.0.0.1 或者 mongo 按回车键 4)命令窗体中输入 db 按回车键可进入测试 备注：–host后的值表示服务器的ip地址,–host=127.0.0.1 表示的就是本地服务器,每次数据库都会默认连接test数据库 MongoDB基本概念 数据库 MongoDB的单个实例可以容纳多个独立的数据库，比如一个学生管理系统就可以对应一个数据库实例 集合 数据库是由集合组成的,一个集合用来表示一个实体,如学生集合 文档 集合是由文档组成的，一个文档表示一条记录,比如一位同学张三就是一个文档]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>MongoDB启动</tag>
        <tag>MongoDB连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对闭包的理解]]></title>
    <url>%2F2017%2F09%2F10%2F%E5%AF%B9%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[当函数执行的时候，会形成一个私有的作用域，保护里面的私有变量不受外界干扰，我们把这种机制叫做“闭包” 闭包 闭包是一种”机制”:函数执行形成私有的作用域(不管销毁还是不销毁),保护了里面的私有变量不受外界的干扰 然而,社会上很多人都认为”闭包”指的是:函数执行形成的那个不销毁的私有作用域才是闭包. 123456var fn = (function () &#123; var num = 12; return function () &#123; console.log(++num); &#125;&#125;)();//-&gt;JS高阶编程技巧之一：&quot;惰性思想&quot; 1、利用可以形成不销毁的私有的作用域的原理，把我们需要保存的内容，存储到这个不销毁的作用域中 2、避免全局变量之间的冲突，保护里面的变量不受外界的干扰 -&gt;所有框架/类库的源码都是写在一个闭包函数中的,目的就是为了不和别人的代码冲突123456var name = &quot;china&quot;;var age = 5000;(function () &#123; var name = &quot;中国&quot;; var age = 100;&#125;)(); [jQuery]123456789(function (global, factory) &#123; //&lt;JS CODE&gt; var jQuery = function () &#123; &#125;; window.jQuery = window.$ = jQuery;//-&gt;让私有的变量在全局下依然可以使用,我们可以使用window.xxx=xxx来进行处理 //-&gt;当前的这个作用域是不销毁的,因为函数里面的jQuery对应的地址被window下的jQuery和$给占用了 &#125;)(); jQuery(); 使用闭包的注意点 （1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 （2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>对闭包的理解</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP缓存机制详解(转载)]]></title>
    <url>%2F2017%2F09%2F10%2FHTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3-%E8%BD%AC%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[原文链接http://www.cnblogs.com/chenqf/p/6386163.html]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>http缓存机制</tag>
        <tag>http</tag>
        <tag>js</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秒懂Vuejs、Angular、React原理和前端发展历史(转载)]]></title>
    <url>%2F2017%2F09%2F10%2F%E7%A7%92%E6%87%82Vuejs%E3%80%81Angular%E3%80%81React%E5%8E%9F%E7%90%86%E5%92%8C%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2(%E8%BD%AC%E8%BD%BD)%2F</url>
    <content type="text"><![CDATA[前端程序发展的历史 现在流行的框架：Vue.Js、AngularJs、ReactJs，已经逐渐应用到各个项目和实际应用中，它们都是MVVM数据驱动框架系列的一种。 回顾一下前端发展的历史阶段,引用了 廖雪峰老师网站总结的一段话:123456789在上个世纪的1989年，欧洲核子研究中心的物理学家Tim Berners-Lee发明了超文本标记语言（HyperText Markup Language），简称HTML，并在1993年成为互联网草案。从此，互联网开始迅速商业化，诞生了一大批商业网站。最早的HTML页面是完全静态的网页，它们是预先编写好的存放在Web服务器上的html文件。浏览器请求某个URL时，Web服务器把对应的html文件扔给浏览器，就可以显示html文件的内容了。如果要针对不同的用户显示不同的页面，显然不可能给成千上万的用户准备好成千上万的不同的html文件，所以，服务器就需要针对不同的用户，动态生成不同的html文件。一个最直接的想法就是利用C、C++这些编程语言，直接向浏览器输出拼接后的字符串。这种技术被称为CGI：Common Gateway Interface。很显然，像新浪首页这样的复杂的HTML是不可能通过拼字符串得到的。于是，人们又发现，其实拼字符串的时候，大多数字符串都是HTML片段，是不变的，变化的只有少数和用户相关的数据，所以，又出现了新的创建动态HTML的方式：ASP、JSP和PHP等——分别由微软、SUN和开源社区开发。在以前：在ASP中，一个asp文件就是一个HTML，但是，需要替换的变量用特殊的&lt;%=var%&gt;标记出来了，再配合循环、条件判断，创建动态HTML就比CGI要容易得多。但是，一旦浏览器显示了一个HTML页面，要更新页面内容，唯一的方法就是重新向服务器获取一份新的HTML内容。如果浏览器想要自己修改HTML页面的内容，怎么办？那就需要等到1995年年底，Java被引入到浏览器。有了Java后，浏览器就可以运行Java，然后，对页面进行一些修改。Java还可以通过修改HTML的DOM结构和CSS来实现一些动画效果，而这些功能没法通过服务器完成，必须在浏览器实现。 揭开MVVM原理 Java操作HTML 至于 js如何在浏览器执行，这又是另外一个资深课题了（前端真的是只是庞杂），这里我们不做研究，有兴趣的可以自己去搜资料。我们只需要知道浏览器就是也JS执行容器，执行完之后，通过页面显示结果就行了，就像java需要编译器一样原理。 用Java在浏览器中操作HTML，也经历了若干发展阶段： 我们利用【小北最帅】这个案例来展示 【第一阶段】 是JS原生通过浏览器解析机制，它的原理是使用浏览器提供的原生API 结合JS语法，可以直接操作DOM，如：12345678910//HTML:&lt;divid=&quot;name&quot;style=&quot;color:#fff&quot;&gt;前端你别闹&lt;/div&gt;&lt;divid=&quot;age&quot;&gt;3&lt;/div&gt;//Java:var dom1 = document.getElementById(&apos;name&apos;);var dom2 = document.getElementById(&apos;age&apos;);dom1.innerHTML = &apos;小北&apos;;dom2.innerHTML = &apos;666&apos;;dom1.style.color = &apos;#000000&apos;; // css样式也可以操作//结果变成：&lt;divid=&quot;name&quot;style=&quot;color:#fff&quot;&gt;小北&lt;/div&gt;&lt;divid=&quot;age&quot;&gt;&apos;666&lt;/div&gt; 【第二阶段】 我用一个字总结 就是懒，就是我们上一篇说的jQuery时代，由于原生API晦涩难懂，语法很长不好用，最重要的是要考虑各种浏览器兼容性，因为他们的解析标准都不一样，造成了，写一段效果代码要写很多的兼容语法，令人沮丧，所以jQuery的出现，迅速占领了世界。 上边的例子用 jQuery 是这样的123456//HTML:&lt;divid=&quot;name&quot;style=&quot;color:#fff&quot;&gt;前端你别闹&lt;/div&gt;&lt;divid=&quot;age&quot;&gt;3&lt;/div&gt;//Java: jQuery 一句话就行$(&apos;#name&apos;).text(&apos;小北好帅&apos;).css(&apos;color&apos;, &apos;#000000&apos;);$(&apos;#age&apos;).text(&apos;666&apos;).css(&apos;color&apos;, &apos;#fff&apos;);//结果变成：&lt;divid=&quot;name&quot;style=&quot;color:#fff&quot;&gt;小北好帅&lt;/div&gt;&lt;divid=&quot;age&quot;&gt;666&lt;/div&gt; 【第三阶段】MVC模式， 需要服务器端配合，Java可以在前端修改服务器渲染后的数据。 一句话就是所有通信都是单向的： 也就是前期我们最常用的状态，提交一次反馈一次，通信一次相互制约。 比如：提交表单 填写内容 → 点击提交 →业务逻辑处理 →存入数据库 → 刷新页面→服务器取数据库数据→渲染到客户端页面→ 展示上一次你提交的内容 MVC: 视图（View）：用户界面。 控制器（Controller）：业务逻辑 模型（Model）：数据保存 各部分之间的通信方式如下“MVC” View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 这个模式缺点是什么呢？ 缺点一：它必须等待服务器端的指示，而且如果是异步模式的话，所有html节点、数据、页面结构都是后端请求过来。- 浏览器只作为一个解析显示容器，Model 作用几乎是废x，Model 层面做的很少几乎前端无法控制，你前端几乎是切图仔和做轮播图的工作/哭 缺点二：因为你前端渲染的页面结构，几乎是后端服务器包扎一堆数据一起发送过来，前端的你只需要用拼接字符串 或者字符串拼接引擎 比如Mustache、Jade、artTemplate、tmpl、kissyTemplate、ejs等来做事，说白了纯苦力和重复工作居多，这也导致了，如果很多人认为前端并不重要，只负责美工 和 动作体验就好了。 缺点三：一发而动全身。数据、显示不分离！为什么这么说，因为如果业务逻辑要变，比如很简单的需求，你用jsp或者php 拼接出来的ajax数据页面，年龄这个字段我不需要了，把性别字段 区分开，男的单独显示，女的单独显示，以前是一起显示到一个表的 那么，后端先要sql查询把 男、女数据分开，然后渲染字符串时候把 年龄 这个字段去除，然后把男女分开成2个table，然后再推送给前端接收。 前端收到了，然后从新在渲染一遍，在加工一次页面甚至是展示动作效果。。。（前后端一起大声喊到：加班使我快乐，呜呜呜） 【第四阶段】MVVM框架模式 MVVM最早由微软提出来，它借鉴了桌面应用程序的MVC思想，在前端页面中，把Model用纯Java对象表示，View负责显示，两者做到了最大限度的分离。也就是我们常说的，前后分离，真正在这里得以实现“MVVM” 它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然,model数据的变动，也自动展示给页面显示 把Model和View关联起来的就是ViewModel。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。 可能理论知识枯燥无味，那么我们还是实战派，来看代码不就好了吗？ 还是刚才的 【小北最帅】案例 由于数据驱动模式的精髓在于【数据】和【视图】分离，所以我们首先并不关心DOM结构，而是关心数据的展现。 最简单的数据存储方式是什么呢？显然不是mysql、数据库而是使用Java对象 123456789//HTML: 这次我不关心你了，哼哼//Java: JS基础对象/原始数据varxiaobei = &#123; name: &apos;前端你别闹&apos;, age: 3，tag：&apos;干货&apos;&#125;;//结果是：name:前端你别闹age:3tag:干货 假设：我们把变量xiaobei 看作Model数据，把HTML某些DOM节点看作View，并意淫它们已经通过某种手段被关联起来了。 下面我们把name 从”前端你别闹” 改为 “小北”，把显示的age从 “3” 改为 “666”，tag变成 “最帅!” 按照以前我们肯定操作DOM节点，而现在我们只需要修改Java对象：12345678Java:// JS基础对象// 改变的数据 varxiaobei = &#123; name: &apos;小北&apos;, age: 666， tag：&apos;最帅&apos; &#125;;//结果是： name:小北 age:666 tag:最帅 通过实验和理论，小伙伴惊呆了，我们只要改变Java对象的内容，就会导致DOM结构作出对应的变化！ 这让我们的关注点从如何操作DOM变成了如何改变Java对象的状态，而操作Java对象比获取和操作DOM简单了一个地球的距离！ 这也是MVVM的核心思想：关注Model的变化，让MVVM框架利用自己的机制去自动更新DOM，从而把开发者从操作DOM的繁琐中解脱出来！ 也就是所谓的 数据 - 视图分离，数据驱动视图， 视图不影响数据，再也不用管繁琐的DOM结构操作了，世界顿时清净，完美！ 原文链接:http://www.sohu.com/a/133415335_355137?qq-pf-to=pcqq.c2c]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>vue</tag>
        <tag>前端框架</tag>
        <tag>angular</tag>
        <tag>vue原理</tag>
        <tag>angular原理</tag>
        <tag>react原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React.createClass和extends Component的区别(转载)]]></title>
    <url>%2F2017%2F09%2F09%2FReact-createClass%E5%92%8Cextends-Component%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。createClass方式的方法定义使用逗号,隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。 React.createClass和extends Component的区别主要在于： 语法区别 propType 和 getDefaultProps 状态的区别 this区别 Mixins 1.语法区别 React.createClass 1234567891011import React from &apos;react&apos;;const Contacts = React.createClass(&#123; render() &#123; return ( &lt;div&gt;&lt;/div&gt; ); &#125;&#125;);export default Contacts; React.Component 1234567891011121314import React from &apos;react&apos;;class Contacts extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;div&gt;&lt;/div&gt; ); &#125;&#125;export default Contacts; 后一种方法使用ES6的语法，用constructor构造器来构造默认的属性和状态。 2.propType和getDefaultProps React.createClass:通过proTypes对象和getDefaultProps()方法来设置和获取props. 12345678910111213141516171819import React from &apos;react&apos;;const Contacts = React.createClass(&#123; propTypes: &#123; name: React.PropTypes.string &#125;, getDefaultProps() &#123; return &#123; &#125;; &#125;, render() &#123; return ( &lt;div&gt;&lt;/div&gt; ); &#125;&#125;);export default Contacts; React.Component：通过设置两个属性propTypes和defaultProps 123456789101112131415import React form &apos;react&apos;;class TodoItem extends React.Component&#123; static propTypes = &#123; // as static property name: React.PropTypes.string &#125;; static defaultProps = &#123; // as static property name: &apos;&apos; &#125;; constructor(props)&#123; super(props) &#125; render()&#123; return &lt;div&gt;&lt;/div&gt; &#125;&#125; 3.状态的区别 React.createClass：通过getInitialState()方法返回一个包含初始值的对象 123456789101112import React from &apos;react&apos;; let TodoItem = React.createClass(&#123; // return an object getInitialState()&#123; return &#123; isEditing: false &#125; &#125; render()&#123; return &lt;div&gt;&lt;/div&gt; &#125; &#125;) React.Component：通过constructor设置初始状态 123456789101112import React from &apos;react&apos;; class TodoItem extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; // define this.state in constructor isEditing: false &#125; &#125; render()&#123; return &lt;div&gt;&lt;/div&gt; &#125; &#125; 4.this区别 React.createClass：会正确绑定this 1234567891011121314import React from &apos;react&apos;;const Contacts = React.createClass(&#123; handleClick() &#123; console.log(this); // React Component instance &#125;, render() &#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt;&lt;/div&gt;//会切换到正确的this上下文 ); &#125;&#125;);export default Contacts; React.Component：由于使用了 ES6，这里会有些微不同，属性并不会自动绑定到 React 类的实例上。 1234567891011121314151617181920import React from &apos;react&apos;;class TodoItem extends React.Component&#123; constructor(props)&#123; super(props); &#125; handleClick()&#123; console.log(this); // null &#125; handleFocus()&#123; // manually bind this console.log(this); // React Component Instance &#125; handleBlur: ()=&gt;&#123; // use arrow function console.log(this); // React Component Instance &#125; render()&#123; return &lt;input onClick=&#123;this.handleClick&#125; onFocus=&#123;this.handleFocus.bind(this)&#125; onBlur=&#123;this.handleBlur&#125;/&gt; &#125;&#125; 我们还可以在 constructor 中来改变 this.handleClick 执行的上下文，这应该是相对上面一种来说更好的办法，万一我们需要改变语法结构，这种方式完全不需要去改动 JSX 的部分： 123456789101112131415161718import React from &apos;react&apos;;class Contacts extends React.Component &#123; constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; console.log(this); // React Component instance &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt;&lt;/div&gt; ); &#125;&#125;export default Contacts; 5.Mixins 如果我们使用 ES6 的方式来创建组件，那么 React mixins 的特性将不能被使用了。123456789101112React.createClass：使用 React.createClass 的话，我们可以在创建组件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组的形式赋给 mixins。import React from &apos;react&apos;;let MyMixin = &#123; doSomething()&#123;&#125;&#125;let TodoItem = React.createClass(&#123; mixins: [MyMixin], // add mixin render()&#123; return &lt;div&gt;&lt;/div&gt; &#125;&#125;) 原文链接https://segmentfault.com/a/1190000005863630]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>react.createClass</tag>
        <tag>extends Component</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化与组件化]]></title>
    <url>%2F2017%2F09%2F09%2F%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%2F</url>
    <content type="text"><![CDATA[组件化和模块化的中心思想都是分而治之。目的都是将一个庞大的系统拆分成多个组件或者说是模块。 模块化的定义1Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality. 简单来说,模块化就是将一个程序按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容。模块我们相对熟悉,比如登录功能可以是一个模块,搜索功能可以是一个模块,汽车的发送机也可是一个模块. 组件化的定义1Component-based software engineering (CBSE), also known as component-based development (CBD), is a branch of software engineering that emphasizes the separation of concerns in respect of the wide-ranging functionality available throughout a given software system. It is a reuse-based approach to defining, implementing and composing loosely coupled independent components into systems. This practice aims to bring about an equally wide-ranging degree of benefits in both the short-term and the long-term for the software itself and for organizations that sponsor such software. 组件化就是基于可重用的目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，主要目的就是减少耦合. 一个独立的组件可以是一个软件包、web服务、web资源或者是封装了一些函数的模块。比如汽车的发动机是一个模块,也是一个组件,再或者前端中的一个日历控件是一个模块,也一个组件.这样，独立出来的组件可以单独维护和升级而不会影响到其他的组件. JS/CSS模块化开发 分而治之是软件工程中的重要思想,是复杂系统开发和维护的基石,这点放在前端开发中同样适用.在解决了基本开发运行效率问题之后,前端团队开始思考维护效率,模块化是目前前端最流行的分治手段. 模块化开发的最大价值应该是分治. 不管你将来是否要复用某段代码,你都有充分的理由将其分治为一个模块 组件化开发 分治的确是非常重要的工程优化手段.前端作为一种GUI软件,光有JS/CSS的模块化还不够,对于UI组件的分治也有着同样迫切的需求 1.页面上的每个独立的可是/可交互区域都可以视为一个组件 2.每个组件对应一个工程目录,组件所需的各种资源都在这个目录下就近维护 3.由于组件具有独立性,因此组件与组件之间可以自由组合 4.页面只不过是组合的容器,负责组合组件形成功能完整的界面 5.当不需要某个组件,或者想要替换组件时,可以整个目录删除替换 组件化vs模块化 组件和模块是一对容易混淆的名词,也常常被用来相互替换,两者是否有差异往往取决于专业背景、所在领域、以及视角。从设计上来看,组件强调复用,模块强调职责(内聚、分离),或者说组件是达到可复用要求的模块 模块化强调的是拆分，无论是从业务角度还是从架构、技术角度，模块化首先意味着将代码、数据等内容按照其职责不同分离，使其变得更加容易维护、迭代，使开发人员可以分而治之。 组件化则着重于可重用性，不管是界面上反复使用的用户头像按钮，还是处理数据的流程中的某个部件，只要可以被反复使用，并且进行了高度封装，只能通过接口访问，就可以称其为“组件”。 参考网址:http://blog.csdn.net/dd864140130/article/details/53645290]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>模块化</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中toStirng()与Object.prototype.toString.call()方法浅谈转载]]></title>
    <url>%2F2017%2F09%2F09%2FJavaScript%E4%B8%ADtoStirng-%E4%B8%8EObject-prototype-toString-call-%E6%96%B9%E6%B3%95%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[一、toString()是一个怎样的方法？它是能将某一个值转化为字符串的方法。然而它是如何将一个值从一种类型转化为字符串类型的呢？通过下面几个例子，我们便能获得答案： 1.将boolean类型的值转化为string类型： 12console.log(true.toString());//&quot;true&quot;console.log(false.toString());//&quot;false&quot; 2.将string类型按其字面量形式输出： 12var str = &quot;test123y&quot;;console.log(str.toString());//&quot;test123y&quot; 3.将Object类型转化成string类型（JavaScript原生的Array类型、Date类型、RegExp类型以及Number、Boolean、String这些包装类型都是Object的子类型）：自定义Object类型（没有重新定义toString方法）： 12var obj = &#123;name:&quot;Tom&quot;, age:18&#125;;console.log(obj.toString());//&quot;[object Object]&quot;此时调用的是从Object继承来的原始的toString()方法 接下来的三个例子都是以重写的方式实现了toString()方法； 1.Array类型： 12var arr = [&quot;tom&quot;,12,&quot;rose&quot;,18];console.log(arr.toString());//&quot;tom,12,rose,18&quot; 2.RegExp类型 12var patten = new RegExp(&quot;\\[hbc\\]at&quot;, &quot;gi&quot;);console.log(patten.toString());//&quot;/\[hbc\]at/gi&quot; 3.Date类型 12var date = new Date(2014,02,26);//注意这种格式创建的日期，其月份是3月console.log(date.toString());//&quot;Wed Mar 26 2014 00:00:00 GMT+0800&quot;输出格式因浏览器不同而不同，此为firefox的输出格式； 4.Number类型也是以重写的方式实现toString()方法的，请看以下例子： (1)它可以接受一个整数参数，并将调用这个方法的数值转化成相应进制的字符串： 12345var num = 16;console.log(num.toString(2));//10000 二进制console.log(num.toString(8));//20 八进制console.log(num.toString(16));//10 十六进制console.log(num.toString(5));//31 虽然没有五进制，但是这样传参是可以被toString()方法接受的 (2)再看下面的代码： 1234567console.log(1.toString());//这种写法会报错语法错误，但是下面的写法都是合法的；console.log((1).toString());//&quot;1&quot;console.log(typeof (1).toString());//stringconsole.log(1..toString());//&quot;1&quot;console.log(typeof (1).toString());//stringconsole.log(1.2.toString());//&quot;1&quot;console.log(typeof (1).toString());//string 这是因为javascript引擎在解释代码时对于“1.toString()”认为“.”是浮点符号，但因小数点后面的字符是非法的，所以报语法错误； 而后面的“1..toString()和1.2.toStirng()”写法，javascript引擎认为第一个“.”小数点，的二个为属性访问语法，所以都能正确解释执行； 对于“(1).toStirng()”的写法，用“()”排除了“.”被视为小数点的语法解释，所以这种写法能够被解释执行； (3)纯小数的小数点后面有连续6或6个以上的“0”时，小数将用e表示法进行输出； 1234var num = 0.000006;//小数点后面有5个“0”console.log(num.toString());//&quot;0.000006&quot;var num = 0.0000006;//小数点后面有6个“0”console.log(num.toString());//&quot;6e-7&quot; (4)浮点数整数部分的位数大于21时，输出时采用e表示法； 12var num = 1234567890123456789012;console.log(num.toString());//&quot;1.2345678901234568e+21&quot; 看到这里大家难免会有些疑问，这些基本的数据类型的值都是常量，而常量是没有方法的，为什么能够调用方法呢？答案是这样的，五种基本类型除了null、undefined以外都有与之对应的特殊的引用类型——包装类型。当代码被解释执行时，底层会对基本类型做一个类型转换，即将基本类型转换成引用类型，这样就可以调用相应引用类型有权访问到的方法。 二、toString()方法定义在何处？ 运行以下代码： 12345678var pro = Object.prototype;var pr = pro.__proto__;//ie11之前版本不支持该属性console.log(typeof pro);//&quot;object&quot;console.log(String(pro));//&quot;[object Object]&quot;console.log(pro.hasOwnProperty(&quot;toString&quot;));//trueconsole.log(typeof pr);//&quot;object&quot;console.log(String(pr));//&quot;null&quot;console.log(pr.hasOwnProperty(&quot;toString&quot;));//报错 由此可知，toString()定义在Object.prototype上； 三、使用Object.prototype上的原生toString()方法判断数据类型，使用方法如下：Object.prototype.toString.call(value) 1.判断基本类型： 12345Object.prototype.toString.call(null);//”[object Null]”Object.prototype.toString.call(undefined);//”[object Undefined]”Object.prototype.toString.call(“abc”);//”[object String]”Object.prototype.toString.call(123);//”[object Number]”Object.prototype.toString.call(true);//”[object Boolean]” 2.判断原生引用类型： 函数类型 12Function fn()&#123;console.log(“test”);&#125;Object.prototype.toString.call(fn);//”[object Function]” 日期类型 12var date = new Date();Object.prototype.toString.call(date);//”[object Date]” 数组类型 12var arr = [1,2,3];Object.prototype.toString.call(arr);//”[object Array]” 正则表达式 12var reg = /[hbc]at/gi;Object.prototype.toString.call(arr);//”[object Array]” 自定义类型 123456function Person(name, age) &#123; this.name = name; this.age = age;&#125;var person = new Person(&quot;Rose&quot;, 18);Object.prototype.toString.call(arr); //”[object Object]” 很明显这种方法不能准确判断person是Person类的实例，而只能用instanceof 操作符来进行判断，如下所示： 1console.log(person instanceof Person);//输出结果为true 3.判断原生JSON对象： 12var isNativeJSON = window.JSON &amp;&amp; Object.prototype.toString.call(JSON);console.log(isNativeJSON);//输出结果为”[object JSON]”说明JSON是原生的，否则不是； 注意：Object.prototype.toString()本身是允许被修改的，而我们目前所讨论的关于Object.prototype.toString()这个方法的应用都是假设toString()方法未被修改为前提的。 本文所讨论内容多参考于《JavaScrip高级编程》第三版，另因个人水平有限，如有描述不当之处还请高手指正。 原文链接http://www.jianshu.com/p/5c6503279685]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>toStirng()</tag>
        <tag>Object.prototype.toString.call()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则基础]]></title>
    <url>%2F2017%2F09%2F05%2F%E6%AD%A3%E5%88%99%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[正则的作用 正则是来处理复杂字符串的 1.正则的匹配 test返回值=&gt;true,false 2.正则的捕获 把匹配内容找出来,exec方法 1var reg=/9/g; 正则的组成 1.元字符,写在//中间的全是元字符 2.修饰符 写在//后面 g(全局匹配),i(忽略大小写),m(换行匹配)注意:一个元字符只能匹配一个字符 1-1.特殊意义的元字符 1). \ 转义字符,一般都是把具有特殊意义的字符变成仅仅是本身意思的字符 12345var str=&apos;I\&apos;m a person&apos;; var reg=/./; reg.test(str);//true var reg=/\./; reg.test(&quot;1.1&quot;);//true 2). ^ 以什么什么开始 123var reg=/^1/; reg.test(&quot;123445464&quot;);//true reg.test(&quot;0001&quot;);//false 3). $ 以什么什么结尾 123var reg=/m$/;reg.test(&quot;mq&quot;);//falsereg.test(&quot;qm&quot;);//true 应用 12var reg=/^6$/;//只匹配&quot;6&quot;var reg=/^\d$/;//只匹配一个0-9中的任意一位数的字符串 4). \d 匹配0-9中任意一个字符 5). \D 除了\d以外任意一个字符 6). \w 匹配0-9,a-z,A-Z,_这63个中的任意一个 7). \W 匹配除了\w以外的任意一个 8). \n 匹配一个换行符 12var str=&quot;abc\nefd&quot;;console.log(str); 9). \s 匹配一个空白符(空格 制表符 换页符) 10). \S 匹配除了\s以外的任意一个字符 11). \b 匹配一个边界 12). \B 匹配一个非边界 13). . 除了\n以外的任意一个字符 12345var reg=/\d\w/;reg.test(&quot;1.2&quot;);//falsereg.test(&quot;1-2&quot;);//falsereg.test(&quot;1&quot;);//falsereg.test(&quot;1w&quot;);//true 123var reg=/^\s\w\s$/;//字符串length是三reg.test(&quot; w &quot;);var reg=/^\s\s\s$/;// &quot; &quot; 12var reg=/\baa\B/;reg.test(&quot;a aa a aaa&quot;);//true 1-2. 量词元字符(量词元字符一定要写在元字符的后面) 1) * 前面的元字符出现0到多次 2) + 前面的元字符出现1到多次 3) ? 前面的元字符出现0次或者1次 4) {number} 前面的元字符出现number次 5) {number,} 前面的元字符出现number到多次 6) {number,m} 前面的元字符出现number到m次 123456789101112var reg=/\d*/;reg.test(&quot;&quot;);//truereg.test(&quot;1&quot;);//truereg.test(&quot;111&quot;);//truereg.test(&quot;wwww...&quot;);//truevar reg=/^\w&#123;4&#125;1+$/;//length&gt;=5reg.test(&quot;111111&quot;);//truereg.test(&quot;abcd2&quot;);//falsereg.test(&quot;121221&quot;);//falsevar reg=/^1\d&#123;10&#125;$/; 1-3.中括号[] 1). x|y x或y中的一个 2). [xyz] xyz中的一个 3). [^xyz] 不是xyz中的任意一个 4). [a-z] a-z中的任意一个 在中括号中除了上面说的具有特殊意义的字符都只是代表本身的意思,但是转义字符\仍然是转义 1234var reg=/^[\d.]$/;//字符串的length=1reg.test(&quot;q&quot;);//falsereg.test(&quot;1.&quot;);//falsereg.test(&quot;.&quot;);//true 在没有小括号的情况下,|最后运算 123456789var reg=/^10|20$/;//以10开头 或者 以20结尾reg.test(&quot;1000D&quot;);//truereg.test(&quot;00020&quot;);//truereg.test(&quot;10201020&quot;);//truevar reg=/^(10|20)$/;//&quot;10&quot; &quot;20&quot; 以10开头结尾 或者 以20开头结尾var reg=/^[1020]$/;//&quot;1&quot; &quot;0&quot; &quot;2&quot;var reg=/^[10-20]$/;//&quot;1&quot; &quot;0-2&quot; &quot;0&quot;var reg=/^[16-20]$/;//不对的 举例 1.21-26的正则 1var reg=/^2[1-6]$/; 2.18-75的正则 可以将18-75差分为:18-19,20-69 70-75 1var reg=/^(1[8-9]|[2-6]\d|7[0-5])$/; 3.在正则中小括号表示分组 作用: 1)改变优先级 先计算括号里面的 2)表示一个小分组 例如:\number ，表示第number个分组匹配的内容12var reg=/^(\w)(\w&#123;2&#125;)\2\1$/;reg.test(&quot;_dcdc_&quot;)]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>正则</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getter&setter]]></title>
    <url>%2F2017%2F09%2F05%2Fgetter-setter%2F</url>
    <content type="text"><![CDATA[一般在书上看到都解释都是 把成员变量直接暴露在外不符合OOP的封装性原则，不安全，应该使用getter和setter方法来取值和赋值。但是没有解释为什么不符合OOP的封装性原则，为什么不安全，一个成员变量不就是取值和赋值这么两个操作吗，还能干什么，暴露出来又怎么样？ 的确可以暴露，如果 所有内外代码都是你自己写； 这个模块再也不改了； 不会继承它，或者继承但不改变语义。 David John Wheeler有一句名言：“All problems in computer science can be solved by another level of indirection(翻译:“计算机科学中的所有问题都可以通过另一种间接方式来解决).”getter、setter就是个很好的中间层。 直接摘录stackoverflow上一个不错的总结： oop - Why use getters and setters? 1.这两个方法可以方便增加额外功能（比如验证）。 2.内部存储和外部表现不同。 3.可以保持外部接口不变的情况下，修改内部存储方式和逻辑。 4.任意管理变量的生命周期和内存存储方式。提供一个debug接口。 5.能够和模拟对象、序列化乃至WPF库等融合。 6.允许继承者改变语义。 7.可以将getter、setter用于lambda表达式。（大概即作为一个函数，参与函数传递和运算） 8.getter和setter可以有不同的访问级别。 lambda表达式 Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。 lambda [&#39;læmdə] 希腊字母的第11个λ expression [ɪkˈspreʃn] 表达 abstraction [əb&#39;strækʃ(ə)n] 抽象概念以下为转载: Compiling the list up here at the top of what seemed winners to me, from the viewpoint of a Java web dev:(从Java web开发人员的角度来看，在我看来是赢家的列表上面列出了这个列表:) 1.When you realize you need to do more than just set and get the value, you don’t have to change every file in the codebase.当您意识到您需要做的不仅仅是设置和获取值时，您不必更改代码库中的每个文件。 2.You can perform validation here.您可以在这里执行验证。 3.You can change the value being set.您可以更改设置的值。 4.You can hide the internal representation. getAddress() could actually be getting several fields for you.您可以隐藏内部表示。getAddress()实际上可以为您获取多个字段。 5.You’ve insulated your public interface from changes under the sheets.您已经将您的公共接口与表单下的更改隔离了。 6.Some libraries expect this. Reflection, serialization, mock objects.一些图书馆预计。反射,序列化,模拟对象。 7.Inheriting this class, you can override default functionality.继承这个类，您可以覆盖默认的功能。 8.You can have different access levels for getter and setter.对于getter和setter，您可以有不同的访问级别。 9.Lazy loading.延迟加载；懒装载；懒加载 10.People can easily tell you didn’t use Python.人们可以很容易地告诉您，您没有使用Python。 参考链接: https://stackoverflow.com/questions/1568091/why-use-getters-and-setters https://www.zhihu.com/question/21401198/answer/18113707]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>getter</tag>
        <tag>setter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios和android 浏览器适配问题总结]]></title>
    <url>%2F2017%2F09%2F03%2Fios%E5%92%8Candroid-%E6%B5%8F%E8%A7%88%E5%99%A8%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.防止手机中网页放大和缩小1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0&quot; /&gt; 2.安卓浏览器看背景图片,有些设备会模糊? 用同等比例的图片在PC机上很清楚，但是手机上很模糊，原因是什么呢？ 经过研究,发现是devicePixelRatio作怪，因为手机分辨率太小，如果按照分辨率来显示网页，这样字会非常小，所以苹果当初就把iPhone 4的960640分辨率，在网页里只显示了480320，这样devicePixelRatio＝2。现在android比较乱，有1.5的，有2的也有3的。 想让图片在手机里显示更为清晰，必须使用2x的背景图来代替img标签（一般情况都是用2倍）。 例如一个div的宽高是100，背景图必须得宽高是200，然后background-size:contain;这样显示出来的图片就比较清晰了。123456background:url(../images/icon/all.png) no-repeat center center;-webkit-background-size:50px 50px;background-size: 50px 50px;display:inline-block;width:100%;height:50px; 3.一些情况下对非可点击元素(如label/span)监听click事件，ios下不会触发 解决方案:css增加cursor:pointer; 4.在ios和andriod中,audio元素和video元素无法自动播放 这个不是 BUG，由于自动播放网页中的音频或视频，会给用户带来一些困扰或者不必要的流量消耗，所以苹果系统和安卓系统通常都会禁止自动播放和使用 JS 的触发播放，必须由用户来触发才可以播放。 解决方法思路:先通过用户 touchstart 触碰,触发播放并暂停(音频开始加载,后面用 JS 再操作就没问题了)。1234document.addEventListener(&apos;touchstart&apos;,function() &#123; document.getElementsByTagName(&apos;audio&apos;)[0].play(); document.getElementsByTagName(&apos;audio&apos;)[0].pause();&#125;); 5.fixed定位缺陷 ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位, android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位 , ios4下不支持position:fixed; 解决方案:可用iScroll插件解决这个问题 6.Input的placeholder会出现文本位置偏上的情况 PC端设置line-height等于height能够对齐，而移动端仍然是偏上 解决方案:设置line-height:normal; 7.圆角bug 某些Android手机圆角失效 解决方案:1background-clip:padding-box; 8.IOS中input键盘事件keyup、keydown、keypress支持不是很好 问题是这样的，用input search做模糊搜索的时候，在键盘里面输入关键词，会通过ajax后台查询，然后返回数据，然后再对返回的数据进行关键词标红。用input监听键盘keyup事件，在安卓手机浏览器中是可以的，但是在ios手机浏览器中变红很慢，用输入法输入之后，并未立刻响应keyup事件，只有在通过删除之后才能相应！ 解决办法:可以用html5的oninput事件去代替keyup,然后就达到类似keyup的效果！123456&lt;input type=&quot;text&quot; id=&quot;testInput&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;document.getElementById(&apos;testInput&apos;).addEventListener(&apos;input&apos;,function(e)&#123; var value = e.target.value;&#125;);&lt;/script&gt; 9.部分机型存在type为search的input,自带close按钮样式修改方法; 有些机型的搜索input控件会自带close按钮(一个伪元素)，而通常为了兼容所有浏览器，我们会自己实现一个，此时去掉原生close按钮的方法为: 123#Search::-webkit-search-cancel-button&#123; display:none;&#125; 如果想使用原生close按钮，又想使其符合设计风格，可以对这个伪元素的样式进行修改。 10.手机浏览器独有的四个事件 onTouchmove,ontouchend,ontouchstart,ontouchcancel 11.为什么要用Zepto? jquery适用于PC端桌面环境，桌面环境更加复杂，jquery需要考虑的因素非常多，尤其表现在兼容性上面，相对于PC端，移动端的发展都远不及PC端,手机上的带宽永远比不上pc端。pc端下载jquery到本地只需要1~3秒（90+K），但是移动端就慢了很多，2G网络下你会看到一大片空白网页在加载，相信用户第二次就没打开的欲望了。zepto解决了这个问题，只有不到10K的大小，2G网络环境下也毫无压力，表现不逊色于jquery。 IOS移动端click事件300ms的延迟响应 详解地址https://gaodaxiu0406.github.io/2017/07/28/%E7%A7%BB%E5%8A%A8%E7%AB%AFclick300-380ms%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98/,这是之前做的关于这个问题的详细讲解地址 点击穿透问题,input、select、a等元素可以被点击和focus 这个在特定需求下才会有，因此如果没有类似问题的可以不看。首先需求是浮层操作，在手机上被遮罩的元素依然可以获取focus、click、change)，有两种解决方案： 1.是通过层显示以后加入对应的class名控制，截断显示层下方可获取焦点元素的事件获取 2.是通过将可获取焦点元素加入的disabled属性，也可以利用属性加dom锁定的方式（disabled的一种变换方式）]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>ios</tag>
        <tag>android</tag>
        <tag>浏览器适配</tag>
        <tag>ios浏览器适配</tag>
        <tag>android浏览器适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vertical-align]]></title>
    <url>%2F2017%2F09%2F01%2Fvertical-align%2F</url>
    <content type="text"><![CDATA[vertical-align 改变基线对齐方式 vertical-align: top; 顶部对齐 vertical-align: bottom; 底部对齐 vertical-align: middle; 中部对齐 |值|描述||—-|—-||长度|通过距离升高（正值）或降低（负值）元素。’0cm’等同于’baseline’||百分值 – %|通过距离（相对于1line-height1值的百分大小）升高（正值）或降低（负值）元素。’0%’等同于’baseline’||baseline|默认。当前元素的基线与父元素的基线对齐。||sub|降低元素的基线到父元素合适的下标位置。||super|升高元素的基线到父元素合适的上标位置。||top|所有平级元素,去找最高(高度最高)元素的顶部进行对齐||text-top|把元素的顶端与父元素内容区域的顶端对齐。||middle|所有平级元素,去找最高(高度最高)元素的中部进行对齐||bottom|所有平级元素,去找最高(高度最高)元素的底部进行对齐||text-bottom|把元素的底端与父元素内容区域的底端对齐。||inherit|采用父元素相关属性的相同的指定值| 浏览器支持 所有浏览器都支持 vertical-align 属性。 注释：任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 “inherit”。 深入理解line-height与vertical-align推荐地址:http://www.cnblogs.com/xiaohuochai/p/5271217.html]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>vertical-align</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Chrome动画”卡顿”的办法]]></title>
    <url>%2F2017%2F08%2F31%2F%E8%A7%A3%E5%86%B3Chrome%E5%8A%A8%E7%94%BB%E2%80%9D%E5%8D%A1%E9%A1%BF%E2%80%9D%E7%9A%84%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[解决Chrome动画”卡顿”的办法,为动画DOM元素添加CSS3样式 123-webkit-transform:transition3d(0,0,0);//或-webkit-transform:translateZ(0); 这两个属性都会开启GPU硬件加速模式，从而让览器在渲染动画时从CPU转向GPU; 其实说白了这是一个小伎俩，也可以算是一个Hack，-webkit-transform:transition3d和-webkit-transform:translateZ其实是为了渲染3D样式，但我们设置值为0后，并没有真正使用3D效果，但浏览器却因此开启了GPU硬件加速模式。 这种GPU硬件加速在当今PC机及移动设备上都已普及，在移动端的性能提升是相当显著地，所以建议大家在做动画时可以尝试一下开启GPU硬件加速。 当然也可以这样开启所有浏览器的GPU硬件加速： 12345webkit-transform: translateZ(0);-moz-transform: translateZ(0);-ms-transform: translateZ(0);-o-transform: translateZ(0);transform: translateZ(0); 或者: 12345webkit-transform: translate3d(0,0,0);-moz-transform: translate3d(0,0,0);-ms-transform: translate3d(0,0,0);-o-transform: translate3d(0,0,0);transform: translate3d(0,0,0); 使用-webkit-transform:transition3d(0,0,0)开启GPU硬件加速的chrome中渲染动画性能明显顺畅了许多 chrome诡异的Bug 对所有动画DOM元素添加-webkit-transform:transition3d(0,0,0)开启GPU硬件加速之后，又出现了一个chrome诡异的Bug 当你有多个position:absolute;元素添加-webkit-transform:transition3d(0,0,0);开启GPU硬件加速之后，会有几个元素凭空消失 这可能是跟添加-webkit-transform之后chrome尝试使用GPU硬件加速有关系，最后还是要等待Chrome官方更新解决了，当前Chrome版本是33。如果谁发现比较好的解决办法，欢迎提出^_^ 如何避免这个问题 在使用-webkit-transform尝试对很多DOM元素编写3D动画时，尽量不要对这些元素及他们的父元素使用position:absolute/fixed。(其实这种情况很难避免) 临时解决办法是,减少使用-webkit-transform:transition3d(0,0,0)的DOM元素数量，例如从9个减至6个就没有元素消失的现象了。 开启GPU硬件加速可能触发的问题： 通过-webkit-transform:transition3d/translateZ开启GPU硬件加速之后，有些时候可能会导致浏览器频繁闪烁或抖动，可以尝试以下办法解决之:12-webkit-backface-visibility:hidden;-webkit-perspective:1000; 如何监测动画帧速率 推荐两种实时监测网页渲染帧速率的方法： 1.Chrome的DevTool中TimeLine的Frame模块 2.地址栏输入”chrome:flags”搜索”fps”，将”FPS计数器”开启，浏览器重启后右上角会实时显示帧速率。 通过-webkit-transform:transition3d/translateZ开启GPU硬件加速的适用范围： 使用很多大尺寸图片(尤其是PNG24图)进行动画的页面。 页面有很多大尺寸图片并且进行了css缩放处理，页面可以滚动时。 使用background-size:cover设置大尺寸背景图，并且页面可以滚动时。(详见:https://coderwall.com/p/j5udlw) 编写大量DOM元素进行CSS3动画时(transition/transform/keyframes/absTop&amp;Left) 使用很多PNG图片拼接成CSS Sprite时 暂时只有这五种情况，欢迎大家补充 通过开启GPU硬件加速虽然可以提升动画渲染性能或解决一些棘手问题，但使用仍需谨慎，使用前一定要进行严谨的测试，否则它反而会大量占用浏览网页用户的系统资源，尤其是在移动端，肆无忌惮的开启GPU硬件加速会导致大量消耗设备电量，降低电池寿命等问题。参考地址:http://blog.bingo929.com/transform-translate3d-translatez-transition-gpu-hardware-acceleration.html]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>Chrome动画”卡顿”</tag>
        <tag>Chrome动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为HEXO博客中每篇文章的浏览量统计]]></title>
    <url>%2F2017%2F08%2F21%2F%E4%B8%BAHEXO%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%AF%8F%E7%AF%87%E6%96%87%E7%AB%A0%E7%9A%84%E6%B5%8F%E8%A7%88%E9%87%8F%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[静态网站建站现在有很多快速的技术和平台，但静态是优点也有缺点，由于是静态的，一些动态的内容如评论、计数等等模块就需要借助外来平台，评论有”多说”，计数有”不蒜”！（多说即将关闭，不蒜子还活着涅，这是程序员对程序员的承诺。） “不蒜子”与百度统计谷歌分析等有区别：”不蒜子”可直接将访问次数显示在您在网页上（也可不显示）；对于已经上线一段时间的网站，”不蒜子”允许您初始化首次数据。。 普通用户只需两步走：一行脚本+一行标签，搞定一切。追求极致的用户可以进行任意DIY。 一、安装脚本（必选） 要使用不蒜子必须在页面中引入busuanzi.js，目前最新版如下。 12&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 不蒜子可以给任何类型的个人站点使用，如果你是用的hexo，打开themes/你的主题/layout/_partial/footer.ejs添加上述脚本即可，当然你也可以添加到 header 中。 二、安装标签（可选） 只需要复制相应的html标签到你的网站要显示访问量的位置即可。您可以随意更改不蒜子标签为自己喜欢的显示效果，内容参考第三部分扩展开发。根据你要显示内容的不同，这分几种情况。 1、显示站点总访问量 要显示站点总访问量，复制以下代码添加到你需要显示的位置。有两种算法可选： 算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 123&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。 1234&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt;如果你是用的hexo，打开themes/你的主题/layout/_partial/footer.ejs添加即可。 2、显示单页面访问量 要显示每篇文章的访问量，复制以下代码添加到你需要显示的位置。 算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。 123&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; 本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 代码中文字是可以修改的，只要保留id正确即可。 注意：不蒜子为保持极简，暂不支持在站点文章摘要列表中（如首页）逐个显示每篇文章的阅读次数，如果您非常需要这一功能，可以留言。根据需要程度再考虑开发相应的功能。 3、显示站点总访问量和单页面访问量你懂的吧，上面两种标签代码都安装。 4、只计数不显示 只安装脚本代码，不安装标签代码。 至此，不蒜子已经可以正常运行，如果你还要自定义一些内容或有疑问，请继续阅读。 附录：扩展开发（自定义） 不蒜子之所以称为极客的算子，正是因为不蒜子自身只提供标签+数字，至于显示的style和css动画效果，任你发挥。 busuanzi_value_site_pv的作用是异步回填访问数，这个id一定要正确。 busuanzi_container_site_pv的作用是为防止计数服务访问出错或超时（3秒）的情况下，使整个标签自动隐藏显示，带来更好的体验。这个id可以省略。 极简模式：123本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 个性化一下：123Total &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; views.您是xxx的第&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;个小伙伴&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; Hits 问题及解答 1、我只要统计不显示？ 只引入busuanzi.js，不引入显示标签即可。 2、你的标签太丑了，我想美化一下可以么？ 可以的，您可以用自己站点的css进行控制，只要内层span的id正确以便回填访问次数即可，甚至标签都可以不是span。 3、中文字体太丑了，我的主题不适合？ 您可以将本站总访问量xxx次改成view xxx times等英文以获得更和谐的显示效果。 4、在访问量数据未取回来之前，我不想让页面显示为诸如“本站总访问量 次”，显得太low，怎么办？ 只需要如下css，不蒜子执行完毕会自动将标签显示出来，其他以此类推： 123&lt;span id=&quot;busuanzi_container_site_pv&quot; style=&apos;display:none&apos;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 原文地址:http://ibruce.info/2015/04/04/busuanzi/参考链接:https://www.zhihu.com/question/33919028]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo博客</tag>
        <tag>浏览量统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS盒子模型(border画三角形)及常见兼容问题解决方案]]></title>
    <url>%2F2017%2F08%2F21%2FCSS%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B(border%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2)%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[每一个元素在html中都是一个盒子,用来装其他盒子或者是内容 可以将html页面看做是一个仓库,仓库中从上到下摆了很多箱子,易碎品(盒子和盒子之间要有间距 内容和盒子之间要有填充 盒子本身要有厚度) 宽高属性 1.height: 100%; 指的是继承父级元素内容的高度 2.width: 100%; 指的是继承父级元素内容的宽度 特性 1.父子关系的时候,在设置margin值的时候,一般只设置上和左,不会设置下和右 2.盒子自身的宽度是由左侧边框的宽度+左侧内边距+内容的宽度+右侧内边距+右侧边框的宽度: 1ALLwidth=(border-left-width)+(padding-left)+width+(padding-right)+(border-right-width) padding和margin123456padding:1px 2px 3px 4px;//上 右 下 左 //top right bottom leftpadding:1px 2px 3px;//上 左右 下 //top left/right bottompadding:1px 2px;//上下 左右 //top/bottom left/right border12345678910111213141516border-top-width: 1px; //上边框的宽度border-top-style: solid; //上边框的样式border-top-color: red; //上边框的颜色border-color:red green yellow pink;//上 右 下 左//上边框红色 右边框绿色 下边框黄色 左边框粉色border-color:red green yellow;//上 左右 下//上边框红色 左右边框绿色 下边框黄色border-color:red green;//上下 左右//上下边框红色 左右边框绿色//合并缩写设置:border-top:1px solid pink;//上边框1px 实线 粉色border-bottom:1px solid pink;border-right:1px solid pink;border-left:1px solid pink;border:1px solid pink; 利用border画三角形123456789&lt;style&gt; div&#123; border:100px solid/* red*/; /*border-color: yellow red blue pink;*/ border-color: black transparent transparent; /*transparent透明的*/ width: 0; &#125;&lt;/style&gt; “利用border画三角形” 常见问题解决方案1.margin支持负值 margin-left和margin-top为负值的时候 跑出浏览器的部分会被吃掉,不会撑开整个页面. 2.margin-top的传递问题 如果父级没有padding-top或border-top值得时候,子元素设置margin-top值,会将这个值传递给父元素 12345678910111213141516171819202122232425262728&lt;style&gt; html,body,div&#123; padding: 0; margin: 0; background: blue; &#125; .box3&#123; width: 300px; height: 300px; background-color: green; &#125; .parent&#123; width: 200px; height: 200px; background-color: red; &#125; .son&#123; width: 100px; height: 100px; background-color: yellow; /*margin-top: 20px;*/ &#125;&lt;/style&gt;&lt;div class=&quot;box3&quot;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 此时:在IE5~11,以及谷歌浏览器中的显示都是一致的,如下图(图片以IE浏览器截图为主) 当给子元素.son设置margin-top:20px;值后 IE5~7中并没有出现margin值的传递问题(IE7同IE5,这里就没有截图了) IE8~11以及谷歌中均出现margin-top值传递问题 解决方法:方法一) 给父级元素一个属性,overflow:hidden;- 弊端: - overflow:hidden;有溢出隐藏的含义,若给父级元素添加这个属性,子级元素超出父级盒子部分将不能显示,例如子级元素的阴影 方法二) 将子级元素的margin-top值去掉,改成父级元素的padding-top值(建议使用这个方法)- 但是此方法也有弊端: - IE5中父级盒子的高度并没有改变 ![Alt margin-top传递问题](/img/margin-top传递问题5.png) - IE7~11及谷歌浏览器中,父级盒子的高度都增加了20px; ![Alt margin-top传递问题](/img/margin-top传递问题6.png) 方法三) 给父级元素上添加一个透明的border处理 弊端: 在IE5~7中确实解决了问题 但是在IE8~11及谷歌浏览器中仍然存在margin-top的传递问题 3.margin-left/margin-right 在ie6中会双倍 当元素浮动的时候,有左右的外边距,有时候ie6会出现双倍边距的问题 解决方案:解决双边距这个方法叫css hack方案一). 给这个元素添加overflow:hidden;方案二). 写ie6的兼容方式,例如:123456div&#123;float:left;margin-left:10px !important;_margin-left:5px;&lt;!-- 当浏览器是ie6的时候 读取_margin-left:5px;这句话 --&gt;&#125; 注意:!important出现在css里面的时候,这个属性会覆盖掉所有之前设置的样式权重最大,比id选择器还大 overflow盒子内容多余部分的处理方式 overflow:hidden; 直接将多余隐藏 overflow:auto; 如果有多余部分出现滚动条,如果没有就不出现 overflow:scroll; 不论是否有多余部分,都会出现滚动条]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css盒模型</tag>
        <tag>border画三角形</tag>
        <tag>兼容问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[box-shadow&text-shadow]]></title>
    <url>%2F2017%2F08%2F20%2Fbox-shadow%2F</url>
    <content type="text"><![CDATA[box-shadow 属性向框添加一个或多个阴影 相关小项目地址:https://github.com/gaodaxiu0406/HEXOcase(CSS/小项目练习) 语法CSS语法1box-shadow: h-shadow v-shadow blur spread color inset; 注释 box-shadow 向框添加一个或多个阴影。该属性是由逗号分隔的阴影列表，每个阴影由 2-4 个长度值、可选的颜色值以及可选的 inset 关键词来规定。省略长度的值是 0。 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅 CSS 颜色值。 inset 可选。将外部阴影 (outset) 改为内部阴影。 1box-shadow: 10px 20px 30px 40px #000 inset; JavaScript语法1object.style.boxShadow=&quot;10px 10px 5px #888888&quot; text-shadow语法CSS语法1text-shadow: h-shadow v-shadow blur color; 注释 text-shadow 属性向文本添加一个或多个阴影。该属性是逗号分隔的阴影列表，每个阴影有两个或三个长度值和一个可选的颜色值进行规定。省略的长度是 0。 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊的距离。 color 可选。阴影的颜色。参阅 CSS 颜色值。 1text-shadow: 10px 20px 30px #000;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>box-shadow</tag>
        <tag>text-shadow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[display]]></title>
    <url>%2F2017%2F08%2F20%2Fdisplay%2F</url>
    <content type="text"><![CDATA[根据这个属性可以将元素分成不同的类型,也会显示出不同的状态,例如属性值为block的时候,这个元素会独占一行,如果属性值为inline的时候,所有这个属性值得元素都会在一行显示,属性值为none,元素会在页面上消失. 所有元素都有天生自带的display属性和属性值,叫做内置属性 display:block; 块级元素(块状元素) 特点: 独占一行,在所在父元素内依次向下排列,从左上角开始 宽度在不设置的情况下,宽度继承父级元素内容的宽,高度由本身内容决定 可以直接设置盒子模型的所有属性(width,height,padding,border,margin) 可以嵌套其他元素(p,dt,h1-h6不能嵌套块级) dt/p 不能嵌套其他块级元素,可以嵌套行内元素等 永远会在父级盒子的左上角开始排布,从上到下排. 人为设置的样式要比自带的样式权重高块级元素这些特点,我们将其称作BFC(Block Fomatting Context–&gt;块级盒子在上下文中的渲染模式) display:inline; 行内元素 特点: 在一行显示 不能设置宽度 高度 padding margin的上下值设置不生效,左右值生效 默认宽度高度是本身内容的宽高 几个行内元素默认的垂直方向的对齐方式是基线对齐 在编辑代码时,如果行内元素之间有回车或者空格,那么在页面显示的时候,就会默认有间隙() 将父级的font-size设置为0,可以解决这个问题. 行内元素不能嵌套块级元素 display:inline-block; 行内块级元素 特点: 在一行显示 可以直接设置宽度高度padding、margin值 默认宽度高度是本身内容的宽高 几个行内元素默认的垂直方向对齐方式是基线对齐 在编辑代码时,如果行内元素之间有回车或者空格,那么在页面显示的时候,就会默认有间隙 将父级的font-size设置为0,可以解决这个问题. 行内元素不能嵌套块级元素 vertical-align改变行内元素和行内块级元素的基线对其方式 top 所有平级元素,去找最高(高度最高)元素的顶部进行对齐 bottom 所有平级元素,去找最高(高度最高)元素的底部进行对齐 middle 所有平级元素,去找最高(高度最高)元素的中部进行对齐 length(数值) px 或 % 改变对齐方式的时候,所有元素都要添加vertical-align这个属性 display:none; 将这个元素在页面上隐藏起来 如何再让设置display:none;的元素显示出来? 将none用其他的属性替换 例如:重新设置display属性为==&gt;display:block;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>display</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于png24格式的图片背景在IE6下显示不透明的解决方法]]></title>
    <url>%2F2017%2F08%2F01%2F%E5%85%B3%E4%BA%8Epng24%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%9B%BE%E7%89%87%E8%83%8C%E6%99%AF%E5%9C%A8IE6%E4%B8%8B%E6%98%BE%E7%A4%BA%E4%B8%8D%E9%80%8F%E6%98%8E%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[图片透明，锯齿问题是重构人员很头疼的问题:png8格式的透明背景图片，会让浏览器在先显示的过程中图片边缘会有一些锯齿情况，png24可以解决这些锯齿问题，但是ie6不支持png24透明 利用ie6的hack问题有两种解决的办法：1234567&lt;div class=&quot;pwdTipsBg&quot;&gt;&lt;/div&gt;&lt;div class=&quot;pwdTips&quot;&gt; &lt;span class=&quot;closeBtn&quot;&gt;&lt;/span&gt; &lt;i class=&quot;pwdTipsIcon&quot;&gt;&lt;/i&gt; 验证码错误，请填写最新获取的验证码！&lt;/div&gt; 1.利用ie6的hack问题，用两种格式的图片来表示；一种其他浏览器用png24格式的图片显示，ie6用png8格式的显示12345678910111213141516171819202122232425262728293031323334353637383940.pwdTipsBg&#123; height:100%; background:#000; opacity:0.5; position: absolute; left:0; top:0; z-index:1001; filter: alpha(opacity=50); width:100%; zoom:1; &#125;.pwdTips&#123; position:absolute; left:40%; top:40%; z-index:1009; width:285px; background:#ececec; height:55px; padding:45px 20px 10px 80px; &#125;.pwdTips i&#123; position:absolute; left:40px; top:40px; background-position:-152px -68px; width:26px; height:26px; &#125;.pwdTips span&#123; position:absolute; top:-10px; right:-15px; width:33px; height:33px; background:url(closebtn.png) no-repeat 0 0; _background:url(scsprites.png) no-repeat -119px -63px; cursor:pointer; display:block; &#125; 2.利用filter滤镜解决图片问题123456789101112.pwdTips span&#123; position:absolute; top:-10px; right:-15px; width:33px; height:33px; background:url(closebtn.png) no-repeat 0 0; _background:none; filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&quot;css/safecenter/closebtn.png&quot;); cursor:pointer; display:block; &#125; 1、书写正常的CSS代码，通过background导入图片，这样所有的浏览器均使用了此PNG图片；background:url(closebtn.png) no-repeat 0 0; 2、通过滤镜对引入图片，滤镜引入图片的时候是相对于HTML文件，而不是相对于CSS文件，语法如下：filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&quot;css/safecenter/closebtn.png&quot;) 代码写到这里，我们放到IE6下测试后发现IE6还是没有透明，因为我们虽然设置了滤镜引入图片，但是background也同样加载了此图片，又因为background的图层比滤镜设置的高，所以才没有显示出来 所以最终的代码设置为：123456789101112pwdTips span&#123; position:absolute; top:-10px; right:-15px; width:33px; height:33px; background:url(closebtn.png) no-repeat 0 0; _background:none; filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&quot;css/safecenter/closebtn.png&quot;); cursor:pointer; display:block; &#125; 优点： 1、绿色无插件； 2、效率高，速度快； 3、网速慢的时候，不会出现先灰底再透明的情况，支持远程图片； 4、支持Hover等伪类，但是得使用两张图片，网速慢的情况下，会导致第二张图片暂时无法显示，因为还没有完全载入； 缺点： 1、不支持平铺，虽然filter有sizingMethod=”scale”, 拉伸缩放模式，但是图片会变形，如果单纯的颜色或简单的渐变色还能横向平铺； 2、不支持Img标签； 3、不支持CSS Sprite； 看到很多人的logo有在ie6下面显示显示不透明，有一层淡蓝色的底，其它浏览器下都是好，这个是因为用了png24格式的图片。 那我们在制作图标的时候应该注意什么呢？（格式，透明，毛边） 如何把png24透明logo转换png8格式 1.用photoshop软件打开 你要处理的格式为png24的logo 2.photoshop菜单 文件—存储为web和设备所用格式（或者快捷键 Alt+Shift+Ctrl+S） 3.在png24那选择png8格式，最重要的一点是“杂色”颜色的选项，如果这边没有设置好就会毛刺边出现这边应该怎么设置呢？ 4.“杂色”选项的颜色应该选择和logo背景颜色最接近的 5.保存一下就可以了。 png8和png24的区别 1.PNG-8 与 PNG-24 对IE6的支持程度 PNG-24是支持alpha通道透明的格式，支持半透明，IE6不支持PNG-24,但是他完全支持PNG-8。 如果是不透明的PNG-24,IE6也是完美支持,之所以说IE6不支持PNG-24是因为PNG-24的半透明会在IE6里显示不正常。 2.PNG-8 与 PNG-24 的透明区别 PNG-8 和 gif 有一些相似之处，模式都是索引颜色，只支持像素级的纯透明，不支持 alpha 透明。我们通常说的“IE6 不支持 PNG 透明”，是指不支持 PNG-24 的透明（将透明区域显示为灰色）。但是 IE6 支持 PNG-8 的透明，就像支持 gif 的透明一样。 3.PNG-8 的高压缩比 切图时，有时选择 PNG-8 可以获得更高的压缩比。注意，是 PNG-8，不是 PNG-24。不过有些情况下还是 gif 或 jpg 会小一些，需要根据实际情况调试以选择最佳方案。 PNG-8 与 GIF PNG-8跟GIF一样支持单色透明。GIF有的PNG-8都有，GIF没有的PNG-8还有，比如:同样的文件PNG-8格式的却比GIF要小]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>png24格式的图片背景</tag>
        <tag>ie6</tag>
        <tag>图片背景ie6不透明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO主题设置(huno主题)]]></title>
    <url>%2F2017%2F07%2F31%2FHEXO%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[目前使用的主题是：next 当前文章所述主题为：huno 在博客的根目录下（即上一篇文章基于GitHub创建自己的博客https://gaodaxiu0406.github.io/2017/04/25/%E5%9F%BA%E4%BA%8EGitHub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/中提到的 HEXO 文件夹下） 克隆主题 克隆主题1git clone git://github.com/someus/huno.git themes/huno 提示:huno的github地址:https://github.com/gaodaxiu0406/huno 执行：1vim _config.yml 执行此命令后可以对此文档进行编辑 输入o进入编辑状态 将 theme 对应的值进行修改1theme: huno 修改完成 按esc键退出编辑状态 再输入:wq退出编辑窗口模式 自动部署1npm install hexo-deployer-git --save 发布1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 稍等片刻看一下自己的博客主页，你想要的效果就出现了。也可以在github或百度中搜索更多主题，挑选自己喜欢的主题进行修改，只要你快乐就好 主题配置 现在主题是更改过来了，但还有许多细节需要处理，比如说你需要修改头像等等。 每个人的设置风格不同,但基本的设置在你下载的主题中的README文件中都有介绍,你可以按照文件中的介绍配置属于自己的博客。动气手来，让你的博客亮起来 返回上篇:基于GitHub创建自己的博客https://gaodaxiu0406.github.io/2017/04/25/%E5%9F%BA%E4%BA%8EGitHub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo博客</tag>
        <tag>hexo主题</tag>
        <tag>huno</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何安装部署服务器]]></title>
    <url>%2F2017%2F07%2F31%2F%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[购买机器https://www.aliyun.com/ 123116.62.9.168用户名:root密码:Zfpx2017 连接服务器1ssh root@116.62.9.168 更新操作系统1apt-get update 安装 npm1apt-get install npm 安装node1apt-get install npm 安装node版本管理器n n是node的管理器 可以通过他管理node的版本1npm install n -g 安装node7.5版本1n 7.5 出现node-v7.5.0就安装成功了 安装mongodb1apt-get install mongodb 安装git1apt-get install git 克隆爬虫的地址1git clone https://github.com/zhufengnodejs/201704crawl.git 进入目录201704crawl1cd 201704crawl 安装依赖1npm install 启动server.js1node server.js 执行脚本main.js(先进入main.js所在的文件夹) 1.进入main.js所在的文件夹执行main.js 12cd tasksnode main.js 2.ctrl+c结束掉之前的任务,再启动server.js 1node server.js 访问(格式–&gt;ip:端口号) 在浏览器输入地址116.62.9.168:8080访问 http://116.62.9.168:8080/ 此时还是静态网页 别人无法访问 在电脑上安装程序Xftp 5安装nginx Nginx是一个高性能的HTTP和反向代理服务器 1apt-get install nginx 此时就可以上传自己的项目,访问自己的服务器 但是一旦窗口关掉,就无法访问 nginx命令 启动 nginx nginx -c /etc/nginx/nginx.conf 关闭 nginx nginx -s stop 重读配置文件 nginx -s reload kill -HUP nginx 常用命令 service nginx {start|stop|status|restart|reload|configtest|} 配置nginx反向代理和负载均衡1234567891011121314upstream crawl&#123; ip_hash; server 127.0.0.1:3000 weight=10; server 127.0.0.1:4000 weight=1;&#125;server &#123; listen 80; server_name www.gdxiu.cn; location / &#123; proxy_pass http://crawl; &#125;&#125; 安装pm2 强大的进程管理器 进程异常退出时pm2会尝试重启 1npm install pm2 -g 进入201704crawl文件夹,在根目录下执行以下命令 12cd /rootcd 201704crawl 切换到server.js文件所在目录,启动pm2应用 12pm2 start server.js --name &quot;crawl&quot;//即pm2 start server.js --name &apos;自己取名字&apos; 如何停止pm2上的项目1.查看node进程号1ps -ef | grep node 2.停止1pm2 stop crawl 3.杀死进程1kill 8796(进程号) 复活:如何重新建立连接1pm2 start server.js --name &quot;crawl&quot; 启动1pm2 start crawl pm2常用命令 用pm2启动node 命令 用途 pm2 start app.js –name “crawl” 启动应用 pm2 list 查看所有应用 pm2 restart crawl 重启应用 pm2 stop crawl 停止应用 pm2 delete crawl 删除应用 关于scp命令 网址http://www.cnblogs.com/hitwtx/archive/2011/11/16/2251254.html cat 查看文件内容 vi命令12vi crawl1000dd//删除1000行 vi的一个命令 重启服务1nginx -s reload 推荐视频地址1http://www.ablesky.com/kecheng/detail_926049]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>安装部署服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.react轮播图项目开写]]></title>
    <url>%2F2017%2F07%2F31%2F2-react%E8%BD%AE%E6%92%AD%E5%9B%BE%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%86%99%2F</url>
    <content type="text"><![CDATA[关于react轮播图的源码,无缝版已上传至github,https://github.com/gaodaxiu0406/React-Slider 用react+webpack写一个的轮播图项目(项目配置请看上篇react轮播图项目配置及原理概要) 先将整个文件写在一个文件中,1.画结构 新建一个components文件夹 components文件夹下新建Slider.js文件和Slider.less文件(Slider.less文件是用来给Slider.js写样式的) 2.在indix.js中引入组件 渲染到页面中 打开src文件夹中的index.html文件 1&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 2-1).在这个id为root的标签中渲染元素 2-2).回到index.js中,写一个轮播图组件，渲染到index.html中 12345678910import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import Slider from &apos;./components/Slider&apos;;let images=[ &#123;src:require(&apos;./images/1.jpg&apos;)&#125;, &#123;src:require(&apos;./images/2.jpg&apos;)&#125;, &#123;src:require(&apos;./images/3.jpg&apos;)&#125;, &#123;src:require(&apos;./images/4.jpg&apos;)&#125;];ReactDOM.render(&lt;Slider images=&#123;images&#125;/&gt;,document.querySelector(&apos;#root&apos;)); 解释1)引入React，引入ReactDOM，引入Slider组件 然后通过ReactDOM.render将Slider组件渲染到index.html的id为root的div标签中 解释2)Slider组件需要图片参数 src文件夹下新建一个images文件夹，存入轮播的图片 将图片路径通过require存入images数组中 通过组件Slider标签将所需的images参数传入组件Slider(让images参数变量等于images数组) 3.开始写Slider.js中的代码 需要默认导出一个组件Slider供外面文件(index.js)调用;还需要接收一个images属性进行轮播 1234567891011121314151617181920import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;require(&apos;./Slider.less&apos;);export default class Slider extends React.Component&#123; render()&#123; let images=this.props.images; return( &lt;div className=&quot;slider-wrapper&quot;&gt; &lt;ul className=&quot;sliders&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;li className=&quot;slider&quot;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125; 1)require(&#39;./Slider.less&#39;);–&gt;这里引入Slider.less用import和require都是一样的效果，都是加载一个模块的意思,模块可能是图片，可能是less/css/js/json文件,都可以–&gt;在webpack中一切皆模块,不管是什么资源，都可以作为模块来加载 2)li的数量取决于images数据,images中有几张图片，就有几个li 在render中let一个变量images来接收index.js传入的images,然后用map方法遍历整个数组 在Slider.less中写好轮播图的样式 123456789101112131415161718192021222324252627*&#123; padding: 0; margin: 0;&#125;ul,li&#123; list-style: none;&#125;.wrapper&#123; width: 400px; height: 400px; position: relative; margin: 30px auto; .sliders&#123; height: 400px; position: absolute; left:0; .slider&#123; float: left; width: 400px; height: 400px; img&#123; width: 100%; height: 100%; &#125; &#125; &#125;&#125; 宽高为400px的轮播图 4.写配置文件 在webpack.config.js中加loaders 1234567module:&#123; loaders:[ &#123;test:/\.js$/,loader:&apos;babel-loader&apos;,exclude:/node_modules/&#125;, &#123;test:/\.less$/,loader:&apos;style-loader!css-loader!less-loader&apos;&#125;, &#123;test:/\.(jpg|png|gif)$/,loader:&apos;url-loader&apos;&#125; ] &#125; babel默认情况下什么都不做，需要一个配置文件.babelrc文件 新建一个.babelrc配置文件123&#123; &quot;presets&quot;: [&quot;es2015&quot;,&quot;stage-0&quot;,&quot;react&quot;]&#125; presets预设,”es2015”将es6编译成es5,”stage-0”将es7编译成es5,”react”将react编译成es5 原理1:{test:/\.js$/,loader:&#39;babel-loader&#39;,exclude:/node_modules/}–&gt;处理(编译)js文件:如果发现文件是js,用babel-loader加载,加载的时候需要读配置文件.babelrc,如果代码时es6/es7/react都要通过babel转成es5;同时通过exclude将node_modules文件夹下的所有js文件排除掉 原理2:{test:/\.less$/,loader:&#39;style-loader!css-loader!less-loader&#39;}–&gt;如果发现文件以.less结尾的,第一步通过less-loader将less编译成css,然后通过css-loader进行加载,然后通过style-loader将他通过style标签的形式插入到页面中去，变成一个行内样式 原理3:{test:/\.(jpg|png|gif)$/,loader:&#39;url-loader&#39;}–&gt;凡是资源文件都可以用url-loader来加载,不论是图片、图标、字体、视频、音频;后面可以通过问号传参,有个参数limit(例如:{test:/\.(jpg|png|gif)$/,loader:&#39;url-loader?limit=8192&#39;}–&gt;小于8K的资源文件将直接以base64的形式内联在代码中，可以减少一次http请求) 此时执行npm run build,将代码打包到出口文件中,打开build文件夹下的index.html文件就可以直接预览效果了 此时会发现控制台有个报错 123Warning: Each child in an array or iterator should have a unique &quot;key&quot; prop. Check the render method of `Slider`. See https://fb.me/react-warning-keys for more information. in li (created by Slider) in Slider 需要唯一的key属性,在Slider.js文件中的li需要唯一的key属性，给li标签加上key属性即可 1&lt;li className=&quot;slider&quot; key=&#123;index&#125;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; 关掉浏览器,重新执行npm run build，再打开build文件夹下的index.html文件预览,控制台就没有报错了 5.写功能 让图片动起来,需要给Slider.js加个状态,需要有个定时器让他动起来 写在周期函数componentDidMount中 1234567891011constructor()&#123; super(); this.state=&#123;pos:0&#125;;//默认索引 &#125; componentDidMount()&#123; this.$timer=setInterval(()=&gt;&#123; let pos=this.state.pos; pos++;//每隔2s让pos加1，pos值影响ul的左偏移量left的值 所以ul应该有个style属性 left值应该变化 this.setState(&#123;pos:pos&#125;) &#125;,this.props.interval*1000) pos++;–&gt;每隔2s让pos加1，pos值影响ul的左偏移量left的值 所以ul应该有个style属性 left值应该变化 ul应该有个style属性123456789101112131415161718192021render()&#123; let images=this.props.images; let style=&#123; width:400*images.length, left:this.state.pos*-400 &#125;; return( &lt;div className=&quot;slider-wrapper&quot;&gt; &lt;ul style=&#123;style&#125; className=&quot;sliders&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;li className=&quot;slider&quot; key=&#123;index&#125;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; this.props.interval*1000–&gt;每隔2s轮播一次,需要有变量传进来–&gt;在index.js中新增一个interval变量(间隔时间让外面可以控制) 1).这里通过this.props获取index.js中传递进来的的interval变量this.props.interval*1000 2).index.js中新增一个interval变量12345ReactDOM.render( &lt;Slider images=&#123;images&#125; interval=&#123;2&#125; /&gt;,document.querySelector(&apos;#root&apos;)); 写功能步骤总结: 第一步:定义一个默认索引pos,默认值是0 第二步:在组件加载完成之后创建定时器setInterval赋给this.$timer 第三步:每隔2s让图片向左偏移一个宽度的距离(interval是外界传进来的,是图片轮播的间隔时间),在index中要给组件Slider传进来一个2,2*1000意味着2s变一次 this.$timer中先取出老的pos值，第一次轮播pos就是0，然后pos++，pos变成1，然后setState重新设置pos值,让pos值往上 pos会影响ul的left值，一张图片的宽度是400px，向左偏移400，就是*-400 ul的宽度应该是宽度400乘以图片的数量images.length,4张图就是1600px执行npm run dev 注意,执行npm run dev可自动将文件编译更新打包到出口文件index.html中，并且只要更改文件，页面就会自动刷新,但是如果更改配置文件,需要重新启动npm run dev服务 此时执行npm run dev命令,轮播图就动起来了，但是越界了,因为此时还没有做边界处理 7.完善功能 将Slider需要的属性(可外界控制的)，在index.js的Slider组件标签中传入 1234567891011ReactDOM.render( &lt;Slider images=&#123;images&#125;//图片 interval=&#123;2&#125;//多长时间轮播一次 speed=&#123;1&#125;//每次轮播的速度 pause=&#123;true&#125;//当鼠标移动上去之后自动暂停 autoplay=&#123;true&#125;//是否启用自动轮播，false不自动轮播 - 在Slider.js中 dots=&#123;true&#125;//是否有点状导航 arrows=&#123;true&#125;//是否有箭头导航 /&gt;,document.querySelector(&apos;#root&apos;)); 添加transitionDuration–&gt;规定完成过渡效果需要花费的时间 speed默认值是1 这里就是1s 12345let style=&#123; width:400*images.length, left:this.state.pos*-400, transitionDuration:this.props.speed+&apos;s&apos; &#125;; 在Slider.js的周期函数中添加一个判断 123456789componentDidMount()&#123; if(this.props.autoPlay)&#123; this.$timer=setInterval(()=&gt;&#123; let pos=this.state.pos; pos++; this.setState(&#123;pos:pos&#125;) &#125;,this.props.interval*1000) &#125;&#125; this.props.autoPlay 是否自动轮播 如果外界传入true就是自动轮播，传入false就是不自动轮播 8.将轮播切换单独拎出来写成一个方法turn12345turn(n)&#123; let pos=this.state.pos; pos+=n; this.setState(&#123;pos:pos&#125;)&#125; 或者使用es6的箭头函数 12345turn=(n)=&gt;&#123; let pos=this.state.pos; pos+=n; this.setState(&#123;pos:pos&#125;) &#125; let pos=this.state.pos;获取旧索引 turn表示切换,n表示切换的步长,方便以后操作:例如往左走传1进来即可，往右走传-1进来即可 那么此时在周期函数中,直接调用这个turn方法即可,默认往右轮播，传入-11234567componentDidMount()&#123; if(this.props.autoplay)&#123; this.timer=setInterval(()=&gt;&#123; this.turn(1); &#125;,this.props.interval*1000) &#125;&#125; 9.实现鼠标移上去停止轮播 给div加onMouseOver和onMouseOut事件123&lt;ul onMouseOver=&#123;()=&gt;clearInterval(this.timer)&#125; onMouseOut=&#123;this.play&#125; style=&#123;style&#125; className=&quot;sliders&quot;&gt;...&lt;/ul&gt; 10.自动轮播部分也封装成一个函数play12345play=()=&gt;&#123; this.timer=setInterval(()=&gt;&#123; this.turn(1); &#125;,this.props.interval*1000) &#125;; play表示开启定时器进行自动轮播 那么此时在周期函数中直接调用this.play()即可12345componentDidMount()&#123; if(this.props.autoplay)&#123; this.play(); &#125;&#125; 11.边界判断12345678turn=(n)=&gt;&#123; let pos=this.state.pos; pos+=n; if(pos&gt;=this.props.images.length)&#123; pos=0; &#125; this.setState(&#123;pos:pos&#125;) &#125;; 当索引为图片总张数的时候 让索引变为012.写左右箭头 在ul下加一个div 1234&lt;div className=&quot;arrows&quot;&gt; &lt;span className=&quot;arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span className=&quot;arrow-right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt; 在Slider.less中写样式 123456789101112131415161718192021222324252627.arrows&#123; position: absolute; width: 100%; height: 20px; top:50%; margin-top:-10px; .arrow&#123; width: 20px; height: 20px; line-height: 20px; text-align: center; cursor: pointer; font-size: 30px; background-color: #eee; &amp;:hover&#123; background-color: #999; &#125; &#125; .arrow-left&#123; margin-left: 5px; float: left; &#125; .arrow-right&#123; margin-right: 5px; float: right; &#125;&#125; 给左右arrow绑定事件 1234&lt;div className=&quot;arrows&quot;&gt; &lt;span onClick=&#123;()=&gt;this.turn(-1)&#125; className=&quot;arrow arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span onClick=&#123;()=&gt;this.turn(1)&#125; className=&quot;arrow arrow-right&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt; 13.处理左边界 在turn中做个判断 1234567891011turn=(n)=&gt;&#123; let pos=this.state.pos; pos+=n; if(pos&gt;=this.props.images.length)&#123; pos=0; &#125; if(pos&lt;0)&#123; pos=this.props.images.length-1; &#125; this.setState(&#123;pos:pos&#125;)&#125;; 当索引小于0的时候,让索引等于images的长度-1 14.根据传进来的arrows值判断是否有左右箭头切换效果 第一种方法(看着比较乱) 123456&#123; this.props.arrows?&lt;div className=&quot;arrows&quot;&gt; &lt;span onClick=&#123;()=&gt;this.turn(-1)&#125; className=&quot;arrow arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span onClick=&#123;()=&gt;this.turn(1)&#125; className=&quot;arrow arrow-right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt;:null &#125; 第二种,在render中 123456789let arrows=null; if(this.props.arrows)&#123; arrows=( &lt;div className=&quot;arrows&quot;&gt; &lt;span onClick=&#123;()=&gt;this.turn(-1)&#125; className=&quot;arrow arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span onClick=&#123;()=&gt;this.turn(1)&#125; className=&quot;arrow arrow-right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt; ) &#125; 那么ul下面就可以直接用{arrows}代替了(看着很清晰明了) 123456789101112&lt;div className=&quot;slider-wrapper&quot;&gt; &lt;ul onMouseOver=&#123;()=&gt;clearInterval(this.timer)&#125; onMouseOut=&#123;this.play&#125; style=&#123;style&#125; className=&quot;sliders&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;li className=&quot;slider&quot; key=&#123;index&#125;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &#123;arrows&#125;&lt;/div&gt; 15.根据传进来的dots值判断是否有点状导航123456789101112let dots=null; if(this.props.dots)&#123; dots=( &lt;div className=&quot;dots&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;span className=&quot;dot&quot; key=&#123;index&#125;&gt;&lt;/span&gt; )) &#125; &lt;/div&gt; ) &#125; dots直接放到最下面即可123...&#123;arrows&#125;&#123;dots&#125; 15-1.在Slider.less中写dots的样式12345678910111213141516171819.dots&#123; width: 100%; height: 20px; position: absolute; bottom: 10px; text-align: center; .dot&#123; display: inline-block; width: 20px; height: 20px; border-radius: 50%; margin-left: 5px; background-color: #abcdef; cursor: pointer; &amp;:hover&#123; background-color: #999999; &#125; &#125;&#125; 16.点状导航的点击跟随事件 给span加onClick事件123···&lt;span className=&quot;dot&quot; key=&#123;index&#125; onClick=&#123;()=&gt;this.turn(index-this.props.pos)&#125;&gt;&lt;/span&gt;··· 16-1.轮播点状导航自动跟随事件 在Slider.less中加一个active样式 123.active&#123; background-color: #999999; &#125; 给span标签添加active属性 1&lt;span className=&#123;&quot;dot &quot;+(index==this.state.pos?&apos;active&apos;:&apos;&apos;)&#125; key=&#123;index&#125; onClick=&#123;()=&gt;this.turn(index-this.state.pos)&#125;&gt;&lt;/span&gt;]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react轮播图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.react轮播图项目配置及原理概要]]></title>
    <url>%2F2017%2F07%2F31%2F1-react%E8%BD%AE%E6%92%AD%E5%9B%BE%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%8E%9F%E7%90%86%E6%A6%82%E8%A6%81%2F</url>
    <content type="text"><![CDATA[项目配置及原理概要1.初始化项目1npm init -y 生成package.json文件 2.安装依赖包 开发依赖1npm install webpack webpack-dev-server babel-core babel-loader babel-preset-react babel-preset-es2015 babel-preset-stage-0 style-loader css-loader less-loader less file-loader url-loader html-webpack-plugin -D webpack 打包 webpack-dev-server 用来启动一个HTTP服务器预览我们的项目 babel-core babel-loader 进行转译 把es6和react代码转译成es5 babel-preset-react 用来转译react babel-preset-es2015 用来转译es6 babel-preset-stage-0 用来转译es7 style-loader css-loader 用来处理css less-loader less 编译less file-loader url-loader 用来处理资源文件 html-webpack-plugin 用来自动产出html文件 open-browser-webpack-plugin 自动打开浏览器 3.安装生产依赖1npm install react react-dom -S 4.配置文件的出入口路径 新建一个webpack.config.js文件，在文件中配置入口文件和出口路径12345678let path=require(&apos;path&apos;);module.exports=&#123; entry:&apos;./src/index.js&apos;,//入口文件 output:&#123;//出口配置 path:path.resolve(&apos;build&apos;),//出口文件路径 filename:&apos;bundle.js&apos;//出口文件名称 &#125;&#125;; 5.启动安装的模块文件夹node_modules–&gt;.bin–&gt;webpack.cmd和webpack-dev-server.cmd文件 在package.json文件中的scripts标签进行匹配1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;:&quot;webpack-dev-server&quot; &#125;, 5-1.启动webpack和webpack-dev 在cmd中执行命令 1npm run build 1)在cmd窗口中显示 123 Asset Size Chunks Chunk Namesbundle.js 2.52 kB 0 [emitted] main [0] ./src/index.js 43 bytes &#123;0&#125; [built] 表示生成bundle.js一个文件 2)在当前项目文件夹下会自动生成一个build文件夹，同时在build文件夹下会自动生成bundle.js文件，我们的入口文件(src文件夹下的index.js)会自动打包到出口文件bundle.js中 6.自动产出html文件6-1.现在我们需要在build文件夹中新建一个index.html文件，然后引入bundle.js进行预览;但是现在我们希望这个文件不要手动创建了，希望他可以自动生成，要做到这一点，我们需要引入插件html-webpack-plugin(此插件在最初已经安装过,如果没有安装需安装后才可使用) 1) 在webpack.config.js中引入html-webpack-plugin 1let HtmlWebPackPlugin=require(&apos;html-webpack-plugin&apos;); 2) 同时给插件再添加个配置项plugins,plugins是个数组 12345plugins:[ new HtmlWebPackPlugin(&#123; template:&apos;./src/index.html&apos; &#125;)] 3) template 模板 配置到时候会按照哪个模板来自动产出html文件 并且把它自动放到配置目录下–&gt;一般会在src文件夹下新建一个模板叫index.html 4) 执行npm run build 4-1).原理:此时如果再执行npm run build的话，就会执行上面配置的plugins插件,插件会读取src文件夹下的index.html模板文件，把他自动插入到打包后的bundle.js，并且把bundle.js保存到build目录下(每次执行npm run build命令，都会重新生成bundle.js和index.html两个文件) 4-2).在cmd命令行执行npm run build,命令行显示: 1234 Asset Size Chunks Chunk Names bundle.js 2.52 kB 0 [emitted] mainindex.html 188 bytes [emitted] [0] ./src/index.js 43 bytes &#123;0&#125; [built] 表示生成bundle.js和index.html两个文件,与之前执行npm run build相比多了一个html文件 4-3).打开我们的项目文件夹下的build文件会发现，已经自动生成了一个出口index.html出口文件,打开这个index.html出口文件会发现,index.html中已经自动引入了bundle.js文件 关于react轮播图的源码,无缝版已上传至github,https://github.com/gaodaxiu0406/React-Slider]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>轮播图</tag>
        <tag>react轮播图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端click300-380ms延迟问题]]></title>
    <url>%2F2017%2F07%2F28%2F%E7%A7%BB%E5%8A%A8%E7%AB%AFclick300-380ms%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。 历史原因 来源一个公司内一个同事的分享:2007年苹果发布首款iphone上iOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。 双击缩放是指用手指在屏幕上快速点击两次，ios 自带的 Safari 浏览器会将网页缩放至原始比例。 原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。 解决方案1.tap.js解决方案 使用 zepto.js 的 tap 事件，通过 singleTap 和 doubleTap 来区分单击和双击。但是会出现点击穿透，而且对于已经使用 click 的文件，改动成本太大。123456789101112131415161718192021222324252627&lt;script src=&quot;tap.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;container&quot;&gt; &lt;button id=&quot;button-1&quot;&gt;Click event&lt;/button&gt; &lt;button id=&quot;button-2&quot;&gt;Tap event&lt;/button&gt;&lt;/div&gt;&lt;div id=&quot;output&quot;&gt;&lt;/div&gt;&lt;script&gt; var container = document.getElementById(&apos;container&apos;) var button1 = document.getElementById(&apos;button-1&apos;); var button2 = document.getElementById(&apos;button-2&apos;); var output = document.getElementById(&apos;output&apos;); var tap = new Tap(container); button1.addEventListener(&apos;click&apos;, callback, false); button2.addEventListener(&apos;tap&apos;, callback, false); function callback (e) &#123; e.preventDefault(); var p = document.createElement(&apos;p&apos;); p.textContent = &apos;event: &apos; + e.type; output.insertBefore(p, output.firstChild); &#125;&lt;/script&gt; 2.对于高版本chrome和firefox，可以通过禁用伸缩，即在 head 上的 meta 标签添加 user-scalable = no。如下：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot;&gt; 3.chrome32+ 可以将 viewport 的宽度设置成 device-width.4.IE10+，可以使用 pointerEvents。可以让特定的元素或者整个文档中的元素移除点击延迟的问题，同时不会影响 pinch-zooming12345a, button, .myelements&#123;-ms-touch-action: manipulation; /* IE10 */touch-action: manipulation; /* IE11+ */&#125; 5.通过 touchend 事件代替 click 事件。6.fastclick.js解决方法 终极大 boss。 fastclick。上面的几种方法都是针对某些浏览器，或者某些浏览器的某些版本，或者会影响到我们平常使用方式的解决方案。使用起来不方便且考虑的细节很多，实践难度比较大。fastclick 作为一个终极的解决方案，使用方便，文件大小压缩后只有 3.3k。对于交互相对复杂的移动端web页面或应用是一个相对不错的解决方案。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; &#125; body &#123; &#125; .button &#123; background-color: #3d3d3d; border: 0px; height: 80px; width: 80%; font-size: 50px; margin: 10% 0% 0% 10%; color: #fff; &#125; .fu &#123; min-height: 100%; min-width: 100%; background-color: Black; background: rgba(0,0,0,0.4); position: absolute; top: 0; text-align: center; display: none; &#125; .ts &#123; margin: 8% auto; width: 400px; height: 400px; top: 59%; background-color: #fff; text-align: center; &#125; &lt;/style&gt; &lt;script src=&quot;fastclick.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;jquery-1.7.2.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; //javascript: &lt;script type=&quot;application/javascript&quot;&gt; window.addEventListener(&apos;load&apos;, function () &#123; FastClick.attach(document.body); &#125;, false); function xian() &#123; $(&quot;.fu&quot;).show().hide(350); &#125; &lt;/script&gt; //jQuery: &lt;script&gt; window.addEventListener(&apos;load&apos;, function () &#123;$(function() &#123; FastClick.attach(document.body); &#125;); &lt;/script&gt; //CommonJS:attachFastClick = require(&apos;fastclick&apos;); attachFastClick(document.body); AMD: var FastClick = require(&apos;fastclick&apos;); FastClick.attach(document.body, options);&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;div class=&quot;but&quot;&gt; &lt;input class=&quot;button&quot; type=&quot;button&quot; value=&quot;点击我&quot; onclick=&quot;xian()&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;fu&quot; &gt; &lt;div class=&quot;ts&quot;&gt; 我是浮层 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>移动端</tag>
        <tag>移动端click延迟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器种类和兼容性总结大全]]></title>
    <url>%2F2017%2F07%2F21%2Fcss%E9%80%89%E6%8B%A9%E5%99%A8%E7%A7%8D%E7%B1%BB%E5%92%8C%E5%85%BC%E5%AE%B9%E6%80%A7%E6%80%BB%E7%BB%93%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[css5选择器 名称 举例 描述 详细 权重 ie6-7 ie8 ie9+ 其他 标签选择器 p{} 直接使用元素标签进行选择 1 yes yes yes 类选择器 .sum{} 类选择器最前方一定要有点 通过元素的类名，来选择元素，一个元素可以有多个类名，都代表这个元素,类名是元素class属性中的属性值，例如&lt;p class=&#39;sum&#39;&gt;&lt;/p&gt; 10 yes yes yes id选择器 #tytle{color:red;} id在html中具有唯一性,这个属性值前面加一个“#” 一个html元素，id属性值只能用一次 100 yes yes yes 通配符选择器 *{key:value} 匹配全部html元素 一般不使用，因为全部匹配耗性能 0&lt;通配符选择器&lt;1 yes yes yes yes (标签)属性选择器 [type]或[type=text] [标签属性名]{}或[标签属性名=属性值]{} 利用标签的属性名和属性值来选择html元素 10 yes yes yes 属性选择器在使用的时候，如果一个元素有两个类名，那么是不生效的 分组选择器 .box,li,.p1{color: red}; 选择器1，选择器2，选择器3{} 同一份css样式，可以一次性的添加给多个不同的html元素 分组选择器将不同的html分为一组，权重计算的时候都是独立计算，不会叠加。 yes yes yes 交集选择器 h2[title]{} 两种选择器同属于一个元素的时候，我们可以使用交集选择器来进行元素的准确选择 所有组合选择器权重之和 yes yes yes 作用：精确查找元素，增加选择器的权重 子级选择器 ul&gt;li{color:red;} 父级选择器&gt;子级选择器{} 存在包含关系的元素选择，通过父级确定选择子级 所有选择器之和 yes yes yes 子级选择器必须是紧邻的父子关系 后代选择器(派生选择器) .div1 ul span{} 祖辈选择器 要查找的后代选择器{},中间用空格连接 后代选择器在写的时候尽量控制在３个左右 yes yes yes 在一个根元素的范围内，查找到它的后代元素，选择器过多浪费性能，不建议使用 相邻兄弟选择器 .list1+li{color: red;} 哥哥选择器+弟弟选择器{} 通过各个元素选择弟弟选择器，两个选择器之间用“+”连接 选择器之和 yes yes yes 伪类选择器 a:hover{color: red}鼠标经过的状态,或a:link{color: blue}默认状态,或a：active{color: green}鼠标点击的状态,或a:visited{color: blanchedalmond}鼠标点击后的状态 10 yes yes yes .input:focus{border-color: blue};input:focus 鼠标聚焦后的状态，input独有的属性 伪元素 div:before{}；或div:after{} 通过css代码向指定元素内添加假的（html中不存在的）元素 before 会出现在div所有内容之前，after 会出现在div所有内容之后 no yes yes 使用伪元素的时候要保证两个前提：1.要有display这个属性2.要有content这个属性，这个属性的属性值可以为空，但是引号不能少content:&quot;&quot; visited security issue yes yes security issue css3选择器 名称 举例 描述 详细 权重 ie6-7 ie8 ie9+ 其他 属性选择器 E[attr~=value]{} 指定属性名,并且具有属性值,此属性值是一个此列表(类名),并且以空格隔开,其中词列表中包含了一个value词,并且等号前的~不能省略. E[attr^=value]{} ^ 表示以谁为开头的,value可以是首字母或者类名 必须是第一个类名 E[attr$=value]{} $ 表示以谁为结尾,value可以是末尾字母或者类名 必须是最后一个类名 E[attr\=value]{}(由于编辑呈现问题，此处用斜杠代替竖杠,正确写法是E[attr竖杠=value]{}) 如果只有一个类名,没有”-“,也可以选中 value必须后面带”-“，value必须是第一个类名 伪类选择器1. .dome p:nth-child(3){background: red;}选择dome下的第三个p标签为背景色红色 no no yes 2. .dome p:first-child{background: yellow;}选择dome下的第一个p标签为背景色黄色 no almost yes 3. .dome p:last-child{background: black;}选择dome下的最后一个p标签为背景色黑色 伪类选择器是针对列表或者很多同级的标签使用,img下是没有效果的也用不到伪类选择器 no no yes 4. .dome p:nth-child(nlength){}；选择dome下所有的p标签 no no yes 5. .dome p:nth-child(2n){}；选择dome下的所有偶数个的p标签 no no yes 6. .dome p:nth-child(3n)选择dome下的所有3的倍数的p标签 no no yes 7. .dome p:nth-child(n+length) 从第length个开始改变,包括第length个(n是从0开始取值的) 选择大于length后面的元素 no no yes 8. .dome p:nth-child(-n+length) 包括length，length是从0开始的 选择小于length前面的元素及length元素 no no yes 9. p:nth-last-child(3) 选择倒数第三个元素 no no yes 10. p:nth-child(n) 从大盒子的第一个元素开始 nth-child选择同级元素 no no yes 11. p:nth-of-type(n) 从大盒子的第一个p元素开始 nth-of-type 选择指定的元素 no no yes 12. p:nth-last-of-type(n) 倒数第n个 在同级元素中 no no yes 13. p:first-of-type{} 同类型的第一个 选择一个上级元素下的同类子元素 no no yes 14. p:last-of-type{} 同类型的最后一个 no no yes 15. p:only-child{} 在父元素中,里面的子元素是唯一的 no no yes 16. p:only-of-type{} 在父元素中,里面有很多的子元素,但是有一个子元素是唯一的 no no yes 空标签 p:empty{display:none;} empty 隐藏空标签 no no yes 否定选择器 not input:not([type=submit]){} no yes yes 根元素 root :root{} 选择文档的根元素 no no yes 目标元素 :target{} 选择器可用于选取当前活动的目标元素 no no no CSS选择器优先级 当两个规则都作用到了同一个html元素上时，如果定义的属性有冲突，那么应该用谁的值的，CSS有一套优先级的定义 不同级别 1.在属性后面使用important会覆盖页面内任何位置定义的元素样式 2.作为style属性写在元素内的样式 3.id选择器 4.类选择器 5.标签选择器 6.通配符选择器 7.浏览器自定义或继承 总结CSS选择器优先级排序: !important&gt;行内样式&gt;ID选择器&gt;类选择器&gt;标签&gt;通配符&gt;继承&gt;浏览器默认属性 CSS样式应用，有个简单的计算方式(权值实际并不是按照十进制，用数字表示只是说明思想，一万个class可能也不如一个id权值高) 内联样式表的权值为 1000 ID选择器的权值为 100 Class类选择器的权值为 10 HTML标签选择器的权值为 1]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>兼容问题</tag>
        <tag>css选择器种类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP分类]]></title>
    <url>%2F2017%2F07%2F05%2FIP%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。 IP地址根据网络ID的不同分为5种类型，A类地址、B类地址、C类地址、D类地址和E类地址A类ip地址 A:0-127 A类ip地址的第一组数字为1～126。 其中0代表任何地址，127为回环测试地址 注意，数字0和 127不作为A类地址，数字127保留给内部回送函数，而数字0则表示该地址是本地宿主机，不能传送。 A类地址的表示范围为：0.0.0.0~126.255.255.255,默认网络掩码为：255.0.0.0；A类地址分配给规模特别大的网络使用。A类网络用第一组数字表示网络本身的地址，后面三组数字作为连接于网络上的主机的地址。分配给具有大量主机（直接个人用户）而局域网络个数较少的大型网络。例如IBM公司的网络。 一个A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”， 地址范围从1.0.0.0 到126.0.0.0。可用的A类网络有126个，每个网络能容纳1亿多个主机。 B类ip地址 B类地址的第一组数字为128～191。 其中128.0.0.0和191.255.0.0为保留ip。 B类地址的表示范围为:128.0.0.0~191.255.255.255，默认网络掩码为:255.255.0.0;实际范围是128.1.0.0–191.254.0.0;B类地址分配给一般的中型网络。B类网络用第一、二组数字表示网络的地址，后面两组数字代表网络上的主机地址。 一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255。可用的B类网络有16382个，每个网络能容纳6万多个主机 。 C类ip地址 C类地址的第一组数字为192～223。 其中192.0.0.0和223.255.255.0为保留ip C类地址的表示范围为:192.0.0.0~223.255.255.255,默认网络掩码为：255.255.255.0;实际范围是192.0.1.0–223.255.254.0;C类地址分配给小型网络，如一般的局域网和校园网，它可连接的主机数量是最少的，采用把所属的用户分为若干的网段进行管理。C类网络用前三组数字表示网络的地址，最后一组数字作为网络上的主机地址。 一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围从192.0.0.0到223.255.255.255。C类网络可达209万余个，每个网络能容纳254个主机。 D类ip地址 224.0.0.0到239.255.255.255用于多点广播 D类IP地址第一个字节以“lll0”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。 D类地址称为广播地址，供特殊协议向选定的节点发送信息时用 E类ip地址 240.0.0.0到255.255.255.254 255.255.255.255用于广播地址 以“llll0”开始，为将来使用保留。 E类地址保留给将来使用。 全零（“0．0．0．0”）地址对应于当前主机。全“1”的IP地址（“255．255．255．255”）是当前子网的广播地址。保留地址的分配一个机构网络要连入Internet，必须申请公用IP地址。但是考虑到网络安全和内部实验等特殊情况，在IP地址中专门保留了三个区域作为私有地址，其地址范围如下：10.0.0.0/8:10.0.0.0-10.255.255.255172.16.0.0/12:172.16.0.0-172.31.255.255192.168.0.0/16:192.168.0.0-192.168.255.255使用保留地址的网络只能在内部进行通信，而不能与其他网络互连。因为本网络中的保留地址同样也可能被其它网络使用，如果进行网络互连，那么寻找路由时就会因为地址的不唯一而出现问题。但是这些使用保留地址的网络可以通过将本网络内的保留地址翻译转换成公共地址的方式实现与外部网络的互连。这也是保证网络安全的重要方法之一。 特殊IP地址(保留IP地址)介绍就像我们每个人都有一个身份证号码一样，网络里的每台电脑(更确切地说，是每一个设备的网络接口)都有一个IP地址用于标示自己。我们可能都知道这些地址由四个字节组成，用点分十进制表示以及它们的A，B，C分类等，然而，在总数大约为四十多亿个可用IP 地址里，你知道下面一些常见的有特殊意义地址吗？我们一起来看看吧： 一、0.0.0.0严格说来，0.0.0.0已经不是一个真正意义上的IP地址了。它表示的是这样一个集合：所有不清楚的主机和目的网络。这里的“不清楚”是指在本机的路由表里没有特定条目指明如何到达。对本机来说，它就是一个“收容所”，所有不认识的“三无”人员，一 律送进去。如果你在网络设置中设置了缺省网关，那么Windows系统会自动产生一个目的地址为0.0.0.0的缺省路由。 二、255.255.255.255限制广播地址。对本机来说，这个地址指本网段内(同一广播域)的所有主机。如果翻译成人类的语言，应该是这样：“这个房间里的所有人都注意了！”这个地址不能被路由器转发。 三、127.0.0.1本机地址，主要用于测试。用汉语表示，就是“我自己”。在Windows系统中，这个地址有一个别名“Localhost”。寻址这样一个地址，是不能把它发到网络接口的。除非出错，否则在传输介质上永远不应该出现目的地址为“127.0.0.1”的 数据包。 四、224.0.0.1组播地址，注意它和广播的区别。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机，224.0.0.2特指所有路由器。这样的地址多用于一些特定的程序以及多媒体程序。如果你的主机开启了IRDP (Internet路由发现协议，使用组播功能)功能，那么你的主机路由表中应该有这样一条路由。 五、169.254.x.x如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超出了一个系统规定的时间，Wingdows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九 是你的网络不能正常运行了。 六、10.x.x.x、172.16。x。x～172.31。x。x、192.168。x。x私有地址，这些地址被大量用于企业内部网络中。一些宽带路由器，也往往使用192.168.1.1作为缺省地址。私有网络由于不与外部互连，因而可能使用随意的IP地址。保留这样的地址供其使用是为了避免以后接入公网时引起地址混乱。使用私有地址的私 有网络在接入Internet时，要使用地址翻译(NAT)，将私有地址翻译成公用合法地址。在Internet上，这类地址是不能出现的。对一台网络上的主机来说，它可以正常接收的合法目的网络地址有三种：本机的IP地址、广播地址以及组播地址。]]></content>
      <categories>
        <category>前端常识</category>
      </categories>
      <tags>
        <tag>前端常识</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuejs基础]]></title>
    <url>%2F2017%2F06%2F30%2FVuejs%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Vue.js是什么 Vue.js（读音 /vjuː/，类似于 view） 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。 vue优点 数据驱动(主要操作的是数据,几乎不直接操作dom) 如何安装vue 通过bower安装bower: npm install bower -gmac本: sudo npm install bower -g查看vue的版本 ： bower info vue安装vue：bower install vue@1.0.28 通过npm安装通过npm: npm install vue通过npm全局安装: npm install vue -g]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相对路径与绝对路径]]></title>
    <url>%2F2017%2F06%2F30%2F%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[路径url 绝对路径 指带域名的文件的完整路径或磁盘中指定文件的全部路径。 例如：C:\windows\system32\cmd.exe 例如：http://www.zhufengpeixun.com/ 可以理解为地址：珠峰培训的地址是北京昌平区回龙观东大街3号楼02号东段珠峰培训 相对路径 是指在同一个文件夹下通过一个参考点找到其他文件 返回上一级用“../” 平级之间直接写文件名 下一级用“/”1&lt;link rel=&quot;stylesheet&quot; href=&quot;../面试题.md&quot;&gt;]]></content>
      <categories>
        <category>前端常识</category>
      </categories>
      <tags>
        <tag>前端常识</tag>
        <tag>相对路径</tag>
        <tag>绝对路径</tag>
        <tag>url</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F06%2F30%2FCSS%E5%B1%9E%E6%80%A7%E7%9A%84%E7%BB%A7%E6%89%BF%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[title: CSS属性的继承及相关面试题date: 2017-06-30 16:56:14tags: - css属性的继承 - css相关面试题 - css属性的继承相关面试题 - css categories: cssCSS属性的继承 子级元素从父级元素身上继承的一些可继承的css属性 1234&lt;style&gt;div&#123;color:red;&#125;&lt;/style&gt;&lt;p&gt;woshiyige[biaoqian&lt;/p&gt; 根据 CSS，子元素从父元素继承属性。看看下面这条规则： body {font-family: Verdana, sans-serif;} 根据上面这条规则，站点的 body 元素将使用 Verdana 字体（假如访问者的系统中存在该字体的话）。 继承的权重较小，可被其他选择器的样式覆盖 面试题： 哪些css样式可以被继承：和文字有关的css样式 和列表有关的css样式总结： 1.可继承属性 1)可以继承的文本相关属性： 1&lt;azimuth&gt;&lt;border-collapse&gt;&lt;border-spacing&gt;&lt;caption-side&gt;&lt;color&gt;&lt;cursor&gt;&lt;direction&gt;&lt;elevation&gt;&lt;empty-cells&gt;&lt;font-family&gt;&lt;font-size&gt;&lt;font-style&gt;&lt;font-variant&gt;&lt;font-weight&gt;&lt;font&gt;&lt;letter-spacing&gt;&lt;line-height&gt;&lt;list-style-image&gt;&lt;list-style-position&gt;&lt;list-style-type&gt;&lt;list-style&gt;&lt;orphans&gt;&lt;pitch-range&gt;&lt;pitch&gt;&lt;quotes&gt;&lt;richness&gt;&lt;speak-header&gt;&lt;speaknumeral&gt;&lt;speak-punctuation&gt;&lt;speak&gt;&lt;speechrate&gt;&lt;stress&gt;&lt;text-align&gt;&lt;text-indent&gt;&lt;texttransform&gt;&lt;visibility&gt;&lt;voice-family&gt;&lt;volume&gt;&lt;whitespace&gt;&lt;widows&gt;&lt;word-spacing&gt; 2)可以继承的列表相关属性： 1&lt;azimuth&gt;&lt;border-collapse&gt;&lt;border-spacing&gt;&lt;caption-side&gt;&lt;color&gt;&lt;cursor&gt;&lt;direction&gt;&lt;elevation&gt;&lt;empty-cells&gt;&lt;font-family&gt;&lt;font-size&gt;&lt;font-style&gt;&lt;font-variant&gt;&lt;font-weight&gt;&lt;font&gt;&lt;letter-spacing&gt;&lt;line-height&gt;&lt;list-style-image&gt;&lt;list-style-position&gt;&lt;list-style-type&gt;&lt;list-style&gt;&lt;orphans&gt;&lt;pitch-range&gt;&lt;pitch&gt;&lt;quotes&gt;&lt;richness&gt;&lt;speak-header&gt;&lt;speaknumeral&gt;&lt;speak-punctuation&gt;&lt;speak&gt;&lt;speechrate&gt;&lt;stress&gt;&lt;text-align&gt;&lt;text-indent&gt;&lt;texttransform&gt;&lt;visibility&gt;&lt;voice-family&gt;&lt;volume&gt;&lt;whitespace&gt;&lt;widows&gt;&lt;word-spacing&gt; 2.不可继承属性 1&lt;display&gt;&lt;margin&gt;&lt;border&gt;&lt;padding&gt;&lt;background&gt;&lt;height&gt;&lt;min-height&gt;&lt;max-height&gt;&lt;width&gt;&lt;min-width&gt;&lt;max-width&gt;&lt;overflow&gt;&lt;position&gt;&lt;left&gt;&lt;right&gt;&lt;top&gt;&lt;bottom&gt;&lt;z-index&gt;&lt;float&gt;&lt;clear&gt;&lt;table-layout&gt;&lt;vertical-align&gt;&lt;page-break-after&gt;&lt;page-bread-before&gt;和&lt;unicode-bidi&gt; 3.所有元素可继承： &lt;visibility&gt;（可见性）和&lt;cursor&gt;(光标) 4.终端块状元素可继承： &lt;text-indent&gt;和&lt;text-align&gt; 5.如果css属性不带有继承性，如何继承父级身上的属性，可以将要继承的属性的属性值写上inherit12ul&#123;float:left;&#125;li&#123;float:inherit;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS中的form表单与table表格]]></title>
    <url>%2F2017%2F06%2F30%2FCSS%E4%B8%AD%E7%9A%84form%E8%A1%A8%E5%8D%95%E4%B8%8Etable%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[form表单 用来获取用户信息&lt;form&gt;&lt;/form&gt; 12345678910111213141516171819202122&lt;form&gt; &lt;input type=&quot;radio&quot; name=&quot;ok&quot; checked=&quot;checked&quot;&gt;&lt;!--单选按钮--&gt;&lt;label&gt;满意&lt;/label&gt;&lt;!--label 描述表单元素功能--&gt; &lt;!--type 类型--&gt; &lt;!--name 名字--&gt; &lt;!--checked 选中--&gt; &lt;input type=&quot;radio&quot; name=&quot;ok&quot;&gt;&lt;!--单选按钮--&gt;&lt;label&gt;不满意&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;篮球&lt;/label&gt; &lt;input type=&quot;checkbox&quot; checked&gt;&lt;label&gt;美女&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;彭于晏&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;陈冠希&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;杨颖&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;维密&lt;/label&gt; &lt;textarea maxlength=&quot;10&quot; minlength=&quot;1&quot;&gt;&lt;/textarea&gt;&lt;!--文本域--&gt; &lt;!--maxlength 字符输入的最大长度--&gt; &lt;br&gt; &lt;label&gt;姓名&lt;/label&gt;&lt;input type=&quot;text&quot;&gt; &lt;br&gt; &lt;label&gt;手机&lt;/label&gt;&lt;input type=&quot;text&quot;&gt; &lt;br&gt; &lt;label&gt;密码&lt;/label&gt;&lt;input type=&quot;password&quot;&gt;&lt;/form&gt; radio 单选按钮 name=”ok”（name的值相同情况下）同时给到input type=”radio”，表示单选只能选中其中的一个 lable描述表单元素功能 type 类型 name 名字 cheked 选中 单独写checked也可以达到选中的效果 &lt;input type=&quot;checkbox&quot;&gt;checkbox 多选按钮 textarea 文本域 &lt;textarea maxlength=&quot;10&quot; minlength=&quot;1&quot;&gt;&lt;/textarea&gt; maxlength字符输入的最大长度 table表格 &lt;caption&gt;标题&lt;/caption&gt; &lt;thead&gt;表头&lt;/thead&gt; tr&gt;th（标题单元格，th加粗居中） &lt;tfoot&gt; 表尾 tr&gt;th（普通单元格） tr&gt;td（普通单元格，td不加粗不居中） tbody 表身 tr&gt;th（普通单元格） thead和tfoot分别有一个 tbody可以有多个tfoot一般放置在thead的后面，为了防止tbody中的内容过多，tfoot加载过慢的情况，但是虽然书写位置在前面，在页面中显示的时候，这部分依然在整个表格的最后面如果table用来搭建结构，我们只需写tr和td 123456789101112&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>form</tag>
        <tag>table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标签语义化]]></title>
    <url>%2F2017%2F06%2F30%2FCSS%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[标签语义化的重要性/为什么要遵循标签语义化：合理的标签做合理的事情 1、重要的内容，要放在语义重要的标签中，利于SEO优化(搜索引擎榨取),利于SEO优化(也就是搜索引擎的抓取，搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重); 浏览器会按照每个标签的意义去解析这个标签中的内容:h1–&gt;这是一个大标题，意义很重要，搜索引擎会重点抓取这个里面的内容 p–&gt;段落 浏览器在展现这一部分的时候，会独立成一块，让网页结构更加清晰，给用户更好的浏览体验 2、在没有css样式的时候，页面也可以整齐的显示效果 3、更好的支持各种终端，例如无障碍阅读和有声小说等； 4、利于团队协作和后期维护 日常工作中怎样遵循标签语义化： 1、尽量减少使用无意义标签，例如span和div； 2、尽量不使用标签本身的css属性，例如b、font、s等标签，如果需要这些样式，那么使用css样式来进行添加； 3、在需要强调的部分，使用strong、em，但是样式尽量使用css样式来描述； 4、表格搭建时，使用`表格头部 表格身体 表格尾部； 5、列表搭建时，使用无序列表 有序列表 定义列表；` 国家评比一个网站的关键点：访问量（流量/点击量）]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>标签语义化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML标签分类]]></title>
    <url>%2F2017%2F06%2F30%2FHTML%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[html标签分类 html标签又叫做html元素，它分为块级元素和内联元素（也可以叫做行内元素），都是html规范中的概念。 块级元素 块级元素是指本身属性为display:block;的元素。因为它自身的特点，我们通常使用块级元素来进行大布局（大结构）的搭建 块级元素的特点： 独占一行，每一个块级元素都会从新的一行重新开始，从上到下排布 可以直接控制宽度、高度以及盒子模型的相关css属性 在不设置宽度的情况下，块级元素的宽度是它父级元素内容的宽度 在不设置高度的情况下，块级元素的高度是它本身内容的高度 常用的块级元素: div 常用块级容器，也是css layout的主要标签 h1 大标题 h2 副标题 h3 三级标题 h4 四级标题 h5 五级标题 h6 六级标题12345678910标题：&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;h$&#123;$级标题&#125;*6+tab生成：&lt;h1&gt;1级标题&lt;/h1&gt;&lt;h2&gt;2级标题&lt;/h2&gt;&lt;h3&gt;3级标题&lt;/h3&gt;&lt;h4&gt;4级标题&lt;/h4&gt;&lt;h5&gt;5级标题&lt;/h5&gt;&lt;h6&gt;6级标题&lt;/h6&gt; hr 水平分隔线 menu 菜单列表 ol 有序列表 li列表项 123456789有序列表&lt;ol&gt; &lt;li&gt;盗天仙图&lt;/li&gt; &lt;li&gt;名侦探&lt;/li&gt; &lt;li&gt;鬼吹灯&lt;/li&gt; &lt;li&gt;盗墓笔记&lt;/li&gt; &lt;li&gt;名侦探&lt;/li&gt; &lt;li&gt;鬼吹灯&lt;/li&gt;&lt;/ol&gt; ul 无序列表 li列表项 123456789无序列表&lt;ul&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;有保证&lt;/b&gt;&lt;/span&gt;:先学习考试后入学&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;有实力&lt;/b&gt;&lt;/span&gt;:专注JS培训七年铸就传奇就业,平均工资超12K&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;有深度&lt;/b&gt;&lt;/span&gt;:结合的大学算法和数据结构的基础课&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;重原生&lt;/b&gt;&lt;/span&gt;:狠练原生代码,原生JS+Node才是王道&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;重应用&lt;/b&gt;&lt;/span&gt;:PC+移动端+H5+CSS3+node的前后台全栈项目&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;重未来&lt;/b&gt;&lt;/span&gt;:app开发,微信开发,angular,es6,前沿技术&lt;/li&gt;&lt;/ul&gt; dl 定义列表 dt 定义术语 dd定义描述 table 表格 p 段落1234567891011&lt;div class=&quot;poem&quot;&gt;&lt;h4&gt;早发白帝城&lt;/h4&gt;&lt;h5&gt;作者：李白&lt;/h5&gt;&lt;p&gt;朝辞白帝彩云间，&lt;br&gt; 千里江陵一日还。&lt;br&gt; 两岸猿声啼不尽，&lt;br&gt; 轻舟已过万重山。&lt;br&gt; &lt;img src=&quot;timg.jpg&quot; alt=&quot;李白&quot;&gt;&lt;/p&gt;&lt;/div&gt; 123456789&lt;div&gt; &lt;h4 align=&quot;center&quot;&gt;早发白帝城&lt;/h4&gt; &lt;h5 align=&quot;center&quot;&gt;作者：李白&lt;/h5&gt; &lt;p align=&quot;center&quot;&gt;朝辞白帝彩云间，&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;千里江陵一日还。&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;两岸猿声啼不尽，&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;轻舟已过万重山。&lt;/p&gt; &lt;img src=&quot;timg.jpg&quot; alt=&quot;李白&quot;&gt;&lt;/div&gt; form 交互表单 内联元素 内联元素是指本身属性为display:inline;的元素。因为它自身的特点，我们通常使用块级元素来进行文字、小图标（小结构）的搭建。 内联元素的特点： 和其他内联元素从左到右在一行显示 2.不能直接控制宽度、高度以及盒子模型的相关css属性，但是直接设置内外边距的左右值是可以的 3.内联元素的宽高是由本身内容的大小决定（文字、图片等） 4.内联元素只能容纳文本或者其他内联元素（此处请注意，不要在内联元素中嵌套块级元素） 常用的内联元素: span 常用内联容器，定义文本内区块 a 锚点 文本设置类: b 加粗 strong 加粗强调 i 斜体 em 斜体强调 s 中划线（不推荐使用） strike 中划线 del 文档中已被删除的文本 big 大字体文本、small小字体文本） small 小字体文本 br 强制换行 u 下划线 textarea 多行文本输入框 input 输入框 select 下拉列表 label（input 元素定义标注/标记）、img sub 下标 sup 上标]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>html标签</tag>
        <tag>css</tag>
        <tag>html标签分类</tag>
        <tag>标签分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基本结构]]></title>
    <url>%2F2017%2F06%2F30%2FHTML%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[html的基本结构 123456789101112&lt;!DOCTYPE html&gt;文档声明：必须放在html文件的第一行；如果没有文档声明会触发浏览器的怪异模式&lt;html&gt;html元素：告知浏览器，我是一个html文件 &lt;head&gt; head元素：文档的头部，一般放在文档头部的内容不会显示在浏览器的可视区内 &lt;meta charset=&quot;utf-8&quot;&gt;规定一个语法 必须放在head的第一部分 &lt;title&gt;标题，显示在浏览器的页卡位置，title中的内容也会被seo抓取&lt;/title&gt; &lt;body&gt;供用户浏览的所有内容，标签、图片、文本、视频···&lt;/body&gt; &lt;/head&gt;&lt;/html&gt; 一个html文件也叫做一个网页，可以称作是一个文档(document) 这个文档从html元素开始，一致向下分支延伸，像一颗大树一样，所以我们将html元素叫做这个文档的根元素 &lt;!DOCTYPE html&gt;html5的文档声明 作用：定义这个文档类型，浏览器先识别这句话，会按照定义的类型去解析这个文档 html5的文档声明，那么浏览器就会按照html5的规则解析整个页面`&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;html4版本的文档声明` 所有高版本都会向下兼容，所以在以后的工作中，我们直接将文档声明写错html5就可以了 文档声明必须写在html文件的第一行 文档声明不区分大小写 如果html文件没有文档声明，会触发浏览器的怪异模式 文档声明不是一个html标签 1.html元素此元素告知浏览器其自身是一个html元素是由开始和结束标签组成的，html文件里面所有的内容都会放在这个这个元素内 2.head元素- 整个文档的头部，head元素自带隐藏功能，display:none;里面的内容不会隐藏，只不过一般放置在head元素中的其他元素和内容也是自带隐藏功能的，例如link、script、meta··· - `&lt;script&gt;&lt;/script&gt;与head标签一样具有隐藏功能，写在其内的内容在网页不显示` 3.&lt;meta charset=&quot;UTF-8&quot;&gt;4.&lt;meta&gt;规定了html文档的元信息 charset=”UTF-8” 文档的编码 UTF-8 国际通用编码 gbk 国标 gb2312 国标 name=”keyword” content=”关键词” name=”keyword” content=”HTML5J5…” SEO优化有关 SEO搜索引擎&lt;meta name=&quot;keyword&quot; content=&quot;关键词&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;勿忘初心,方得始终&quot;&gt; 5.title元素 html文档名称 一个页面只有一个title元素放文字 显示在浏览器的页卡（页头）位置6.link标签 &lt;link href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; rel=&quot;shortcut icon&quot;&gt; 图标让设计师生成 一般整个图片放在整个项目的根目录下 显示在浏览器页卡位置，title内容之前 &lt;link rel=&quot;stylesheet&quot; herf=&quot;url&quot; type=&quot;texe/css&quot;&gt; 引入一个外部的css文件 rel不能缺少 stylesheet样式表 type可以省略 但是建议写全 7.body元素 定义整个文档的主体部分，所有展示给用户的内容都要放在这个元素中 body中有常用的html元素（div、ul），文本内容、音频、视频、图片、表单1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UIF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html基本结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS的引入方式]]></title>
    <url>%2F2017%2F06%2F30%2FCSS%E7%9A%84%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[css如何在html中使用（html引入css的四种方法） 行内式：直接写在标签内，通过标签属性style引入 媒介：style属性&lt;style type=&quot;text/css&quot;&gt;选择器{}&lt;/style&gt;12&lt;div style=&quot;css属性名:属性值；&quot;&gt;&lt;/div&gt;&lt;img style=&quot;css属性名:属性值；&quot;alt=&quot;&quot;&gt; css想要生效，html中必须有这个元素才可以 内嵌式（内联式）:将css代码写在style元素内，通过css选择器选择html元素，将css样式添加个这个元素 媒介：style标签+选择器 style这个元素一般放在head元素内 style元素：盛装css样式12345&lt;style&gt;div&#123;height:100px;&#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 外联式（外链式）：将css代码单独放置在一个css文件中，再通过link标签将这个css文件引入到html文件中 媒介：link标签+选择器1&lt;link rel=&quot;stylesheet&quot; herf=&quot;css文件链接地址&quot; type=&quot;text/css&quot;&gt; css这个文件中不能出现标签 导入式：都是引入一个单独的css文件 媒介：@import”css文件链接地址”; 当有多个css文件的时候，可以使用导入式先导入到一个css文件中，再用外链式link外链进html文件 @import”css文件链接地址”;既不是html标签，也不是css属性，他是一条声明语句 这条语句必须写在style元素内,或者css文件内 这条语句必须在所在文件内的第一行 外链式和导入式的差别： link和@import虽然都是引入外部的css文件，但是他们是由天差地别的区别的 1) link是html标签，@import完全是css提供的方式，要写在css文件或者style标签中。 2) 他们的加载顺序也是有区别的，当一个页面被加载的时候，link引用的css文件会被同时加载，而@import引入的css文件会等页面全部下载完后再加载。 3) 当使用javascript控制DOM去改变css样式的时候，只能使用link标签，因为import是不能被DOM控制的。 在工作中常用的引入方式是外链式 四种引入方式的权重（一个html元素最终加载的css样式是谁决定的） 有行内式的时候，听行内的 在选择器相同的情况下，谁最后加载就听谁的 外链式和内嵌式一般都放在head元素内 CSS层叠样式表 css的作用： 给html文档添加静态或者动态的样式 css和html如何融合到一起 在css文件中如何选择一个html元素，将样式添加给这个元素]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css引入方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS常用选择器]]></title>
    <url>%2F2017%2F06%2F30%2FCSS%E5%B8%B8%E7%94%A8%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[CSS选择器 因为html和css分离，那么就出现一个问题，如何选择一个元素，将样式添加给这个元素–&gt;css选择器 选择器是css属性和html元素的连接桥梁，通过正确的选择器来找到想要操作的元素，添加一定的样式。 选择器{} 1.语法选择器{key:value;key:value;} 可以批量选择选择器名称相同的元素 通过选择器类型不同，可以选择不同的html元素 2.CSS基础选择器分类1) 标签选择器 1-1).说明:直接使用元素标签进行选择 例如：&lt;p&gt;&lt;/p&gt; p{color:red;} 1-2).权重:11234&lt;style&gt;h1&#123;color:red;&#125;&lt;/style&gt;&lt;h1&gt;标签选择器&lt;/h1&gt; 2) 类选择器 2-1).说明: 1).将html元素的class标签属性值当作选择器使用，需要在这个属性值前面加一个“.” 2).通过元素的类名，来选择元素，一个元素可以有多个类名，都代表这个元素 3).类名是元素class属性中的属性值，例如(下例中的sum即为类名) 12&lt;p class=&apos;sum&apos;&gt;&lt;/p&gt;&lt;style&gt;.sum&#123;&#125;&lt;/style&gt; 4).一个html元素可以有多个css属性值（可以有多个类名，每一个类名之间用空格隔开） 5).类名可以重复使用 2-2).权重:10 类选择器最前方一定要有点,例如:123456&lt;style&gt;.title&#123;color:red;&#125;&lt;/style&gt;&lt;h1 class=&quot;title title1&quot;&gt;标签选择器&lt;/h1&gt;&lt;h1 class=&quot;title&quot;&gt;标签选择器&lt;/h1&gt;//以上class属性名为title中的文字颜色都讲被设置为红色 3) id选择器 3-1).说明: 1).一个html元素，id属性值只能用一次，id在html中具有唯一性 2).类选择器最前方一定要有# 3).通过元素的id名，来选择元素 4).类名是元素id属性中的属性值(title/title1)，例如:12345&lt;style&gt;#title&#123;color:red;&#125;&lt;/style&gt;&lt;h1 id=&quot;title title1&quot;&gt;id选择器&lt;/h1&gt;&lt;h1 id=&quot;title&quot;&gt;错误的，不识别&lt;/h1&gt; 3-2).权重:100 总结(根据权重)： 标签选择器相当于人的姓名,类选择器相当于人的名字,id选择器相当于身份证号码,是独一无二的。 4) 通配符选择器 4-1). 说明: 1).通过*匹配全部html元素，包括根元素 2).一般不使用，因为全部匹配耗性能 3)语法:*{}1*&#123;key:value&#125; 4-2). 权重&lt;1,可被覆盖 5) 并集选择器 5-1).说明: 1). 你可以对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。用逗号将需要分组的选择器分开。在下面的例子中，我们对所有的标题元素进行了分组。所有的标题元素都是绿色的。 例如：1h1,h2,h3,h4,h5,h6&#123;color:green;&#125; 6) 属性选择器 6-1).说明: 1). 对带有指定属性的 HTML 元素设置样式，可以为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。 下面的例子为带有 title 属性的所有元素设置样式：123[title]&#123; color:red; &#125; 2). 利用标签的属性名和属性值来选择html元素 3). 属性选择器在使用的时候，如果一个元素有两个类名，那么是不生效的。 4). 属性选择器我们一般不会使用class,因为class可以直接使用类选择器12345&lt;!--有多少种方法只获取div?--&gt; /*如果class值有两个，不能这样使用*/&lt;style&gt;[class=div1]&#123;&#125;;&lt;/style&gt;&lt;div class=&quot;div1 p1&quot; id=&quot;div2&quot;&gt;&lt;/div&gt;&lt;p class=&quot;p1&quot;&gt;&lt;/p&gt; 6-2). 语法： [标签属性名]{} [标签属性名=属性值]{}123456789&lt;style&gt;h1[title]&#123;&#125; //交集选择器//权重:标签+属性的权重=11[type]&#123;&#125;//权重：10[type=text]&#123;&#125;//权重:10&lt;/style&gt;&lt;a href=&quot;&quot; title=&quot;&quot;&gt;link&lt;/a&gt; 6-3). 权重:10 7)属性和值选择器 7-1). 说明: 1). 下面的例子为 title=”xx” 的所有元素设置样式： 1234[title=xx] &#123; border:5px solid blue; &#125; 2). 设置表单的样式 12345678input[type=&quot;text&quot;]&#123; width:150px; display:block; margin-bottom:10px; background-color:yellow; font-family: Verdana, Arial;&#125; 8)分组选择器 8-1).作用(应用场景): 1). 同一份css样式，可以一次性的添加给多个不同的html元素 8-2).语法： 选择器1,选择器2,选择器3{};例如:12.box,li,.p1&#123;color: red&#125;.box&#123;color:green&#125; 8-3).权重 1)分组选择器将不同的html分为一组，权重计算的时候都是独立计算，不会叠加。 9)交集选择器 9-1).一个元素具有两个属性(两种属性同属一个元素的时候)，可以使用交集选择器来进行元素的准确选择 9-2).组成选择器的两部分，必须属于同一个 反例(错误用法): 123&lt;style&gt;h1.p1&#123;&#125; //--&gt;什么都选择不到&lt;/style&gt;&lt;p class=&quot;p1&quot;&gt;&lt;/p&gt;&lt;h1&gt;&lt;/h1&gt; 正例(正确用法): 123456789&lt;p class=&apos;name1 name2&apos; id=&apos;id1&apos;&gt;&lt;/p&gt;&lt;style&gt;//第一种:p.name1&#123;&#125;//第二种:p#id1&#123;&#125;//第三种:.name1.name2&#123;&#125;&lt;/style&gt; 使用解说(正确用法): 1.组合选择器之间没有任何的符号和空格 2.标签选择器和其他选择器组合的时候，标签选择器要放在前面 3.交集选择器是两个选择器组合在一起，可以是1)标签和类名,2)标签和属性选择器,3)标签和id,4)两个类选择器。 9-3). 作用 精确查找元素，增加选择器的权重1234567891011121314151617181920212223242526&lt;style&gt;h1&#123;&#125;//标签选择器 权重:1[title]&#123;&#125;//属性选择器 权重:10[title=xx]&#123;&#125;//属性选择器 权重:10h2[title]&#123;&#125;//交集选择器 权重:11h2[title=xx]&#123;&#125;//交集选择器 权重:11&lt;/style&gt;&lt;h1 title=&quot;xx&quot;&gt;&lt;/h1&gt;&lt;h2 title=&quot;xx&quot;&gt;&lt;/h2&gt;&lt;style&gt;p.p1&#123;&#125;//交集选择器 权重:11&lt;/style&gt;&lt;p class=&quot;p1&quot;&gt;&lt;/p&gt;&lt;style&gt;.p1.p2&#123;&#125;//交集选择器 权重:20&lt;/style&gt;&lt;p class=&quot;p1 p2&quot;&gt;&lt;/p&gt; 10)子集选择器 10-1). 说明: 1). 与后代选择器相比，子元素选择器只能选择作为某元素子元素的元素。 2). 父级选择器是用来确定范围的， 3). 子级选择器才是我们要添加样式的那个元素 4). 子级选择器必须是紧邻的父子关系 10-2). 语法: 父级选择器&gt;子级选择器 10-3). 权重 所有选择器之和 1234567&lt;style&gt;ul&gt;li&#123;color:red;&#125;//选择ul下的li 权重:2&lt;/style&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 11)后代选择器(派生选择器) 11-1). 说明: 1). 在一个根元素的范围内，查找到它的后代元素 2). 后代选择器在写的时候尽量控制在３个左右 3). 选择器过多浪费性能，不建议使用 11-2). 举例: 1). html结构： 1234&lt;ol&gt; &lt;li&gt;&lt;strong&gt;我是斜体字。这是因为 strong 元素位于 li 元素内。&lt;/strong&gt; &lt;/li&gt;&lt;/ol&gt; 2). 列表中的 strong 元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器： 1234li strong &#123; font-style: italic; font-weight: normal; &#125; 3). 后代选择器在写的时候尽量控制在３个左右,选择器过多浪费性能: 12345678910&lt;style&gt;.div ul span&#123;&#125;&lt;/style&gt;&lt;div class=&quot;div&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;只选择这个span元素&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 11-3). 语法: 祖辈选择器 要查找的后代选择器{};(中间用空格连接) 12)相邻兄弟选择器 12-1). 说明: 1). 相邻兄弟选择器可选择紧接在另一元素后的元素，且二者有相同父元素。 2). 通过各个元素选择弟弟选择器,两个选择器之间用“+”连接;例如: h1 + p {margin-top:50px;} 12-2).语法: 哥哥选择器+弟弟选择器{};123456789101112&lt;style&gt; .list1+li&#123;color:red;&#125; //22222变为红色 .list3+li&#123;color:green;&#125; //4444变为绿色&lt;/style&gt;&lt;ul&gt; &lt;li class=&quot;list1&quot;&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li class=&quot;list3&quot;&gt;33333&lt;/li&gt; &lt;li&gt;4444&lt;/li&gt;&lt;/ul&gt; 12-3).权重:选择器之和 13)伪类选择器 13-1).说明: 1). 给一个元素添加某种状态 例如:鼠标经过时/获取焦点时/鼠标点击时 13-2). 权重:10 13-3).举例: 1). a标签 CSS 伪类用于向某些选择器添加特殊的效果 12345678910111213&lt;style&gt; a:link &#123;color: #FF0000&#125; /* 未访问的链接 是默认状态*/ a:visited &#123;color: #00FF00&#125; /* 已访问的链接 鼠标点击后的状态*/ a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 鼠标经过的状态*/ a:active &#123;color: #0000FF&#125; /* 选定的链接 鼠标点击的状态*/&lt;/style&gt;&lt;a href=&quot;javascript:void (0)&quot;&gt;最初形态&lt;/a&gt;&lt;a href=&quot;javascript:void 0&quot;&gt;赛亚人形态&lt;/a&gt;&lt;a href=&quot;javascript:&quot;&gt;超级赛亚人形态&lt;/a&gt; 2). input标签 1234567&lt;style&gt; .input&#123;border: 1px solid gainsboro&#125; .input:hover&#123;border-color: gray&#125; .input:focus&#123;border-color: blue&#125; /*input:focus 鼠标聚焦后的状态，input独有的属性*/&lt;/style&gt;&lt;input type=&quot;text&quot; class=&quot;input&quot;&gt; 14)CSS 伪元素 14-1). 说明: 1). 通过css代码向指定元素内添加假的（html中不存在的）元素 14-2). 举例: CSS 伪元素用于向某些选择器设置特殊效果 1)before “before”会出现在div所有内容之前 “:before”伪元素可以在元素的内容前面插入新内容。 下面的例子在每个 &lt;h1&gt; 元素前面插入内容:’我是一个伪元素’： 1234h1:before &#123; content:&apos;我是一个伪元素&apos;; &#125; 2)after 会出现在div所有内容之后使用伪元素的时候要保证两个前提 2-1)要有display这个属性 2-2)要有content这个属性，这个属性的属性值可以为空，但是引号不能少(content:&quot;&quot;): 12345678910111213141516171819202122&lt;style&gt; div&#123; width: 300px; height: 300px; background-color: red; &#125; div:before&#123; display: block; content: &quot;我是before&quot;; font-size: 40px; color: white; &#125; div:after&#123; display: block; content: &quot;我是aftre&quot;; font-size: 40px; color: blue; &#125;&lt;/style&gt;&lt;div&gt; &lt;span&gt;我是span&lt;/span&gt;&lt;/div&gt; 网页显示：“伪元素选择器” 注意1.选择器的查找机制 选择器的查找机制是从右向左,例如:123456&lt;style&gt;.div ul li&#123;&#125;&lt;!-- 第一步选择这个文档中所有的li第二步选择哪些li是ul下面的第三步选择哪些li是ul下面，ul还是.div1下面的 --&gt;&lt;/style&gt; 2.选择器的组成最好不要超过三个3.后代选择器没有必要将每一层元素都写出来，只写那些关键节点即可(具有代表性的)]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows快捷键整理]]></title>
    <url>%2F2017%2F06%2F30%2FWindow%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[window+E 打开我的电脑 alt+tab 切换操作界面 window+R 运行 ctrl+C 复制 ctrl+X 剪切 ctrl+S 保存 ctrl+shift+S 另存 ctrl+Z 撤销 ctrl+W 关闭 ctrl+A 全选 ctrl+V 粘贴 ctrl+alt+delete 资源管理器 或 菜单右键选择资源管理器 F2 重命名 web： ctrl+alt+L整理代码]]></content>
      <categories>
        <category>前端常识</category>
      </categories>
      <tags>
        <tag>前端常识</tag>
        <tag>windows</tag>
        <tag>windows快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS中常用的HTML元素及标签]]></title>
    <url>%2F2017%2F06%2F30%2FCSS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84HTML%E5%85%83%E7%B4%A0%E5%8F%8A%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[常用的HTML标签总结 div 无意义标签，用来区分网页大模块，例如网页头部、主题内容、尾部 &lt;div&gt;无意义元素，用它来区分网页大模块&lt;/div&gt;123456789banner&lt;div&gt;区分模块 &lt;a href=&quot;http://www.baidu.com&quot;&gt; &lt;img src=&quot;pic.jpg&quot; alt=&quot;备注/描述&quot;&gt; &lt;/a&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;&quot; alt=&quot;图片加载出问题了&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt; &lt;/a&gt;&lt;/div&gt; span 无意义标签,用来描述行内某个小模块 p &lt;p&gt;段落&lt;/p&gt; ul li 无序列表 ol li 有序列表 b 加粗 strong 加粗,浏览器解析的时候,有强调作用 body 身体,网页主体部分 （内容在浏览器可视区显示） a 超链接,描点123点击元素可以进行跳转的&lt;a href=&quot;链接路径&quot; target=&quot;_blank&quot;&gt;珠峰培训&lt;/a&gt;&lt;a href=&quot;pic.jpg&quot; target=&quot;_blank&quot;&gt;珠峰培训&lt;/a&gt; img 插入图片12&lt;img src=&quot;图片路径&quot; alt=&quot;备注/描述&quot;&gt;&lt;img src=&quot;pic.jpg&quot; alt=&quot;备注/描述&quot;&gt; i 作用：斜体 em 强调 作用：*斜体 h1-h6 标题 dl-dt-dd定义列表 常用在新闻标题和摘要 dt 定义标题 dd 定义描述 一个dt可以多个dd进行描述 标签 标签（由尖括号和关键字组成的超文本） 关键字（就是普通文本），在编辑html这门语言的时候，相关组织将这些文本归纳到了一定的规则中，是他有了特殊的含义和作用 标签的分类：开始标签、结束标签、空标签 12345678&lt;开始标签&gt;&lt;空标签 /&gt;&lt;div&gt;&lt;/div&gt;&lt;b&gt;&lt;/b&gt;&lt;strong&gt;&lt;/strong&gt;&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;···&lt;/结束标签&gt; 标签属性：用来描述标签功能的，一般写在开始标签中，跟在标签名的后面，用空格隔开，一个标签可以有很多标签属性，每一个属性都用空格隔开 12&lt;开始标签 属性名=&quot;属性值&quot; 属性名1=&quot;属性值&quot;&gt;&lt;结束标签&gt;&lt;img src=&quot;url&quot; alt=&quot;备注&quot; /&gt; html标签 html标签HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。 标签不会出现在页面中，只有标签中的内容才会显示在页面上 ：也就是&lt;html&gt;此处为内容&lt;/html&gt; 标签不区分大小写，但是推荐使用小写 ：(X)HTML 版本中强制使用小写，这样更加严谨 标签分为闭合标签和空标签 ：闭合标签是指由开始标签和结束标签组成的一对标签，这种标签允许嵌套和承载内容，例如：&lt;html&gt;&lt;/html&gt;、&lt;p&gt;&lt;/p&gt;；空标签是没有内容的标签，在开始标签中自动闭合，例如：&lt;img /&gt;、&lt;br /&gt;、&lt;hr /&gt;等 元素 由标签（开始和结束标签中有内容）和内容组成，元素中内容可以为空，一个空标签也叫做一个元素 12&lt;div&gt;content&lt;/div&gt;--&gt;div元素&lt;img src=&quot;url&quot; alt=&quot;备注&quot; /&gt;--&gt;img元素 标签属性经过html的进化，舍弃了有关样式的标签属性，保留功能的标签属性 例如舍弃width bgcolor align，这些样式描述都放在css里面 保留alt title src href··· iframe标签在引入其他文件的时候，必须写宽度和高度]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>html元素</tag>
        <tag>html标签</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“前端三层”]]></title>
    <url>%2F2017%2F06%2F30%2F%E2%80%9C%E5%89%8D%E7%AB%AF%E4%B8%89%E5%B1%82%E2%80%9D%2F</url>
    <content type="text"><![CDATA[前端三层 html结构 是直接被浏览器解析加载 CSS样式 是在html结构之上去装点网站 javascript 交互 动态效果/数据交互 基础知识 网页 网页是构成网站的基本元素，通俗来讲，一个html文件就是一个网页 网站 是由很多个网页组成的，共同为一个目标服务的网页集合 站群（流水线统一化管理） 由很多网站组成的，为同一个公司服务。 例如整个百度下所属的子公司都有自己的网站。例如：百度搜索/糯米/音乐/手机助手/百度金融等组成的就是一个站群。 HTTP（超文本传输协议） HyperText Transfer Protocol 在万维网上提供一种发布和接收HTML页面（网页）的方法。 eg：http://www.baidu.com 404服务器无响应 步骤: 输入网址，建立链接，建立客户端和服务端的连接。 发送请求信息：客户端发送一个请求给服务器 发送相应信息：服务器找到请求后，给予相应的响应信息 关闭连接：客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接 服务器 服务器，是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。 在网络环境下，根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，WEB服务器等。 防篡改：WEB端服务器一旦受到攻击，在0.0n秒做出反应，将内网服务器中的内容，马上覆盖在WEB服务器上。 负载均衡：平均WEB服务器压力，将用户访问进行分流。 vpn：用来翻墙，有指定账号就可以通过这个产品进行内网访问。 浏览器 浏览器是指可以显示网页服务器或者文件系统的HTML文件（标准通用标记语言的一个应用）内容，并让用户与这些文件交互的一种软件。 html，css，js都是运行在这个软件中，浏览器是一个工厂，html/css/js是工人和原料。 IE6–&gt;IE7（很快淘汰）–&gt;IE8(时间较长，稳定性好)–&gt;IE9(半年到一年)–&gt;IE10–&gt;IE11–&gt;IE11–&gt;IE(Edge) 最好用的浏览器–&gt;谷歌 网页的基本组成 HTML:是网页的骨架,支撑起血肉(文字,图片,音视频等) CSS:表皮和衣服、化妆品 javascript：动态和交互 HTML（超文本标记语言） 网页本身就是一种文本文件（除了文字再无其他），只有通过特定的标记描述，那些普通文本才能在浏览器中正常显示。 在页面中如果遇到图片、音视频的时候，如何用文本描述，需要用超文本进行引入才可以正常显示。 HTML文件的特点： 浏览器根据标记来解析和描述内容（从html的第一行开始向下），如果遇到错误，浏览器不会指出也不会报错，会跳过此处继续加载，编辑人员需要根据显示效果去分析哪里出错误了——html不会报错 HTML的兼容问题： 因为浏览器是由不同厂商生产的，所以对html的解析有分歧，产生了页面效果显示不一致的情况，我们将这个问题叫做兼容问题。 超文本（标签） 标签语法： 由成对的尖括号和关键字组成，叫做标签。 关键字（标签名）：是已经规范过的，不是自己随便制造的。 例如：&lt;div&gt; , &lt;/h2&gt; , &lt;img/&gt; 标签属性 属性提供了这个元素的更多信息，语法：由属性名和属性值组成（键值对 key=”value”） 1234&lt;span style=&quot;font-family:宋体;&quot; title=&quot;标题&quot;&gt;span是标签名style是标签属性名&quot;font-family:宋体;标签属性值 一个标签可以由多个标签属性，每一个属性之间用空格隔开 标签的分类: 开始标签 &lt;div&gt; 结束标签 &lt;/div&gt; 自闭合标签(空标签) &lt;br/&gt; HTML元素 可以将元素理解成一个容器，容器中放置的就是 由标签和内容组成的，叫做元素。 &lt;div&gt;此处是内容&lt;/div&gt; 元素分类 由开始标签和结束标签组成的元素，可以进行嵌套（一个元素包着另一个元素），元素中可以添加内容，只有一个空标签，只能进行功能的添加，例如img元素 标签和元素是用来标记和描述内容的，所以这些标签和元素用户是看不到的，用户只能看到这个元素的内容。]]></content>
      <categories>
        <category>前端常识</category>
      </categories>
      <tags>
        <tag>前端常识</tag>
        <tag>前端三层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown的简单使用]]></title>
    <url>%2F2017%2F06%2F30%2Fmarkdown%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[#–&gt; 一级标题 相当于html中的h1标签 [TOC]–&gt;目录 ##–&gt; 二级标题 相当于html中的h2标签 ###–&gt; 三级标题 相当于html中的h3标签 ####–&gt; 四级标题 相当于html中的h4标签 #####–&gt; 五级标题 相当于html中的h5标签 ######–&gt; 六级标题 相当于html中的h6标签 在每个段落或标题结束后 增加一个回车（一行空白） 普通段落相当于html中的p标签 列表： -+空格（-列表-） -+空格+tab（二级列表） -+空格+tab+tab（三级列表） 如何缩进 –&gt; 点击tab键 编辑新的内容（英文状态下，按住shift+“—”） &gt; (大于号加空格)–&gt; 摘要或标注编辑表格:左边有冒号代表左对齐,右边有冒号代表右对齐,两边都有冒号代表居中 快捷键：ctrl+alt+T |标题|标题|标题| |:—-|—-:|:—-:| |左对齐|右对齐|居中| 例如: 标题 标题 标题 左对齐左对齐左对齐 右对齐右对齐右对齐 居中居中居中居中 内容 内容 内容 编辑代码块&lt;div&gt;div&lt;/div&gt;123&lt;div&gt;div&lt;/div&gt;&lt;div&gt;div&lt;/div&gt;&lt;div&gt;div&lt;/div&gt; 编辑行内代码:独立的行间代码 html中的p标签：&lt;p&gt; 插入图片 可以直接复制粘贴 快捷键：ctrl+G 插入链接： ctrl+L 保存笔记的方法: 点击【账号】选择【导出】 –&gt; 可以导出md格式，pdf格式，html格式 md格式：再次打开时，可以使用文本文档打开，将内容复制一份粘到markdown软件中 pdf格式：直接观看，但不能修改 html格式：可以浏览器中直接观看，可以在代码编辑器中修改 快捷键： 文档管理 –&gt; Ctrl+O 帮助 –&gt; Ctrl+/ 最大化编辑器 –&gt; Ctrl+Enter 预览文档 –&gt; Ctrl+Alt+Enter 同步文档 –&gt; Ctrl+S 创建文档 –&gt; Ctrl+Alt+N 系统菜单 –&gt; Ctrl+M 斜体 –&gt; Ctrl+I 粗体 –&gt; Ctrl+B]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs的全局对象和全局变量]]></title>
    <url>%2F2017%2F06%2F27%2FNodejs%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[全局对象 所有模块都可以调用 global：表示Node所在的全局环境，类似于浏览器中的window对象。 你可以通过console.log(global);来输出一下global; 1-1. global全局对象里常用的变量 1). __dirname 存储的是在nodejs中执行javascript所在的绝对目录 12 console.log(__dirname);//C:\Users\Gao\Documents\webstore学习文件\node 2). __filename 文件名 12console.log(__filename);//C:\Users\Gao\Documents\webstore学习文件\node\global.js process 程序所执行的一些相关的内容信息的封装对象 指向Node内置的process模块，允许开发者与当前进程互动。 例如你在DOS或终端窗口直接输入node，就会进入NODE的命令行方式（REPL环境）。如果要退出的话，可以输入 process.exit(); 2-1. 和输出相关的 process.stdout/process.stderr 1) process.stdout –&gt; standard output –&gt; 标准的信息输出 2) process.stderr –&gt; standard error –&gt; 标准的错误输出 console.info和console.error这些相关的输出功能就是调用的process.stdout和process.stderr来完成的12process.stdout.write(&quot;this is stdout&quot;);process.stderr.write(&quot;this is stderr&quot;);//红色的 2-2. process如何去监听一些事件 1) process.stdin.on() 监听用户输入的键盘信息 2)process.on()监听操作系统对node发出的一些信号 2-3. 如何读取输入用户的键盘输入 1).process.stdin 在使用process.stdin之前 要先对他进行一下编码设置```process.stdin.setEncoding(“utf-8”);//这里的编码设置和平常编写网页时候的文本编码不一样//在这里如果想读取纯文本信息 只要把他的编码设置成utf-8就可以了 不需要去考虑类似jbk或者jb2312来区分是不是中文//on方法来监听用户相关的输入事件// process.stdin.on(“data”,function (data) {// console.log(data);// });process.stdin.on(“readable”,function () { var data=process.stdin.read(); //回调函数没有参数 需要通过process.stdin.read来读取用户的键盘输入信息 console.log(data);}); //exit事件process.on(“exit”,function () { console.log(“programe will exit”);});//在程序正常退出的之前 会触发exit事件 //SIGINT –&gt; signal interrupted 信号 被中断//当一个信号被中断的时候就会触发SIGINT事件(cmd 中 ctrl+c会中断信号) process.on(“SIGINT”,function () {//会改变程序默认的退出行为 console.log(“programe has a sigint”); process.exit();//让程序正常退出}); console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。通常是写console.log();全局函数 定时器函数：共有4个，分别是setTimeout(), clearTimeout(), setInterval(), clearInterval()。 require：用于加载模块 全局变量： _filename：指向当前运行的脚本文件名。 _dirname：指向当前运行的脚本所在的目录 准全局变量 模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。 module变量指代当前模块。module.exports变量表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。 module.id 模块的识别符，通常是模块的文件名。 module.filename 模块的文件名。 module.loaded 返回一个布尔值，表示模块是否已经完成加载。 module.parent 返回使用该模块的模块。 module.children 返回一个数组，表示该模块要用到的其他模块。 这里需要特别指出的是，exports变量实际上是一个指向module.exports对象的链接，等同在每个模块头部，有一行这样的命令。var exports = module.exports; 这造成的结果是，在对外输出模块接口时，可以向exports对象添加方法，但是不能直接将exports变量指向一个函数：exports = function (x){ console.log(x);}; 上面这样的写法是无效的，因为它切断了exports与module.exports之间的链接。 如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>node全局对象</tag>
        <tag>node全局变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[caller和callee]]></title>
    <url>%2F2017%2F06%2F26%2FJS%E4%B8%AD%E7%9A%84caller%E5%92%8Ccallee%2F</url>
    <content type="text"><![CDATA[caller 检验函数被谁调用过 检验函数被谁调用过 返回值是调用这个函数的函数本身,没有的话返回null arguments.callee 函数本身12345678910function Fn() &#123; console.log(arguments.callee.caller);//--&gt;function fn() &#123;Fn()&#125; //--&gt;arguments.callee 函数本身 //caller:检验函数被谁调用过 返回值是调用这个函数的函数本身,没有的话返回null console.log(Fn.prototype.constructor === arguments.callee);//--&gt;true&#125;function fn() &#123; Fn()&#125;fn(); 12345678910function sum(n) &#123; console.log(arguments.callee===arguments.callee.caller); //-&gt;第一次输出false，因为第一次是函数自己执行，即自调用 自调用的时候console.log(arguments.callee.caller) 输出null 而此时arguments.callee 函数本身仍然是sun函数本身 所以输出false; // --&gt;当自调用执行完成后 arguments.callee===arguments.callee.caller===sum这个函数本身 ---&gt; 返回true if(n&lt;=0)&#123; return 0 &#125; return n+sum(--n);&#125;console.log(sum(10));//55]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>caller</tag>
        <tag>callee</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的同步异步编程思想]]></title>
    <url>%2F2017%2F06%2F23%2FJS%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[JS是单线程的-&gt;JS就是个傻子,脑子一根筋,做着当前的这件事情,没有完成之前,绝对不会做下一件是事情 JS中的两种编程思想:同步、异步 1、同步编程-&gt;上一件事情没有完成,继续处理上一件事情,只有上一件事情完成了,才会做下一件事情(JS中大部分都是同步编程的) 123456for (var i = 0; i &lt; 100000; i++) &#123; if (i == 99999) &#123; console.log(&quot;循环结束了~~&quot;);//-&gt;(1) &#125;&#125;console.log(&quot;ok&quot;);//-&gt;(2) 1) for循环就是同步编程的,只有循环结束后,才会继续执行下面的代码 1234while (1) &#123;&#125;console.log(&quot;ok&quot;);//-&gt;永远都不会执行的,因为上面的循环是死循环,循环永远都不会结束 2、异步-&gt;规划要做一件事情,但是不是当前立马去执行这件事情,需要等一定的时间,这样的话,我们不会等着它执行,而是继续执行下面的操作,”只有当下面的事情都处理完成了,才会返回头处理之前的事情;如果下面的事情并没有处理完成,不管之前的事情有没有到时间,都踏踏实实的给我等着” 在JS中异步编程只有四种情况: 1)定时器都是异步编程的 2)所有的事件绑定都是异步编程的 3)Ajax读取数据的时候,我们一般都设置为异步编程 4)回调函数也是异步编程的123456var n = 0;window.setTimeout(function () &#123; n++; console.log(n);//-&gt;1 (2)&#125;, 1000);console.log(n);//-&gt;0 (1) 3.定时器 1) 每一个浏览器对于定时器的等待时间都有一个最小的值,谷歌:5~6ms IE:10~13ms,如果设置的等待时间小于这个值,不起作用,还是需要等到最小时间才执行的;尤其是写0也不是立即执行; 1234567var n = 0;window.setTimeout(function () &#123; n++; console.log(n);//-&gt;1 (2)&#125;, 0);console.log(n);//-&gt;0 (1)//--&gt;先输出0 再输出1 2) 我们定时器设置的等待时间不一定就是最后执行的时间,如果定时器之后还有其他的事情正在处理中,不管定时器的时间有没有到,都是不会执行定时器的 12345678910111213141516171819202122 var n = 0; window.setTimeout(function () &#123; n++; console.log(n);//-&gt;不执行的 &#125;, 0); console.log(n);//-&gt;0 (1) while (1) &#123;//-&gt;死循环 n++; &#125;console.log(n);//-&gt;不执行 var n = 0; window.setTimeout(function () &#123; n += 2; console.log(n); //-&gt;7 (4) &#125;, 20); window.setTimeout(function () &#123; n += 5; console.log(n); //-&gt;5 (3) &#125;, 5); console.log(n);//-&gt;0 (1) for (var i = 0; i &lt; 10000000; i++) &#123;&#125; console.log(n);//-&gt;0 (2) 3)事件绑定 123456var oLis=document.getElementsByTagName(&quot;li&quot;); for(var i=0;i&lt;oLis.length;i++)&#123; oLis[i].onclick=function()&#123; tabChange(i); &#125; &#125;]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>同步异步编程思想</tag>
        <tag>js同步异步编程思想</tag>
        <tag>同步异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE版本条件注释语句(全)]]></title>
    <url>%2F2017%2F06%2F20%2FIE%E7%89%88%E6%9C%AC%E6%9D%A1%E4%BB%B6%E6%B3%A8%E9%87%8A%E8%AF%AD%E5%8F%A5-%E5%85%A8%2F</url>
    <content type="text"><![CDATA[IE版本条件注释语句(全) 123&lt;!--[if lt IE 9]&gt;&lt;script charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;js/html5.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 1、只有IE才能识别 123&lt;!--[if IE]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 因为只有IE5以上的版本才开始支持IE条件注释，所有“只有IE”才能识别的意思是“只有IE5版本以上”才能识别。 2、只有特定版本才能识别 123&lt;!--[if IE 8]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 识别特定的IE版本，高了或者低了都不可以。上例只有IE8才能识别。 3、只有不是特定版本的才能识别 123&lt;!--[if !IE 7]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 上例中特定IE7版本不能识别，其他版本都能识别，当然要在IE5以上。 4、只有高于特定版本才能识别 123&lt;!--[if gt IE 7]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 上例中只有高于IE7的版本才能识别。IE7无法识别。 5、等于或者高于特定版本才能识别 123&lt;!--[if gte IE 7]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 上例中IE7和更高的版本都能识别。 6、只有低于特定版本的才能识别 123&lt;!--[if lt IE 7]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 上例中只有低于IE7的版本才能识别，IE7无法识别。 7、等于或者低于特定版本的才能识别 123&lt;!--[if lte IE 7]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 上例中IE7和更低的版本可以识别。 关键词解释 上面那些代码好像很难记的样子，其实只要稍微解释一下关键字就很容易记住了。 lt ：就是Less than的简写，也就是小于的意思。 lte ：就是Less than or equal to的简写，也就是小于或等于的意思。 gt ：就是Greater than的简写，也就是大于的意思。 gte：就是Greater than or equal to的简写，也就是大于或等于的意思。 !：就是不等于的意思，跟javascript里的不等于判断符相同。 特别提示： １、有人会试图使用&lt;!–[if !IE]&gt;来定义非IE浏览器下的状况，但注意：条件注释只有在IE浏览器下才能执行，这个代码在非IE浏览下被当做注释视而不见。 ２、我们通常用IE条件注释根据浏览器不同载入不同css，从而解决样式兼容性问题的。其实它可以做的更多。它可以保护任何代码块——HTML代码块、JavaScript代码块、服务器端代码……看看下面的代码。12345&lt;!--[if IE]&gt;&lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;你使用的是IE浏览器！&quot;);&lt;/script&gt;&lt;![endif]--&gt; 12345678910111213141516171819202122232425262728293031323334353637&lt;!–[if !IE]&gt;&lt;!–&gt;&lt;!–&lt;![endif]–&gt;&lt;!–除IE外都可识别（IE10版本以上也可以识别）–&gt;&lt;!–[if IE]&gt;&lt;![endif]–&gt;&lt;!–IE9以及以下版本可识别–&gt;&lt;!–[if IE 5]&gt;&lt;![endif]–&gt;&lt;!–仅IE5可识别–&gt;&lt;!–[if IE 5.0]&gt;&lt;![endif]–&gt;&lt;!–仅IE5.0可识别–&gt;&lt;!–[if IE 5.5]&gt;&lt;![endif]–&gt;&lt;!–仅IE5.5可识别–&gt;&lt;!–[if IE 6]&gt;&lt;![endif]–&gt;&lt;!–仅IE6可识别–&gt;&lt;!–[if IE 7]&gt;&lt;![endif]–&gt;&lt;!–仅IE7可识别–&gt;&lt;!–[if IE 8]&gt;&lt;![endif]–&gt;&lt;!–仅IE8可识别–&gt;&lt;!–[if IE 9]&gt;&lt;![endif]–&gt;&lt;!–仅IE9可识别–&gt;&lt;!–[if lt IE 5]&gt;&lt;![endif]–&gt;&lt;!–IE5以下版本可识别–&gt;&lt;!–[if lt IE 5.0]&gt;&lt;![endif]–&gt;&lt;!–IE5.0以下版本可识别–&gt;&lt;!–[if lt IE 5.5]&gt;&lt;![endif]–&gt;&lt;!–IE5.5以下版本可识别–&gt;&lt;!–[if lt IE 6]&gt;&lt;![endif]–&gt;&lt;!–IE6以下版本可识别–&gt;&lt;!–[if lt IE 7]&gt;&lt;![endif]–&gt;&lt;!–IE7以下版本可识别–&gt;&lt;!–[if lt IE 8]&gt;&lt;![endif]–&gt;&lt;!–IE8以下版本可识别–&gt;&lt;!–[if lt IE 9]&gt;&lt;![endif]–&gt;&lt;!–IE9以下版本可识别–&gt;&lt;!–[if lte IE 5]&gt;&lt;![endif]–&gt;&lt;!–IE5以及IE5以下版本可识别–&gt;&lt;!–[if lte IE 5.0]&gt;&lt;![endif]–&gt;&lt;!–IE5.0以及IE5.0以下版本可识别–&gt;&lt;!–[if lte IE 5.5]&gt;&lt;![endif]–&gt;&lt;!–IE5.5以及IE5.5以下版本可识别–&gt;&lt;!–[if lte IE 6]&gt;&lt;![endif]–&gt;&lt;!–IE6以及IE6以下版本可识别–&gt;&lt;!–[if lte IE 7]&gt;&lt;![endif]–&gt;&lt;!–IE7以及IE7以下版本可识别–&gt;&lt;!–[if lte IE 8]&gt;&lt;![endif]–&gt;&lt;!–IE8以及IE8以下版本可识别–&gt;&lt;!–[if lte IE 9]&gt;&lt;![endif]–&gt;&lt;!–IE9以及IE9以下版本可识别–&gt;&lt;!–[if gt IE 5]&gt;&lt;![endif]–&gt;&lt;!–IE5以上版本可识别–&gt;&lt;!–[if gt IE 5.0]&gt;&lt;![endif]–&gt;&lt;!–IE5.0以上版本可识别–&gt;&lt;!–[if gt IE 5.5]&gt;&lt;![endif]–&gt;&lt;!–IE5.5以上版本可识别–&gt;&lt;!–[if gt IE 6]&gt;&lt;![endif]–&gt;&lt;!–IE6以上版本可识别–&gt;&lt;!–[if gt IE 7]&gt;&lt;![endif]–&gt;&lt;!–IE7以上版本可识别–&gt;&lt;!–[if gt IE 8]&gt;&lt;![endif]–&gt;&lt;!–IE8以上版本可识别–&gt;&lt;!–[if gt IE 9]&gt;&lt;![endif]–&gt;&lt;!–IE9以上版本可识别–&gt;&lt;!–[if gte IE 5]&gt;&lt;![endif]–&gt;&lt;!–IE5以及IE5以上版本可识别–&gt;&lt;!–[if gte IE 5.0]&gt;&lt;![endif]–&gt;&lt;!–IE5.0以及IE5.0以上版本可识别–&gt;&lt;!–[if gte IE 5.5]&gt;&lt;![endif]–&gt;&lt;!–IE5.5以及IE5.5以上版本可识别–&gt;&lt;!–[if gte IE 6]&gt;&lt;![endif]–&gt;&lt;!–IE6以及IE6以上版本可识别–&gt;&lt;!–[if gte IE 7]&gt;&lt;![endif]–&gt;&lt;!–IE7以及IE7以上版本可识别–&gt;&lt;!–[if gte IE 8]&gt;&lt;![endif]–&gt;&lt;!–IE8以及IE8以上版本可识别–&gt;&lt;!–[if gte IE 9]&gt;&lt;![endif]–&gt;&lt;!–IE9以及IE9以上版本可识别–&gt;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>ie条件注释语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站如何发布]]></title>
    <url>%2F2017%2F06%2F20%2F%E7%BD%91%E7%AB%99%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[客户端（浏览器） DNS服务器 域名解析服务器 www.baidu.com-&gt;61.135.169.121 网站如何发布?1.租一台服务器（阿里云服务器：主机/虚拟服务器） 给这个主机/服务器连接网络（连个网线），联网之后就会有个外网ip地址 （就是别人通过外网的ip可以找到我们的服务器，一般公司都会禁止外网IP访问） 例如，通过本地webstore打开本地的文件地址是 http://localhost:63342/webstore%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6/JS%E6%AD%A3%E5%BC%8F%E8%AF%BE/%E5%91%A8%E5%95%B8%E5%A4%A9%E8%AF%BE%E4%BB%B6/JavaScript201602-master/20160512_CSS3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/PPT/%E9%99%84%E4%BB%B6/2%E3%80%81%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/1%E3%80%81%E4%BD%BF%E7%94%A8border-color%E5%88%B6%E4%BD%9C%E4%B8%89%E8%A7%92%E7%AC%A6%E5%8F%B7.html?_ijt=214ukq11e5l4bismdevhkenfhm localhost:本地文件地址 百度的服务器的外网IP：61.135.169.121 2.买一个域名（域名备案） 域名有哪些？ .cn / .com / .net / .org / .wang /.gov…… 3.将自己的项目放到服务器上 上传到服务器指定的磁盘上–&gt;FTP上传（上传工具FileZilla）4.发布项目（网站）一个服务区可以发布多个项目，每个项目各自占一个端口，每一个端口都有对应的端口号（每一个端口号都是唯一的，不能重复的），用端口号来进行区分项目–&gt;0~65535之间的任意一个数 1）发布网站的工具 IIS Apache nginx node 5.域名解析（DNS解析） 把购买的域名和服务器的IP地址关联到一起 以后只要提到域名 就关联的是这个服务器 DNS服务器：他是一台服务器 是属于全世界的万维网联盟，只要是地球上的域名解析都在他这里进行 www.baidu.com 61.135.169.121 www.jd.com 111.206.231.1 HTTP事物 请求Request阶段： 1.客户端通过域名访问，到DNS服务器上找到对应的外网IP地址 2.通过外网IP找到对应的项目服务器 3.通过端口号找到服务器上对应的项目，因为在发布项目的时候，就已经将项目文件和端口号对应了 响应response阶段： 4.服务器将客户端请求的资源文件的 源代码 返回给客户端 5.客户端（浏览器）进行解析文件 渲染页面 这两步组成了前后交互的模型/过程 “HTTP事物”–&gt;只有请求Request阶段 响应response阶段 都完成 才叫做HTTP事物 URI URI：统一资源标识符 URI=URL+URN URL：统一资源定位符 URN：统一资源名称 一个完整的URL –&gt; https://www.baidu.com:443/xxx/xxx.html?name=hh&amp;age=10#video https 传输协议 传输协议：HTTP / HTTPS / FTP 他是内容传输的媒介（快递公司） 客户端通过传输协议把一些信息传给服务器 同样 服务端也可以把一些信息返回给客户端 HTTP：超文本传输协议 除了传输文本之外 还可以传输其他的东西 比如图片 音频 视频（二进制流/base64） HTTPS:更安全的HTTP，因为他的传输通道加密了（SSL加密）（一般跟金钱 用户重要信息的网站都会采用HTTPS传输） FTP：一般都是将我们的项目文件传到服务器上，采用一些工具 例如上传工具FileZilla www.baidu.com 域名 一级域名 www.qq.com 一级域名 需要购买 ，二级域名、三级域名自己分配即可 二级域名 sport.qq.com 三级域名 kbs.sports.qq.com 443 端口号 取值范围 0-65535之间的一个数 HTTP的端口号:80 HTTPS的端口号:443 FTP的端口号:21 webstore 默认的端口号：63342 xxx/xxx.html 文件的目录–请求文件的路径和名称 表示的是在当前项目下xxx文件夹下的xxx.html /index.html 表示的是当前项目根目录下的index.html文件 ../index.html 表示的是当前项目上一级目录下的index.html文件 在不指定文件目录的时候 默认进入的是index.html（因为一般在发布项目的时候，会指定一个默认的入口文件 一般是index.html或者deflut.html） ?name=hh&amp;age=10 ?+参数 1）客户端可以通过 ?+参数 的方式给服务器传递一些信息 2）服务器不进行处理，例如之前做H5的时候 根据page=n，展示不同的区域 3）处理缓存的问题 传某个参数，但是这个参数服务器不需要 我们用它来做缓存处理 保证每次的URL都不一样 防止缓存 （例如ajax获取数据的拼接） #video 哈希值HASH 1） 客户端也可以通过这种方式给服务器传数据 （一般不用了） 2） 锚点定位 3） 通过哈希值HASH 实现页面路由的切换 6.客户端 浏览器 代码解析和页面的渲染 开发标准由W3C W3C：一个非盈利机构，他就是用来制定编程规范和标准的地方 按照浏览器的开发标准和规范开发出来的浏览器 都有一个东西叫引擎 也就是内核 我们前端工程师也要按照标准和规范去写代码 把符合标准的代码放到标准的浏览器中 通过引擎来渲染 IE内核（Trident引擎）：IE5-11，IE Edge，360，猎豹，百度 Gecko：火狐 webkit（V8引擎） 最快的 ：谷歌、Safari、QQ Presto引擎：欧朋Opera]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>网站发布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOS基本命令大全]]></title>
    <url>%2F2017%2F06%2F20%2FDOS%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[基本命令 1、列出文件 ls 参数 目录名 例: 看看驱动目录下有什么:ls /System/Library/Extensions 参数 -w 显示中文，-l 详细信息， -a 包括隐藏文件 2、转换目录 cd 例：想到驱动目录下溜达一圈 cd /System/Library/Extensions 3、建立新目录 mkdir 目录名 例：在驱动目录下建一个备份目录 backup mkdir /System/Library/Extensions/backup 在桌面上建一个备份目录 backup mkdir /User/用户名/Desktop/backup 4、拷贝文件 cp 参数 源文件 目标文件 例：想把桌面的Natit.kext 拷贝到驱动目录中 cp -R /User/用户名/Desktop/Natit.kext /System/Library/Extensions 参数R表示对目录进行递归操作，kext在图形界面下看起来是个文件，实际上是个文件夹。 把驱动目录下的所有文件备份到桌面backup cp -R /System/Library/Extensions/* /User/用户名/Desktop/backup 5、删除文件 rm 参数 文件 例：想删除驱动的缓存 rm -rf /System/Library/Extensions.kextcache rm -rf /System/Library/Extensions.mkext 参数－rf 表示递归和强制，千万要小心使用，如果执行了 rm -rf / 你的系统就全没了 6、移动文件 mv 文件 例：想把AppleHDA.Kext 移到桌面 mv /System/Library/Extensions/AppleHDA.kext /User/用户名/Desktop 想把AppleHDA.Kext 移到备份目录中 mv /System/Library/Extensions/AppleHDA.kext /System/Library/Extensions/backup 7、文本编辑 nano 文件名 例：编辑natit Info.plist nano /System/Library/Extensions/Natit.kext/Info.plist 目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la 文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename 选择操作 命令名 功能描述 使用举例 head 显示文件的最初几行 head -20 filename tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 diff 比较并显示两个文件的差异 diff file1 file2 sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142 时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.NET.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftpftp.sp.net.edu.cn rcp 在本地主机与远程主机 之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的 几条命令及编号 history r 重复执行最近执行过的 某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir df /tmp 显示文件系统的总空间和可用空间 w 显示当前系统活动的总信息]]></content>
      <categories>
        <category>前端常识</category>
      </categories>
      <tags>
        <tag>DOS命令</tag>
        <tag>DOS命令大全</tag>
        <tag>前端常识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas动态案例]]></title>
    <url>%2F2017%2F06%2F09%2Fcanvas%E5%8A%A8%E6%80%81%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Canvas动态案例 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;draw&quot; width=&quot;220&quot; height=&quot;320&quot; style=&quot;background-color: skyblue&quot;&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); var img=new Image; img.src=&apos;walkingdead.png&apos;;//添加图片地址 img.onload=function()&#123;//图片上有10张小图横着排列 var width=this.width/10; var height=this.height; var i=0; window.setInterval(function()&#123; cvs.clearRect(0,0,draw.width,draw.height);//清除上一个图片 cvs.drawImage(img,i*width,0,width,height,0,0,width,height); if(i==9)&#123; i=0 &#125;else&#123;i++;&#125; &#125;,200); &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>canvas动态案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas之8图形组合]]></title>
    <url>%2F2017%2F06%2F09%2Fcanvas%E4%B9%8B8%E5%9B%BE%E5%BD%A2%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[图形组合 cvs.globalCompositeOperation=type; type的值: 1.source-over 默认值 覆盖 在原来的图形上绘制新图 新图在上 2.source-out 显示新图的非交集部分 3.source-in 显示新图和图形的交集，颜色是新图的颜色 4.source-atop 显示旧图和交集部分 交集是新图颜色 5.destination-over 在原来图形的下面绘制新图 旧图在上 6.destination-out 显示旧图的非交集部分 7.destination-in 显示交集 颜色是旧图颜色 8.destination-atop 显示新图和交集部分 交集是旧图颜色 9.lighter:全部显示 交集部分是叠加颜色 10.xor:显示新旧图的非交集部分 11.copy 只显示新图 案例1:在原来的图形上绘制新图 新图在上12345678910var draw=document.getElementById(&apos;draw&apos;);var cvs=draw.getContext(&apos;2d&apos;);function draw1()&#123; cvs.fillStyle=&apos;gold&apos;; cvs.fillRect(10,10,100,100); cvs.globalCompositeOperation=&apos;source-over&apos;; cvs.fillStyle=&apos;pink&apos;; cvs.fillRect(50,50,100,100);&#125;draw1();]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>canvas图形组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas之7变形]]></title>
    <url>%2F2017%2F06%2F09%2Fcanvas%E4%B9%8B7%E5%8F%98%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[平移translate(x,y);x:坐标原点向x轴平移的距离y:坐标原点向y轴平移的距离 案例 1234567891011121314function draw1()&#123; cvs.fillStyle=&apos;skyblue&apos;; //设置填充颜色天空蓝 cvs.fillRect(0,0,200,100); //矩形左上角坐标0,0 宽200px 高100px cvs.translate(50,50); //设置平移 坐标原点向x轴(向右)平移50px 坐标原点向y轴(向下)偏移50px //--&gt;这个平移只会对后面的矩形造成影响 不会影响前面的 cvs.fillStyle=&apos;pink&apos;; //设置填充颜色粉色 cvs.fillRect(0,0,180,80); //矩形左上角坐标0,0 宽180px 高80px&#125;draw1(); 缩放 vas.scale(x0,y0);x0:x轴按照x0的比例缩放y0:y轴按照x0的比例缩放 案例 12345678function draw2()&#123; cvs.scale(1,2);//设置缩放 x轴不变 y轴是之前的2倍 cvs.fillStyle=&apos;plum&apos;;//设置填充样式为颜色填充 cvs.fillRect(0,0,200,100); //矩形左上角坐标0,0 宽200px 高100px //--&gt;那么转化后的矩形宽200px 高200px&#125;draw2(); 3.旋转 vas.rotate(angle); angle:坐标轴转的角度 他是一个弧度(和画圆的计算是一样的) 案例 123456function draw3()&#123; cvs.rotate(Math.PI/4);//设置旋转 旋转角度为45度 cvs.fillStyle=&apos;lightblue&apos;; cvs.fillRect(100,100,200,100);&#125;draw3(); 注意：平移、缩放、旋转都是对原始坐标（画布）操作的 例如:1234567function draw3()&#123; cvs.translate(200,0);//此时的原点已经变到200,0的位置 cvs.rotate(Math.PI/4);//设置旋转 旋转角度为45度 cvs.fillStyle=&apos;lightblue&apos;; cvs.fillRect(100,100,200,100);&#125;draw3();]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>canvas变形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas之6绘制图片]]></title>
    <url>%2F2017%2F06%2F09%2Fcanvas%E4%B9%8B6%E7%BB%98%E5%88%B6%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[绘图 cvs.drawImage(Image,x,y,w,h); Image 就是可以放在DOM中的真实图片，可以动态创建，也可以获取页面上的 x,y 图片放入画布,在画布左上角的坐标 w,h 绘制图片的宽高 案例:将图片放在画布上 123456789function draw1()&#123; var img=new Image;//动态创建一个img img.src=&apos;default.gif&apos;;//添加图片链接 img.onload=function()&#123;//如果图片地址真实存在 执行这个函数 cvs.drawImage(this,0,100,100,90); //将图片放在画布上 图片左上角的坐标0,100 图片宽100px 高90px &#125;&#125;draw1(); cvs.drawImage(img_elem,sx,sy,sw,sh,dx,dy,dw,dh); sx,sy 图片左上角的坐标 sw,sh 矩形区域的宽高 用来截取图片 dx,dy 截取出来放在画布canvas上的坐标 dw,dh 画在canvas上的宽高 总结: sw,sy,sx,sy 是用来截取图片的过程 dx,dy,dw,dh 把截取出来的图片放在canvas上的过程 案例:截取图片 123456789 function draw2()&#123; var img=new Image;//动态创建一个img img.src=&apos;1.jpg&apos;;//添加图片链接 img.onload=function()&#123;//如果图片地址真实存在 执行这个函数 cvs.drawImage(this,480,150,440,410,0,0,200,200); //this就是img 将图片放在画布上 需要截取的图片在原图片左上角的坐标480,150 截取图片的大小为440px*410px 截取出来的图片放入画布的坐标0,0 截取出来的图片画在画布canvas的宽200px 高200px &#125; &#125;// draw2(); 设置平铺 cvs.creatPattern(image,type) Image 就是可以放在DOM中的真实图片，可以动态创建，也可以获取页面上的 type: no-repeat 不平铺 repeat 全方向平铺 repeat-x x轴方向平铺 repeat-y y轴方向平铺 案例 123456789101112function draw3()&#123; var img=new Image; img.src=&apos;default.gif&apos;; img.onload=function()&#123; var rep=cvs.createPattern(this,&apos;repeat&apos;);//设置图片平铺 cvs.fillStyle=rep;//设置填充样式为图片平铺 cvs.fillRect(0,0,draw.width,draw.height); //draw.width画布的宽 draw.height画布的高 //设置填充矩形 矩形左上角坐标0,0 矩形的宽为画布的宽 矩形的高为画布的高 &#125;&#125;//draw3();]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>canvas绘制图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas之4渐变]]></title>
    <url>%2F2017%2F06%2F09%2Fcanvas%E4%B9%8B4%E6%B8%90%E5%8F%98%2F</url>
    <content type="text"><![CDATA[1.线性渐变 var CLG=cvs.createLinearGradient(x0,y0,x1,y1); x0:渐变开始的x坐标 y0:渐变开始的y坐标 x1:渐变结束的x坐标 y1:渐变结束的y坐标 CLG.addColorStop(n,m); n:设置颜色的偏移量 m:颜色 例如: 12345678910111213function draw1()&#123; var CLG=cvs.createLinearGradient(0,0,200,200); //创建一个线性渐变 渐变开始的坐标0,0 渐变结束的坐标200,200 (即从左上角到右下角渐变) CLG.addColorStop(0,&apos;red&apos;);//设置渐变的偏移量0% 颜色红色 CLG.addColorStop(0.25,&apos;yellow&apos;);//设置渐变的偏移量25% 颜色黄色 CLG.addColorStop(0.5,&apos;skyblue&apos;);//设置渐变的偏移量50% 颜色天空蓝 CLG.addColorStop(0.75,&apos;orange&apos;);//设置渐变的偏移量75% 颜色橘黄 CLG.addColorStop(1,&apos;pink&apos;);//设置渐变的偏移量100% 颜色粉色 cvs.fillStyle=CLG;//设置填充样式是线性渐变 cvs.fillRect(0,0,200,200);//设置填充矩形 左上角坐标0,0 宽200px 高200px cvs.fill();//设置样式为填充样式&#125;draw1(); 2.径向渐变(发散性渐变) cvs.createRadialGradient(x0,y0,x1,y1,r1); x0:发散渐变开始中心的x坐标 y0：发散渐变开始中心的y坐标 r0:发散渐变开始的半径 x1:发散渐变结束中心的x坐标 y1：发散渐变结束中心的y坐标 r1:发散渐变结束的半径 例如:1234567891011121314function draw2()&#123; var CRG=cvs.createRadialGradient(200,200,200,200,200,10); //创建一个径向/发散性渐变 渐变开始的坐标200,200 渐变开始的半径200px 渐变结束的坐标200,200 渐变结束的半径10px CRG.addColorStop(0,&apos;purple&apos;); CRG.addColorStop(0.2,&apos;yellow&apos;); CRG.addColorStop(0.4,&apos;pink&apos;); CRG.addColorStop(0.6,&apos;lightblue&apos;); CRG.addColorStop(0.8,&apos;skyblue&apos;); CRG.addColorStop(1,&apos;white&apos;); cvs.fillStyle=CRG;//设置填充样式是径向渐变 cvs.fillRect(100,100,200,200); //设置填充矩形 左上角坐标100,100 宽200px 高200px&#125;draw2();]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>canvas渐变</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas之3绘制矩形]]></title>
    <url>%2F2017%2F06%2F09%2Fcanvas%E4%B9%8B3%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[cvs.fillRect(x,y,w,h); –&gt; 填充矩形 x,y 是这个矩形左上角的坐标 w,h 是这个矩形的宽高 cvs.strokeRect(x,y,w,h); –&gt; 带边框的矩形 x,y 是这个矩形左上角的坐标 w,h 是这个矩形的宽高 注意:如果设置边框 边框一半在里面一半在外面 cvs.clearRect(x,y,w,h); –&gt; 清除填充图的某一部分，清除的还是一个矩形 x,y 是这个矩形左上角的坐标 w,h 是这个矩形的宽高案例 案例1 12345678910function draw1()&#123; //填充矩形 cvs.fillStyle=&apos;#fccdda&apos;;//画之前填充颜色 cvs.fillRect(10,20,100,50);//设置填充矩形,矩形的左上角坐标为10,20 宽100px 高50px //边框矩形 cvs.strokeStyle=&apos;red&apos;;//设置边框的矩形边框颜色 cvs.lineWidth=20;//设置边框宽度20px cvs.strokeRect(150,20,100,50);//设置边框矩形， 矩形的左上角坐标为150,20 宽100px 高50px&#125;draw1(); 案例2 12345678910111213function draw2()&#123;//清除填充图的某一部分，清除的还是一个矩形cvs.clearRect(x,y,w,h) cvs.fillStyle=&apos;orange&apos;; //画之前填充颜色 cvs.fillRect(20,100,300,100); //设置填充矩形,矩形左上角坐标为20,100 宽300px 高100px cvs.clearRect(140,140,60,60); //清除填充图的矩形 清除的这个矩形左上角坐标140,140 宽60px 高60px cvs.clearRect(20,100,40,40); //清除填充图的矩形 清除的这个矩形左上角坐标20,100 宽40px 高40px cvs.clearRect(280,100,40,40); //清除填充图的矩形 清除的这个矩形左上角坐标280,100 宽40px 高40px&#125;draw2();]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas绘制矩形</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas之5绘制文本]]></title>
    <url>%2F2017%2F06%2F09%2Fcanvas%E4%B9%8B5%E7%BB%98%E5%88%B6%E6%96%87%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[1.阴影 cvs.shadowOffsetX//阴影的横向偏移量，默认值是0 cvs.shadowOffsetY//阴影的纵向偏移量，默认值是0 cvs.shadowColor//阴影的颜色 cvs.shadowBlur//阴影的模糊范围（值越大越模糊） 案例 123456789function draw1()&#123; cvs.shadowColor=&apos;#000fff&apos;;//设置阴影颜色 cvs.shadowOffsetX=30;//设置阴影的横向偏移量30px cvs.shadowOffsetY=20;//设置阴影的纵向偏移量20px cvs.shadowBlur=20;//设置阴影的模糊范围20px cvs.fillStyle=&apos;#449fdb&apos;;//设置填充的样式为颜色填充 cvs.fillRect(50,50,100,100);//设置填充矩形 左上角坐标50,50 宽100px 高100px&#125;draw1(); 2.绘制文本 设置字体样式 cvs.font=’字体大小font-size 字体样式font-family’ 水平对齐方式 cvs.textAlign(start,end,right,center); 垂直对齐方式 cvs.textBaseline=’’ 属性值:top,middle,hangle,bottom,alphabetic,ideographic 计算文本长度 var text=’dfbzbh’ console.log(cvs.measureText(text));//width:40.453125 填充文字 cvs.fillText(text,x,y,maxWidth); 1) text:文本内容 2) x:文字起始点的横坐标 3) y:文字起始点的纵坐标 绘制文字轮廓 cvs.strokeText(text,x,y,maxWidth); 1) text:文本内容 2) x:文字起始点的横坐标 3) y:文字起始点的纵坐标 案例1 12345678910function draw1()&#123; cvs.shadowColor=&apos;#000fff&apos;;//设置阴影颜色 cvs.shadowOffsetX=30;//设置阴影的横向偏移量30px cvs.shadowOffsetY=20;//设置阴影的纵向偏移量20px cvs.shadowBlur=20;//设置阴影的模糊范围20px cvs.fillStyle=&apos;#449fdb&apos;;//设置填充的样式为颜色填充 cvs.fillRect(50,50,100,100); //设置填充矩形 左上角坐标50,50 宽100px 高100px &#125; draw1(); 案例2 1234567891011121314151617function draw2()&#123; var text=&apos;hellow word&apos;;//设置文本内容 cvs.fillStyle=&apos;yellow&apos;;//设置填充样式颜色 cvs.font=&apos;40px verdana&apos;;//设置字体样式 cvs.textAlign=&apos;start&apos;;//设置字体的水平对齐方式 cvs.textBaseline=&apos;top&apos;;//设置字体的垂直对齐方式 cvs.fillText(text,10,10); //设置填充文字 文本内容text 文本起始点坐标10,10 var length=cvs.measureText(text); //获取文本宽度(长度)length console.dir(length); //TextMetrics--&gt;width:241.171875 //==&gt;length.width字体的宽度 cvs.fillText(&quot;字体长度为&quot;+length.width,10,60); //设置填充文字(通过字符串拼接方式) 文本起始点坐标10,60&#125;draw2(); 案例3:文本线性渐变 123456789101112131415161718192021222324function draw3()&#123; var CLG=cvs.createLinearGradient(0,0,300,100); //创建一个线性渐变 渐变开始的坐标0,0 渐变结束的坐标300,100 CLG.addColorStop(0,&apos;skyblue&apos;);//设置渐变的偏移量0% 天空蓝 CLG.addColorStop(0.25,&apos;plum&apos;);//设置渐变的偏移量25% 紫色 CLG.addColorStop(0.5,&apos;lightblue&apos;);//设置渐变的偏移量50% 蓝 CLG.addColorStop(0.75,&apos;skyblue&apos;);//设置渐变的偏移量75% 天空蓝 CLG.addColorStop(1,&apos;plum&apos;);//设置渐变的偏移量100% 紫色 var text=&apos;hellow word&apos;;//设置文本内容 cvs.fillStyle=CLG;//设置填充样式是线性渐变 cvs.shadowOffsetX=5;//设置阴影的横向偏移量5px cvs.shadowOffsetY=4;//设置阴影的纵向偏移量4px cvs.shadowColor=&apos;#ffb6c1&apos;;//设置阴影的颜色 cvs.shadowBlur=5;//设置阴影的模糊度 cvs.font=&apos;40px cursive&apos;;//设置字体样式 cvs.textAlign=&apos;top&apos;;//设置字体的水平对齐方式 cvs.fillText(text,50,150); //设置填充文字text 文本起始点坐标50,150 var width=cvs.measureText(text).width;//获取文本宽度(长度)length cvs.fillText(&quot;字体长度为：&quot;+width,10,200); //设置填充文字(通过字符串拼接方式) 文本起始点坐标10,200 &#125; draw3(); 案例4:文本径向渐变 123456789101112131415161718function draw4()&#123; var CRG=cvs.createLinearGradient(0,0,600,0,0,20); //创建一个径向渐变 渐变开始的坐标0,0 开始渐变的半径600px 渐变结束的坐标0,0 渐变结束的半径20px CRG.addColorStop(0,&apos;pink&apos;); CRG.addColorStop(0.25,&apos;skyblue&apos;); CRG.addColorStop(0.5,&apos;yellow&apos;); CRG.addColorStop(0.75,&apos;plum&apos;); CRG.addColorStop(1,&apos;skyblue&apos;); var text=&apos;I WANT EAT&apos;; cvs.fillStyle=CRG;//设置填充样式是径向渐变 cvs.font=&apos;80px simsun&apos;;//设置字体样式 cvs.textAlign=&apos;start&apos;;//设置文本横向对齐方式 cvs.textBaseline=&apos;top&apos;;//设置文本纵向对齐方式 cvs.shadowColor=&apos;lightblue&apos;;//设置阴影颜色 cvs.shadowBlur=10;//设置阴影的模糊范围10px cvs.fillText(text,10,10);//设置填充文字text 文本起始点坐标10,10&#125;draw4();]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>canvas绘制文本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器及相关知识]]></title>
    <url>%2F2017%2F06%2F09%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[服务器 是具有储存功能的计算机设备（笔记本电脑本身就是一个服务器） 服务器根据功能分类： web服务器：供用户访问的 安全系数相对较低 数据库服务器：放在内网的服务器，用来安装数据库 应用服务器：放在内网的服务器，用来安装应用（产品） 操作系统有关 可视操作：可以直观看到所有文件，可以直接操作这些文件（window） 不可视操作：不能直观看到所有文件，需要ssh，ftp这样的工具进行连接（或者是敲命令进行） 大型机与嵌入式系统使用很多样化的操作系统。 在服务器方面Linux、UNIX和WindowsServer占据了市场的大部分份额。在超级计算机方面，Linux取代Unix成为了第一大操作系统，截止2012年6月，世界超级计算机500强排名中基于Linux的超级计算机占据了462个席位，比率高达92%。随着智能手机的发展，Android和iOS已经成为目前最流行的两大手机操作系统。 内外网： 内网：数据库 ，产品应用——可供用户观看的页面 外网：web服务器，web服务器（多个相同的web服务器，负载均衡）——可供用户访问的 vpn(翻墙软件)负载均衡：内外网的连接工具]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas之2画圆]]></title>
    <url>%2F2017%2F06%2F08%2Fcanvas%E4%B9%8B2%E7%94%BB%E5%9C%86%2F</url>
    <content type="text"><![CDATA[cvs.arc(x,y,radius,startAngle,endAngle,anticlokwise); x,y 圆心坐标 radius半径r startAngle 起始角 以弧度计算(钟表的3点钟方向是0度,也就是x轴的正方向是0度,默认是顺时针) endAngle 结束角 anticlokwise 是否逆时针 默认值false false表示顺时针 案例 案例1:边框半圆 123456789function draw1()&#123;//边框圆 cvs.strokeStyle=&apos;#ffa50&apos;;//设置笔触样式(边框样式)颜色 cvs.beginPath();//开始一个路径 cvs.arc(500,500,100,0,Math.PI);//圆心坐标是500,500，半径是100px，起始角为0度，结束角为180度 cvs.closePath();//结束路径 cvs.lineWidth=10;//边框宽度为10px cvs.stroke();//绘制图形以边框样式绘制&#125;draw1(); 案例2:同心圆 12345678910111213141516171819202122function draw2()&#123; cvs.fillStyle=&apos;orange&apos;; cvs.beginPath(); //开始一个新的路径 cvs.arc(200,200,60,Math.PI/2,2*Math.PI); //圆心坐标是(200,200),半径为60px,起始角为90度,结束角为360度 cvs.closePath(); //结束一个路径 cvs.fill(); //绘制图形以填充样式绘制 cvs.strokeStyle=&apos;yellow&apos;; //设置 笔触样式(边框样式) 为黄色 cvs.lineWidth=40; //边框的宽度为40px cvs.beginPath(); //开始一个新的路径 cvs.arc(200,200,80,0,2*Math.PI); //圆心坐标是(200,200),半径为80px,起始角度为0度,结束角度为360度 cvs.closePath();//结束一个路径 cvs.stroke();//绘制图形以边框样式绘制&#125;draw2(); 案例3:每次调用fill绘制填充图的时候，会把当次路径的起始点和结束点分别连接，填充闭合部分(如果想让每个路径互不干扰 一定要记得写结束路径–&gt;关闭路径) 12345678910111213function draw3()&#123; cvs.strokeStyle=&apos;pink&apos;;//设置笔触样式(边框样式)颜色为粉色 cvs.beginPath();//开始一个路径 cvs.lineWidth=2;//边框的宽度为2px cvs.arc(100,100,100,0,Math.PI);//圆心坐标是100,100,半径为100,起始角度为0度,结束角度为180度 cvs.closePath();//结束一个路径 cvs.stroke();//绘制图形以边框样式绘制 cvs.fillStyle=&apos;gray&apos;;//设置填充颜色为灰色 cvs.arc(300,300,80,0,Math.PI/2);//圆心坐标是300,300，半径是80px，起始角度为0，结束角度为90度 cvs.closePath(); cvs.fill();&#125;draw3();]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>canvas画圆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas之1绘制线条的有关属性和步骤]]></title>
    <url>%2F2017%2F06%2F08%2Fcanvas%E4%B9%8B1%E7%BB%98%E5%88%B6%E7%BA%BF%E6%9D%A1%E7%9A%84%E6%9C%89%E5%85%B3%E5%B1%9E%E6%80%A7%E5%92%8C%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[&lt;canvas id=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt;&lt;/canvas&gt;canvas :H5标签 在页面上绘制图形用的（通常称他画布）canvas只是一个容器，我们用js脚本来控制他&lt;canvas id=&quot;draw&quot; width=&quot;600&quot; height=&quot;500&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; 绘制线条的有关属性和步骤 1.相关属性 1.填充的样式 cvs.fillStyle --&gt;fillStyle`填充样式 cvs.strokeStyle --&gt;strokeStyle笔触样式 主要用来画边框的 cvs.lineWidth --&gt; 边框的宽度 2.绘制图形有两种方式 cvs.fill(); --&gt; 填充样式 cvs.stroke(); --&gt; 边框样式 3.颜色值的四种书写方式 1).颜色名 –&gt;”red” 2).十六进制 –&gt;”#fff” 3).三色值 –&gt;rgb(0,0,0) 4).四色值 –&gt;rgba(0,0,0,0.3) 4.坐标: 1.)以画布为基准,距离画布的上边是y坐标值(top值),距离画布的左边是x坐标值(left值); cvs.moveTo(x,y); –&gt; 起始点坐标 cvs.lineTo(x,y); –&gt; 结束点的坐标 如果没有moveTo就把上一个挨着的lineTo作为起始坐标 例如:假如第一个不是moveTo而是lineTo,那么lineTo就是其实坐标 5.开始和关闭一个路径 cvs.beginPath(); –&gt; 开始一个新的路径 cvs.closePath(); –&gt; 关闭当前路径 注意:加上.closePath会自动闭合 会自动连接起始坐标和结束坐标 6.canvas中的圆角 1).设置线条交汇处的样式 cvs.lineJoin 他有三个属性： 1).尖角miter 2).斜角bevel 3).圆角round 2).设置一条线段两端点的样式 lineCap焦点样式 1)平的butt(默认值) 2.)圆角round 3.)方角square 2.步骤及案例 步骤1.获取出canvas标签,例如:var draw=document.getElementById(&#39;draw&#39;); 步骤2.设置绘制环境–2d 平面图,例如: 12var cvs=draw.getContext(&apos;2d&apos;);//cvs 这个就是你的画板 接下来就可以在cvs上进行绘制 步骤3 案例1:线段 123456789101112function draw1()&#123;var draw=document.getElementById(&apos;draw&apos;);var cvs=draw.getContext(&apos;2d&apos;);cvs.beginPath();cvs.moveTo(50,50);cvs.lineTo(150,50);cvs.closePath();cvs.strokeStyle=&apos;#800080&apos;;cvs.lineWidth=5;cvs.stroke();//以边框的形式显示&#125;draw1(); 案例2:等腰直角三角形 12345678910111213function draw2()&#123; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); cvs.beginPath(); cvs.lineTo(80,120); cvs.lineTo(80,240); cvs.lineTo(200,240); cvs.closePath(); cvs.strokeStyle=&apos;ec568c&apos;; cvs.lineWidth=10; cvs.stroke();&#125;draw2(); 案例3:圆角矩形 12345678910111213function draw3()&#123; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); cvs.beginPath(); cvs.lineCap=&apos;round&apos;; cvs.lineTo(50,50); cvs.lineTo(250,50); cvs.closePath();//关闭就没有圆角效果 cvs.lineWidth=100; cvs.strokeStyle=&apos;#896446&apos;; cvs.stroke();&#125;draw3(); 案例4:圆角三角形 1234567891011121314function draw4()&#123; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); cvs.beginPath(); cvs.lineJoin=&apos;round&apos;;//设置圆角 cvs.moveTo(200,100); cvs.lineTo(100,250); cvs.lineTo(300,250); cvs.closePath(); cvs.lineWidth=50; cvs.strokeStyle=&apos;#896446&apos;; cvs.stroke();&#125;draw4();]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>canvas绘制线条</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串中的几个重要方法]]></title>
    <url>%2F2017%2F06%2F02%2FJS%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.通过索引查找字符串1) charAt(索引) 字符串上的charAt方法里边传索引值，进行搜索指定索引位置的字符，还是字符串格式;原字符串不变2) charCodeAt（索引） 返回结果对应的是ASCII码;原字符串不变例如:12345var str = &apos;addias&apos;;console.log(str.charAt(0),str);//&quot;a&quot; &quot;addias&quot; 原字符串不变console.log(str.charCodeAt(0),str);//97 &quot;addias&quot; 原字符串不变 2.检取字符串 substr(n,m); 从索引n开始截取m个 返回值为截取的字符串 原有字符串不变12var str = &apos;addias&apos;;console.log(str.substr(1, 2),str);//&quot;dd&quot; &quot;addias&quot; 1). str.substr();// 复制字符串 2). str.substr(0);// 复制字符串12345var str = &apos;addias&apos;;console.log(str.substr(),str);//&quot;addias&quot; &quot;addias&quot; 复制字符串console.log(str.substr(0),str);//&quot;addias&quot; &quot;addias&quot; 复制字符串 subString(n,m) 从索引n找到索引m之前，不包含m处;原字符串不变123var str = &apos;addias&apos;;console.log(str.substring(3, 4),str);//&quot;i&quot; &quot;addias&quot; substring(0); 克隆字符串 substring(); 克隆字符串12345var str = &apos;addias&apos;;console.log(str.substring(0),str);//&quot;addias&quot; &quot;addias&quot;console.log(str.substring(),str);//&quot;addias&quot; &quot;addias&quot; slice 字符串也可以使用slice1234var str = &apos;addias&apos;;console.log(str.slice(-1+str.length));//sconsole.log(str.slice(-1)); //s 同数组的使用方法一样console.log(str.slice(-2)); //as 同数组的使用方法一样 4.indexOf();字符串中当前字符出现的第一个索引;lastIndexOf();字符串中当前字符出现的最后一个索引;123var str = &apos;addias&apos;;console.log(str.indexOf(&apos;f&apos;));//-1console.log(str.lastIndexOf(&apos;a&apos;));//4 5.toUpperCase();字符串转化成大写;toLowerCase();字符串转化成小写123456var str = &apos;addias&apos;;console.log(str.toUpperCase(), str);// &quot;ADDIAS&quot; &quot;addias&quot; 字符串转化成大写var str = &apos;ADDIAS&apos;;console.log(str.toLowerCase(), str);//&quot;addias&quot; &quot;ADDIAS&quot; 字符串转化成小写 6.replace 替换字符串中的字符;原字符串不变1234var str1 = &apos;珠,峰,珠,训&apos;;var str2 = &apos;sdasdasdasdasd&apos;;console.log(str1.replace(&apos;珠&apos;, &apos;zhu&apos;), str1);//&quot;zhu,峰,珠,训&quot; &quot;珠,峰,珠,训&quot; 6.split 将字符串拆分成数组;将字符串以字符串中存在的指定分隔符拆分成数组12345678910var str1 = &apos;珠,峰,珠,训&apos;;var str2 = &apos;sdasdasdasdasd&apos;;console.log(str2.split(&apos;a&apos;));//(5) [&quot;sd&quot;, &quot;sd&quot;, &quot;sd&quot;, &quot;sd&quot;, &quot;sd&quot;]console.log(str2.split());//[&quot;sdasdasdasdasd&quot;]console.log(str1.split(&apos;,&apos;));//[&quot;珠&quot;, &quot;峰&quot;, &quot;珠&quot;, &quot;训&quot;]console.log(str1.split(&apos;&apos;));//[&quot;珠&quot;, &quot;,&quot;, &quot;峰&quot;, &quot;,&quot;, &quot;珠&quot;, &quot;,&quot;, &quot;训&quot;]]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>charAt</tag>
        <tag>charCodeAt</tag>
        <tag>substr</tag>
        <tag>subString</tag>
        <tag>slice</tag>
        <tag>indexOf</tag>
        <tag>lastIndexOf</tag>
        <tag>toUpperCase</tag>
        <tag>toLowerCase</tag>
        <tag>replace</tag>
        <tag>split</tag>
        <tag>字符串中的方法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的作用域]]></title>
    <url>%2F2017%2F04%2F29%2FJS%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[内存1.堆内存：来存储东西的，一般来存储引用数据类型2.栈内存：代码执行空间，作用域 作用域两种：全局作用域：一打开浏览器就会形成私有作用域：函数执行形成的作用域函数执行的时候1.函数一执行，形成一个私有作用域2.有形参数的话给形参数赋值，相当于var 一个变量，function s(a){},s(1)-&gt;var a=1;3.预解释4.代码执行私有变量：1.形参2.在私有作用域中声明的变量，var过和function过得记住：私有变量只能私有作用域自己使用，别人获取不到 闭包：函数执行的时候形参一个私有作用域，来保护里面的私有变量不受外界干扰，这种机制叫做闭包]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>js作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的预解释]]></title>
    <url>%2F2017%2F04%2F29%2FJS%E4%B8%AD%E7%9A%84%E9%A2%84%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[预解释的基础知识 例子 1234567console.log(d);//--&gt;function d()&#123;&#125;;d=1;//--&gt;d=1s=d;//--&gt;s=1function d()&#123;//--&gt;xxxfff000&#125;d();//--&gt;d is not a function 1.预解释: 是一个过程，作用域形成之后，代码执行之前，把所有带var关键字和function提前声明或定义 2.作用域： 1). 全局作用域：window下，一打开浏览器就会形成 2). 私有作用域：一个函数就是一个私有作用域，函数一执行就会形成私有作用域 3.声明: 告诉浏览器这里有个变量，var关键字的只有声明 4.定义: 赋值过程，在预解释的时候function即声明还定义 5.注意: 预解释的时候遇到变量已经声明过了就不用声明了，但是需要重新定义,例如:1234567891011//变量只声明未定义就是undefinedconsole.log(obj1);//--&gt;undefinedvar obj1=&#123;name:&quot;111&quot;&#125;;console.log(fn);function fn() &#123;&#125;//1.全局作用形成//2.全局作用域下的预解释：var obj1，function fn=xxxfff000//3.代码执行：// 1.console.log(obj1);--&gt;undefined// 2.obj1=xxxfff111// 3. console.log(fn);--&gt;function fn() &#123;&#125; 预解释的几种特殊情况 注意: 全局作用域下的变量就是window的一个属性 1.=右边函数不进行预解释（函数作为值的时候\绑定事件的时候 不进行预解释）123var ff=function () &#123; console.log(1);&#125;; 2.return 后面的代码不行行但是需要预解释，return出的内容执行但是不进行预解释123456789101112function fn() &#123; var a=0; console.log(f);//function f()&#123;&#125; return function () &#123; console.log(1); return 1 &#125;; function f() &#123;&#125;&#125;var d=fn();console.log(d());fn()(); 3.在条件语句中 1)不管条件是否成立都进行预解释 1234567console.log(num);if (0)&#123; //虽然条件不成立 但是需要预解释 var num=0&#125;ss=0;//-&gt;window.ss=0console.log(&quot;ss&quot; in window); 2)条件中有函数function 在条件中的var和function只声明不定义，声明的时候当遇到变量已经被声明了，就会报错 1234if(&apos;a&apos; in window)&#123;var a=1;function()&#123;&#125;;//--&gt;&apos;a&apos; has already been declared&#125; 条件一旦成立，首先给函数赋值 123456789101112console.log(a);if (&quot;a&quot; in window)&#123; console.log(a); a=1; function a() &#123;&#125; console.log(a);&#125;//预解释：function a --&gt;就相当于给window增加一个“a”属性//&quot;a&quot; in window 就是true//条件成立第一步先给function a赋值=xxxfff000//代码执行：console.log(a);xxxfff000-&gt;function a() &#123;&#125;// a=1,重新给a赋值 4.自执行函数 不进行预解释1234//console.log(sss);(function sss() &#123; console.log(&quot;a&quot;)&#125;)(); 5.函数作为参数的时候不进行预解释123[1,2,3].sort(function(a,b)&#123;return a-b;&#125;); 6.预解释的时候遇到已经声明过得变量不需要声明了，但是需要定义12345678var s1=1;function s1() &#123;//s1=xxxfff000 console.log(&quot;s1&quot;)&#125;function s1() &#123;//s1=xxxfff111 console.log(&quot;s11&quot;)&#125;console.log(s1);]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>预解释</tag>
        <tag>js预解释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义属性和引用数据类型的赋值]]></title>
    <url>%2F2017%2F04%2F29%2FJS%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[自定义属性:- 一般都是给某些元素增加一个自己起的属性名（不能是内置属性），来存储一些值的比如说我们在选项卡中用自定义属性来存储他的索引值，不用全局变量的好处：只有自己可以修改 元素.自定义属性名=值 只要是引用数据类型都可以加自定义属性 特别注意：函数也可以加 对于引用数据类型: 对象: 浏览器先看是什么数据类型的，是对象的话，浏览器给对象开辟一个堆内存 把所有的键值对（属性名：属性值）放到这个堆内存里，如果属性值遇到变量名，是把变量代表的值存起来 把这个地址赋给对象 函数 浏览器检测他是什么数据类型，是函数的话就给他开辟一个堆内存 将函数当做字符串存起来 将地址赋给函数名]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>自定义属性</tag>
        <tag>引用数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于GitHub创建自己HEXO的博客]]></title>
    <url>%2F2017%2F04%2F25%2F%E5%9F%BA%E4%BA%8EGitHub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84HEXO%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建环境准备 Node.js 的安装和准备 Git的安装和准备 gitHub账户的配置 Node.js 的安装和准备 1.下载node.js安装文件：https://nodejs.org/en/ 2.cmd，打开命令行界面,查看安装版本 12node -vnpm -v 配置Git环境 下载Git安装文件：https://git-scm.com/downloads 打开命令行输入,检查安装是否成功 1git --version github账户的注册和配置 Github注册：https://github.com/ 创建代码库： 在Repository name下填写yourname.github.io，Description (optional)下填写一些简单的描述（不写也没有关系 123注意：比如我的github名称是gaodaxiu0406 ,这里你就填 gaodaxiu0406.github.io 代码库设置:Setting 接下来开启gh-pages功能，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages 点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面 安装Hexo 首先在E盘(选择你的HEXO存放的文件夹,最好不要安装到C盘)目录下创建Hexo文件夹，并在命令行的窗口进入到该目录 12E: 进入E盘cd Hexo 进入Hexo文件夹 安装HEXO 1npm install hexo-cli -g 可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。 检查安装是否成功1hexo -v hexo的相关配置初始化Hexo12hexo initnpm install 首次体验Hexo12hexo g #生成hexo s #启动服务 在浏览器中打开http://localhost:4000/ 即可预览你的HEXO页面 怎样将Hexo与github page 联系起来大概分为以下几步: 配置git个人信息 配置Deployment 配置Git个人信息 1.设置Git的user name和email：(如果是第一次的话) 12git config --global user.name &quot;gaodaxiu0406&quot;git config --global user.email &quot;1260833716@qq.com&quot; 2.检查是否已经有SSH Key(密钥)。 12cd ~/.sshls 3.生成密钥(如果没有密钥的话) 1ssh-keygen -t rsa -C &quot;1260833716@qq.com&quot; 123连续3个回车。如果不需要密码的话。最后得到了两个文件：id_rsa和id_rsa.pub。默认的存储路径是：C:\Users\Administrator\.ssh 4.添加密钥到ssh-agent 1eval &quot;$(ssh-agent -s)&quot; 添加生成的 SSH key 到 ssh-agent。 1ssh-add ~/.ssh/id_rsa 5.登陆Github, 添加 ssh 把id_rsa.pub文件里的内容复制到SSH keys 6.测试： 1ssh -T git@github.com 你将会看到：如果看到Hi后面是你的用户名，就说明成功了。 1如果提示Are you sure you want to continue connecting (yes/no)?，输入yes 配置Deployment 配置_config.yml中有关deploy的部分： 1234deploy:type: gitrepository: git@github.com:gaodaxiu0406/gaodaxiu0406.github.io.gitbranch: master 写博客、发布文章 1.定位到我们的hexo根目录，执行命令： 1hexo new &apos;my-first-blog&apos; hexo会帮我们在HEXO文件夹–&gt;source文件夹–&gt;_posts文件夹下生成相关.md文件,用马克飞象打开写文章就可以 文章编辑好之后，运行生成、部署命令： 12hexo g // 生成hexo d // 部署 或者(合并写法) 1hexo d -g #在部署前先生成 踩坑提醒1deloyer not found:git 这样的错误是需要装插件 1npm install hexo-deployer-git --save 下篇:HEXO主题设置https://gaodaxiu0406.github.io/2017/07/31/HEXO%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo博客</tag>
        <tag>基于GitHub创建HEXO博客</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中的方法]]></title>
    <url>%2F2017%2F04%2F25%2FJS%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数组中的方法 1.给数组添加值2) charCodeAt（索引） 返回结果对应的是ASCII码;原字符串不变 1). push();向数组末尾增加n项 参数:想向数组末尾增加的内容,可以传递多个值,统一向数组末尾增加n向 返回值:新增后数组的长度 原数组:改变123var ary=[12,23,34,45]; ary.push(56); console.log(ary);//--&gt;[12,23,34,45,56] 2). unshift();向数组开头增加n项 参数:想向数组开头增加的内容,可以传递多个值,统一向数组开头增加n向 返回值:新增后数组的长度 原数组:改变 扩展:向数组末尾增加 a). splice(a.length,0,x);向末尾增加,可增加多项 2.删除数组中的项 1). pop();删除数组最后一项内容 参数:没有 返回值:被删除的那一项内容 原数组:改变 2). shift();删除数组中的第一项 参数:没有 返回值:被删除的那一项内容 原数组:改变 扩展:删除数组最后一项内容的方法 a) pop();删除数组最后一项内容 b) ary.length–; c) ary.splice(ary.length-1); 3.数组中的截取和拼接 1).slice 实现数组的截取，在原来的数组中截取某一部分 a). slice(n,m); a1). n&gt;=m 返回空数组 a2). n&lt;0,m&lt;0,n&lt;m 从索引m开始找到索引为n处，不包含n，将找到的部分，以新数组返回，原数组不变。原数组的索引最后一位是0,倒数第二位索引是-1,以此类推;例如: 1234var ary1=[11,22,33,44,55,66,77,88,99];var res=ary1.slice(-4,-3);console.log(res,ary1);//[66] (9) [11, 22, 33, 44, 55, 66, 77, 88, 99] a3). n&gt;0,m=原数组总长度时，slice(n,m)返回空数组;例如 123var ary1=[11,22,33,44,55,66,77,88,99];var res=ary1.slice(3,-3);//[44, 55, 66] (9) [11, 22, 33, 44, 55, 66, 77, 88, 99] a4). n&gt;0,m&gt;0,m&gt;n 参数:从索引n开始找到索引m处(不包含m); 返回值:索引n项到索引m-1项,将找到的部分以新数组返回; 原数组:不变; b). slice(n); 参数:从索引n开始一直找到数组末尾 将找到的部分以新数组返回 原数组:不变 c). slice(0);/slice() 把原来的数组克隆一份一模一样的新数组返回 原数组:不变 2).concat();把两个数组拼接在一起 参数: a). ary1.concat(ary2);将ary1和ary2进行拼接,ary2在后面 b). ary1.concat();把ary1克隆一份一模一样的数组 原数组:不变 4.修改数组中某一项的值 1).利用对象的操作方式修改某一项的值,例如:ary[2]=100; 原数组:改变 2).数组中的方法splice a). splice 既能实现删除,也能实现增加,还能实现修改 splice的删除: 返回值:删除的数据以新数组的方式返回 原数组:改变 a1). splice(n,m);从索引n开始,删除m个元素,把删除的内容以一个新数组的方式返回,原数组改变 a2). splice(n);从索引n开始,删除到数组的末尾 a3). splice(0);从索引0开始,删除到数组的末尾;原数组返回空数组,splice(0)相当于克隆一份原数组,这样的克隆会修改原来的数;例如: 1234var a=[11,22,33,44,55,66,77];var res=a.splice(0);console.log(res,a);//(7) [11, 22, 33, 44, 55, 66, 77] , [] a4). splice();相当于没有对原数组进行任何操作,splice()返回一个空数组.原数组不变;例如: 1234 var a=[11,22,33,44,55,66,77];var res=a.splice();console.log(res,a);//[] , (7) [11, 22, 33, 44, 55, 66, 77] a5). splice(a.length-1);删除最后一项，把所有索引最后一个删除掉;例如: 1234var a=[11,22,33,44,55,66];var res=a.splice(a.length-1);console.log(res,a);//[66] , (5) [11, 22, 33, 44, 55] splice的修改: b1). splice(n,m,x); 从索引n开始，删除m个，用x替换删除的部分,x可以是多项;例如: 1234var b=[1,2,3,4,5,6]; var res=b.splice(1,2,11,12,13); console.log(res,b); //[2, 3] , (7) [1, 11, 12, 13, 4, 5, 6] splice的增加: c1). splice(n,0,x); 从索引n开始，删除0个，用x替换删除的部分–&gt;相当于把x增加到索引n的前面;例如: 1234var a=[11,22,33,44,55,66];var res=a.splice(1,0,77,88);console.log(res,a);//[] , (8) [11, 77, 88, 22, 33, 44, 55, 66] c2). splice(a.length,0,x);向末尾增加,可增加多项 5.通过属性值查找索引:只有在标准浏览器下兼容的(数组中不兼容 字符串中兼容)原数组不变 1) indexOf() 2) lastIndexof() 6.遍历数组中的每一项 1) forEach(function(x,y,i){});没有返回值,例如: 12345678910var b=[11,22,33,44,55,66,11];b.forEach(function (item,index) &#123; //item为数组当前项,index为数组中的索引 console.log(item,index);&#125;);//没有返回值 var new1b=b.forEach(function (a,b) &#123; return a*10; &#125;); console.log(new1b);//undefined 2) map(function(x,y,i){return;}); 123456789var b=[11,22,33,44,55,66,11];b.map(function (item,index) &#123; //item为数组当前项,index为数组中的索引 console.log(item,index);&#125;);var newb=b.map(function (item,index) &#123; return item*10;&#125;);console.log(newb);//[110, 220, 330, 440, 550, 660, 110] 7.将数组转化为字符串: 1) join(“”);按照每一个分隔符，把数组中的每一项拼接成一个字符串 12345678var b=[12,22,33,44,55];var res=b.join(&apos;+&apos;);console.log(res,b);//&quot;12+22+33+44+55&quot; (5) [12, 22, 33, 44, 55]//扩展:eval：JS中把字符串变为JS表达式执行的一种方法 console.log(eval(res));//166 //简写: console.log(eval(b.join(&apos;+&apos;)));//166 2) toString();原数组不变 123var b=[12,22,33,44,55];var res=b.toString();console.log(res);//&quot;12,22,33,44,55&quot; 8.排序 1) reverse();把数组倒过来排列,原数组也倒过来排列;例如: 1234var b=[11,22,33,44,55,66,11];var res=b.reverse();console.log(res,b);//(7) [11, 66, 55, 44, 33, 22, 11] (7) [11, 66, 55, 44, 33, 22, 11] 2) sort();给数组进行排序,原数组也进行排序 a). ary.sort(); 只能处理10以内的数字 b). sort(function(a,b){return a-b;});从小到大排序 c). sort(function(a,b){return b-a;);从大到小排序]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>javascript</tag>
        <tag>charCodeAt</tag>
        <tag>slice</tag>
        <tag>indexOf</tag>
        <tag>push</tag>
        <tag>unshift</tag>
        <tag>splice</tag>
        <tag>pop</tag>
        <tag>shift</tag>
        <tag>concat</tag>
        <tag>lastIndexof</tag>
        <tag>forEach</tag>
        <tag>map</tag>
        <tag>join</tag>
        <tag>toString</tag>
        <tag>reverse</tag>
        <tag>sort</tag>
        <tag>数组</tag>
        <tag>数组中的方法</tag>
      </tags>
  </entry>
</search>
