{"meta":{"title":"高大秀博客","subtitle":null,"description":"本站内容涉及前端开发的相关内容,如Javascript、CSS、HTML、CSS3、较为简单的Node、jQuery插件等,为作者高大秀本人根据自己多年经验总结写成，如有异议欢迎留言，愿与大家共同进步。作者qq号:1260833716","author":"高大秀","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2017-07-26T11:43:03.000Z","updated":"2018-01-24T07:08:21.851Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于文档 Vue官方中文文档：https://cn.vuejs.org/ React官方中文文档：https://discountry.github.io/react/ Webpack文档：https://doc.webpack-china.org/ EsLint中文官网：http://eslint.cn/ React Native中文官网：https://reactnative.cn/ Node.js中文文档：http://nodejs.cn/api/ Git中文：https://git-scm.com/book/zh/v2/ Apizza(api接口文档)注册：http://apizza.cc/account/register 关于我 我的github地址：https://github.com/gaodaxiu0406"},{"title":"gitHub","date":"2017-07-29T15:46:57.000Z","updated":"2017-07-29T15:50:15.010Z","comments":true,"path":"gitHub/index.html","permalink":"http://yoursite.com/gitHub/index.html","excerpt":"","text":""},{"title":"分类目录","date":"2017-07-26T10:46:32.000Z","updated":"2017-08-18T12:14:00.674Z","comments":true,"path":"archive/index.html","permalink":"http://yoursite.com/archive/index.html","excerpt":"","text":""}],"posts":[{"title":"2.react轮播图项目开写","slug":"2-react轮播图项目开写","date":"2017-07-30T17:49:58.000Z","updated":"2017-09-09T12:26:32.998Z","comments":true,"path":"2017/07/31/2-react轮播图项目开写/","link":"","permalink":"http://yoursite.com/2017/07/31/2-react轮播图项目开写/","excerpt":"","text":"关于react轮播图的源码,无缝版已上传至github,https://github.com/gaodaxiu0406/React-Slider 用react+webpack写一个的轮播图项目(项目配置请看上篇react轮播图项目配置及原理概要) 先将整个文件写在一个文件中,1.画结构 新建一个components文件夹 components文件夹下新建Slider.js文件和Slider.less文件(Slider.less文件是用来给Slider.js写样式的) 2.在indix.js中引入组件 渲染到页面中 打开src文件夹中的index.html文件 1&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 2-1).在这个id为root的标签中渲染元素 2-2).回到index.js中,写一个轮播图组件，渲染到index.html中 12345678910import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import Slider from &apos;./components/Slider&apos;;let images=[ &#123;src:require(&apos;./images/1.jpg&apos;)&#125;, &#123;src:require(&apos;./images/2.jpg&apos;)&#125;, &#123;src:require(&apos;./images/3.jpg&apos;)&#125;, &#123;src:require(&apos;./images/4.jpg&apos;)&#125;];ReactDOM.render(&lt;Slider images=&#123;images&#125;/&gt;,document.querySelector(&apos;#root&apos;)); 解释1)引入React，引入ReactDOM，引入Slider组件 然后通过ReactDOM.render将Slider组件渲染到index.html的id为root的div标签中 解释2)Slider组件需要图片参数 src文件夹下新建一个images文件夹，存入轮播的图片 将图片路径通过require存入images数组中 通过组件Slider标签将所需的images参数传入组件Slider(让images参数变量等于images数组) 3.开始写Slider.js中的代码 需要默认导出一个组件Slider供外面文件(index.js)调用;还需要接收一个images属性进行轮播 1234567891011121314151617181920import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;require(&apos;./Slider.less&apos;);export default class Slider extends React.Component&#123; render()&#123; let images=this.props.images; return( &lt;div className=&quot;slider-wrapper&quot;&gt; &lt;ul className=&quot;sliders&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;li className=&quot;slider&quot;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125; 1)require(&#39;./Slider.less&#39;);–&gt;这里引入Slider.less用import和require都是一样的效果，都是加载一个模块的意思,模块可能是图片，可能是less/css/js/json文件,都可以–&gt;在webpack中一切皆模块,不管是什么资源，都可以作为模块来加载 2)li的数量取决于images数据,images中有几张图片，就有几个li 在render中let一个变量images来接收index.js传入的images,然后用map方法遍历整个数组 在Slider.less中写好轮播图的样式 123456789101112131415161718192021222324252627*&#123; padding: 0; margin: 0;&#125;ul,li&#123; list-style: none;&#125;.wrapper&#123; width: 400px; height: 400px; position: relative; margin: 30px auto; .sliders&#123; height: 400px; position: absolute; left:0; .slider&#123; float: left; width: 400px; height: 400px; img&#123; width: 100%; height: 100%; &#125; &#125; &#125;&#125; 宽高为400px的轮播图 4.写配置文件 在webpack.config.js中加loaders 1234567module:&#123; loaders:[ &#123;test:/\\.js$/,loader:&apos;babel-loader&apos;,exclude:/node_modules/&#125;, &#123;test:/\\.less$/,loader:&apos;style-loader!css-loader!less-loader&apos;&#125;, &#123;test:/\\.(jpg|png|gif)$/,loader:&apos;url-loader&apos;&#125; ] &#125; babel默认情况下什么都不做，需要一个配置文件.babelrc文件 新建一个.babelrc配置文件123&#123; &quot;presets&quot;: [&quot;es2015&quot;,&quot;stage-0&quot;,&quot;react&quot;]&#125; presets预设,”es2015”将es6编译成es5,”stage-0”将es7编译成es5,”react”将react编译成es5 原理1:{test:/\\.js$/,loader:&#39;babel-loader&#39;,exclude:/node_modules/}–&gt;处理(编译)js文件:如果发现文件是js,用babel-loader加载,加载的时候需要读配置文件.babelrc,如果代码时es6/es7/react都要通过babel转成es5;同时通过exclude将node_modules文件夹下的所有js文件排除掉 原理2:{test:/\\.less$/,loader:&#39;style-loader!css-loader!less-loader&#39;}–&gt;如果发现文件以.less结尾的,第一步通过less-loader将less编译成css,然后通过css-loader进行加载,然后通过style-loader将他通过style标签的形式插入到页面中去，变成一个行内样式 原理3:{test:/\\.(jpg|png|gif)$/,loader:&#39;url-loader&#39;}–&gt;凡是资源文件都可以用url-loader来加载,不论是图片、图标、字体、视频、音频;后面可以通过问号传参,有个参数limit(例如:{test:/\\.(jpg|png|gif)$/,loader:&#39;url-loader?limit=8192&#39;}–&gt;小于8K的资源文件将直接以base64的形式内联在代码中，可以减少一次http请求) 此时执行npm run build,将代码打包到出口文件中,打开build文件夹下的index.html文件就可以直接预览效果了 此时会发现控制台有个报错 123Warning: Each child in an array or iterator should have a unique &quot;key&quot; prop. Check the render method of `Slider`. See https://fb.me/react-warning-keys for more information. in li (created by Slider) in Slider 需要唯一的key属性,在Slider.js文件中的li需要唯一的key属性，给li标签加上key属性即可 1&lt;li className=&quot;slider&quot; key=&#123;index&#125;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; 关掉浏览器,重新执行npm run build，再打开build文件夹下的index.html文件预览,控制台就没有报错了 5.写功能 让图片动起来,需要给Slider.js加个状态,需要有个定时器让他动起来 写在周期函数componentDidMount中 1234567891011constructor()&#123; super(); this.state=&#123;pos:0&#125;;//默认索引 &#125; componentDidMount()&#123; this.$timer=setInterval(()=&gt;&#123; let pos=this.state.pos; pos++;//每隔2s让pos加1，pos值影响ul的左偏移量left的值 所以ul应该有个style属性 left值应该变化 this.setState(&#123;pos:pos&#125;) &#125;,this.props.interval*1000) pos++;–&gt;每隔2s让pos加1，pos值影响ul的左偏移量left的值 所以ul应该有个style属性 left值应该变化 ul应该有个style属性123456789101112131415161718192021render()&#123; let images=this.props.images; let style=&#123; width:400*images.length, left:this.state.pos*-400 &#125;; return( &lt;div className=&quot;slider-wrapper&quot;&gt; &lt;ul style=&#123;style&#125; className=&quot;sliders&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;li className=&quot;slider&quot; key=&#123;index&#125;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; this.props.interval*1000–&gt;每隔2s轮播一次,需要有变量传进来–&gt;在index.js中新增一个interval变量(间隔时间让外面可以控制) 1).这里通过this.props获取index.js中传递进来的的interval变量this.props.interval*1000 2).index.js中新增一个interval变量12345ReactDOM.render( &lt;Slider images=&#123;images&#125; interval=&#123;2&#125; /&gt;,document.querySelector(&apos;#root&apos;)); 写功能步骤总结: 第一步:定义一个默认索引pos,默认值是0 第二步:在组件加载完成之后创建定时器setInterval赋给this.$timer 第三步:每隔2s让图片向左偏移一个宽度的距离(interval是外界传进来的,是图片轮播的间隔时间),在index中要给组件Slider传进来一个2,2*1000意味着2s变一次 this.$timer中先取出老的pos值，第一次轮播pos就是0，然后pos++，pos变成1，然后setState重新设置pos值,让pos值往上 pos会影响ul的left值，一张图片的宽度是400px，向左偏移400，就是*-400 ul的宽度应该是宽度400乘以图片的数量images.length,4张图就是1600px执行npm run dev 注意,执行npm run dev可自动将文件编译更新打包到出口文件index.html中，并且只要更改文件，页面就会自动刷新,但是如果更改配置文件,需要重新启动npm run dev服务 此时执行npm run dev命令,轮播图就动起来了，但是越界了,因为此时还没有做边界处理 7.完善功能 将Slider需要的属性(可外界控制的)，在index.js的Slider组件标签中传入 1234567891011ReactDOM.render( &lt;Slider images=&#123;images&#125;//图片 interval=&#123;2&#125;//多长时间轮播一次 speed=&#123;1&#125;//每次轮播的速度 pause=&#123;true&#125;//当鼠标移动上去之后自动暂停 autoplay=&#123;true&#125;//是否启用自动轮播，false不自动轮播 - 在Slider.js中 dots=&#123;true&#125;//是否有点状导航 arrows=&#123;true&#125;//是否有箭头导航 /&gt;,document.querySelector(&apos;#root&apos;)); 添加transitionDuration–&gt;规定完成过渡效果需要花费的时间 speed默认值是1 这里就是1s 12345let style=&#123; width:400*images.length, left:this.state.pos*-400, transitionDuration:this.props.speed+&apos;s&apos; &#125;; 在Slider.js的周期函数中添加一个判断 123456789componentDidMount()&#123; if(this.props.autoPlay)&#123; this.$timer=setInterval(()=&gt;&#123; let pos=this.state.pos; pos++; this.setState(&#123;pos:pos&#125;) &#125;,this.props.interval*1000) &#125;&#125; this.props.autoPlay 是否自动轮播 如果外界传入true就是自动轮播，传入false就是不自动轮播 8.将轮播切换单独拎出来写成一个方法turn12345turn(n)&#123; let pos=this.state.pos; pos+=n; this.setState(&#123;pos:pos&#125;)&#125; 或者使用es6的箭头函数 12345turn=(n)=&gt;&#123; let pos=this.state.pos; pos+=n; this.setState(&#123;pos:pos&#125;) &#125; let pos=this.state.pos;获取旧索引 turn表示切换,n表示切换的步长,方便以后操作:例如往左走传1进来即可，往右走传-1进来即可 那么此时在周期函数中,直接调用这个turn方法即可,默认往右轮播，传入-11234567componentDidMount()&#123; if(this.props.autoplay)&#123; this.timer=setInterval(()=&gt;&#123; this.turn(1); &#125;,this.props.interval*1000) &#125;&#125; 9.实现鼠标移上去停止轮播 给div加onMouseOver和onMouseOut事件123&lt;ul onMouseOver=&#123;()=&gt;clearInterval(this.timer)&#125; onMouseOut=&#123;this.play&#125; style=&#123;style&#125; className=&quot;sliders&quot;&gt;...&lt;/ul&gt; 10.自动轮播部分也封装成一个函数play12345play=()=&gt;&#123; this.timer=setInterval(()=&gt;&#123; this.turn(1); &#125;,this.props.interval*1000) &#125;; play表示开启定时器进行自动轮播 那么此时在周期函数中直接调用this.play()即可12345componentDidMount()&#123; if(this.props.autoplay)&#123; this.play(); &#125;&#125; 11.边界判断12345678turn=(n)=&gt;&#123; let pos=this.state.pos; pos+=n; if(pos&gt;=this.props.images.length)&#123; pos=0; &#125; this.setState(&#123;pos:pos&#125;) &#125;; 当索引为图片总张数的时候 让索引变为012.写左右箭头 在ul下加一个div 1234&lt;div className=&quot;arrows&quot;&gt; &lt;span className=&quot;arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span className=&quot;arrow-right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt; 在Slider.less中写样式 123456789101112131415161718192021222324252627.arrows&#123; position: absolute; width: 100%; height: 20px; top:50%; margin-top:-10px; .arrow&#123; width: 20px; height: 20px; line-height: 20px; text-align: center; cursor: pointer; font-size: 30px; background-color: #eee; &amp;:hover&#123; background-color: #999; &#125; &#125; .arrow-left&#123; margin-left: 5px; float: left; &#125; .arrow-right&#123; margin-right: 5px; float: right; &#125;&#125; 给左右arrow绑定事件 1234&lt;div className=&quot;arrows&quot;&gt; &lt;span onClick=&#123;()=&gt;this.turn(-1)&#125; className=&quot;arrow arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span onClick=&#123;()=&gt;this.turn(1)&#125; className=&quot;arrow arrow-right&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt; 13.处理左边界 在turn中做个判断 1234567891011turn=(n)=&gt;&#123; let pos=this.state.pos; pos+=n; if(pos&gt;=this.props.images.length)&#123; pos=0; &#125; if(pos&lt;0)&#123; pos=this.props.images.length-1; &#125; this.setState(&#123;pos:pos&#125;)&#125;; 当索引小于0的时候,让索引等于images的长度-1 14.根据传进来的arrows值判断是否有左右箭头切换效果 第一种方法(看着比较乱) 123456&#123; this.props.arrows?&lt;div className=&quot;arrows&quot;&gt; &lt;span onClick=&#123;()=&gt;this.turn(-1)&#125; className=&quot;arrow arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span onClick=&#123;()=&gt;this.turn(1)&#125; className=&quot;arrow arrow-right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt;:null &#125; 第二种,在render中 123456789let arrows=null; if(this.props.arrows)&#123; arrows=( &lt;div className=&quot;arrows&quot;&gt; &lt;span onClick=&#123;()=&gt;this.turn(-1)&#125; className=&quot;arrow arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span onClick=&#123;()=&gt;this.turn(1)&#125; className=&quot;arrow arrow-right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt; ) &#125; 那么ul下面就可以直接用{arrows}代替了(看着很清晰明了) 123456789101112&lt;div className=&quot;slider-wrapper&quot;&gt; &lt;ul onMouseOver=&#123;()=&gt;clearInterval(this.timer)&#125; onMouseOut=&#123;this.play&#125; style=&#123;style&#125; className=&quot;sliders&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;li className=&quot;slider&quot; key=&#123;index&#125;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &#123;arrows&#125;&lt;/div&gt; 15.根据传进来的dots值判断是否有点状导航123456789101112let dots=null; if(this.props.dots)&#123; dots=( &lt;div className=&quot;dots&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;span className=&quot;dot&quot; key=&#123;index&#125;&gt;&lt;/span&gt; )) &#125; &lt;/div&gt; ) &#125; dots直接放到最下面即可123...&#123;arrows&#125;&#123;dots&#125; 15-1.在Slider.less中写dots的样式12345678910111213141516171819.dots&#123; width: 100%; height: 20px; position: absolute; bottom: 10px; text-align: center; .dot&#123; display: inline-block; width: 20px; height: 20px; border-radius: 50%; margin-left: 5px; background-color: #abcdef; cursor: pointer; &amp;:hover&#123; background-color: #999999; &#125; &#125;&#125; 16.点状导航的点击跟随事件 给span加onClick事件123···&lt;span className=&quot;dot&quot; key=&#123;index&#125; onClick=&#123;()=&gt;this.turn(index-this.props.pos)&#125;&gt;&lt;/span&gt;··· 16-1.轮播点状导航自动跟随事件 在Slider.less中加一个active样式 123.active&#123; background-color: #999999; &#125; 给span标签添加active属性 1&lt;span className=&#123;&quot;dot &quot;+(index==this.state.pos?&apos;active&apos;:&apos;&apos;)&#125; key=&#123;index&#125; onClick=&#123;()=&gt;this.turn(index-this.state.pos)&#125;&gt;&lt;/span&gt;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"1.react轮播图项目配置及原理概要","slug":"1-react轮播图项目配置及原理概要","date":"2017-07-30T17:47:17.000Z","updated":"2017-09-09T12:26:33.016Z","comments":true,"path":"2017/07/31/1-react轮播图项目配置及原理概要/","link":"","permalink":"http://yoursite.com/2017/07/31/1-react轮播图项目配置及原理概要/","excerpt":"","text":"项目配置及原理概要1.初始化项目1npm init -y 生成package.json文件 2.安装依赖包 开发依赖1npm install webpack webpack-dev-server babel-core babel-loader babel-preset-react babel-preset-es2015 babel-preset-stage-0 style-loader css-loader less-loader less file-loader url-loader html-webpack-plugin -D webpack 打包 webpack-dev-server 用来启动一个HTTP服务器预览我们的项目 babel-core babel-loader 进行转译 把es6和react代码转译成es5 babel-preset-react 用来转译react babel-preset-es2015 用来转译es6 babel-preset-stage-0 用来转译es7 style-loader css-loader 用来处理css less-loader less 编译less file-loader url-loader 用来处理资源文件 html-webpack-plugin 用来自动产出html文件 open-browser-webpack-plugin 自动打开浏览器 3.安装生产依赖1npm install react react-dom -S 4.配置文件的出入口路径 新建一个webpack.config.js文件，在文件中配置入口文件和出口路径12345678let path=require(&apos;path&apos;);module.exports=&#123; entry:&apos;./src/index.js&apos;,//入口文件 output:&#123;//出口配置 path:path.resolve(&apos;build&apos;),//出口文件路径 filename:&apos;bundle.js&apos;//出口文件名称 &#125;&#125;; 5.启动安装的模块文件夹node_modules–&gt;.bin–&gt;webpack.cmd和webpack-dev-server.cmd文件 在package.json文件中的scripts标签进行匹配1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;:&quot;webpack-dev-server&quot; &#125;, 5-1.启动webpack和webpack-dev 在cmd中执行命令 1npm run build 1)在cmd窗口中显示 123 Asset Size Chunks Chunk Namesbundle.js 2.52 kB 0 [emitted] main [0] ./src/index.js 43 bytes &#123;0&#125; [built] 表示生成bundle.js一个文件 2)在当前项目文件夹下会自动生成一个build文件夹，同时在build文件夹下会自动生成bundle.js文件，我们的入口文件(src文件夹下的index.js)会自动打包到出口文件bundle.js中 6.自动产出html文件6-1.现在我们需要在build文件夹中新建一个index.html文件，然后引入bundle.js进行预览;但是现在我们希望这个文件不要手动创建了，希望他可以自动生成，要做到这一点，我们需要引入插件html-webpack-plugin(此插件在最初已经安装过,如果没有安装需安装后才可使用) 1) 在webpack.config.js中引入html-webpack-plugin 1let HtmlWebPackPlugin=require(&apos;html-webpack-plugin&apos;); 2) 同时给插件再添加个配置项plugins,plugins是个数组 12345plugins:[ new HtmlWebPackPlugin(&#123; template:&apos;./src/index.html&apos; &#125;)] 3) template 模板 配置到时候会按照哪个模板来自动产出html文件 并且把它自动放到配置目录下–&gt;一般会在src文件夹下新建一个模板叫index.html 4) 执行npm run build 4-1).原理:此时如果再执行npm run build的话，就会执行上面配置的plugins插件,插件会读取src文件夹下的index.html模板文件，把他自动插入到打包后的bundle.js，并且把bundle.js保存到build目录下(每次执行npm run build命令，都会重新生成bundle.js和index.html两个文件) 4-2).在cmd命令行执行npm run build,命令行显示: 1234 Asset Size Chunks Chunk Names bundle.js 2.52 kB 0 [emitted] mainindex.html 188 bytes [emitted] [0] ./src/index.js 43 bytes &#123;0&#125; [built] 表示生成bundle.js和index.html两个文件,与之前执行npm run build相比多了一个html文件 4-3).打开我们的项目文件夹下的build文件会发现，已经自动生成了一个出口index.html出口文件,打开这个index.html出口文件会发现,index.html中已经自动引入了bundle.js文件 关于react轮播图的源码,无缝版已上传至github,https://github.com/gaodaxiu0406/React-Slider","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"“前端三层”","slug":"“前端三层”","date":"2017-06-30T06:26:17.000Z","updated":"2017-09-09T12:22:08.765Z","comments":true,"path":"2017/06/30/“前端三层”/","link":"","permalink":"http://yoursite.com/2017/06/30/“前端三层”/","excerpt":"","text":"前端三层 html结构 是直接被浏览器解析加载 CSS样式 是在html结构之上去装点网站 javascript 交互 动态效果/数据交互 基础知识 网页 网页是构成网站的基本元素，通俗来讲，一个html文件就是一个网页 网站 是由很多个网页组成的，共同为一个目标服务的网页集合 站群（流水线统一化管理） 由很多网站组成的，为同一个公司服务。 例如整个百度下所属的子公司都有自己的网站。例如：百度搜索/糯米/音乐/手机助手/百度金融等组成的就是一个站群。 HTTP（超文本传输协议） HyperText Transfer Protocol 在万维网上提供一种发布和接收HTML页面（网页）的方法。 eg：http://www.baidu.com 404服务器无响应 步骤: 输入网址，建立链接，建立客户端和服务端的连接。 发送请求信息：客户端发送一个请求给服务器 发送相应信息：服务器找到请求后，给予相应的响应信息 关闭连接：客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接 服务器 服务器，是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。 在网络环境下，根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，WEB服务器等。 防篡改：WEB端服务器一旦受到攻击，在0.0n秒做出反应，将内网服务器中的内容，马上覆盖在WEB服务器上。 负载均衡：平均WEB服务器压力，将用户访问进行分流。 vpn：用来翻墙，有指定账号就可以通过这个产品进行内网访问。 浏览器 浏览器是指可以显示网页服务器或者文件系统的HTML文件（标准通用标记语言的一个应用）内容，并让用户与这些文件交互的一种软件。 html，css，js都是运行在这个软件中，浏览器是一个工厂，html/css/js是工人和原料。 IE6–&gt;IE7（很快淘汰）–&gt;IE8(时间较长，稳定性好)–&gt;IE9(半年到一年)–&gt;IE10–&gt;IE11–&gt;IE11–&gt;IE(Edge) 最好用的浏览器–&gt;谷歌 网页的基本组成 HTML:是网页的骨架,支撑起血肉(文字,图片,音视频等) CSS:表皮和衣服、化妆品 javascript：动态和交互 HTML（超文本标记语言） 网页本身就是一种文本文件（除了文字再无其他），只有通过特定的标记描述，那些普通文本才能在浏览器中正常显示。 在页面中如果遇到图片、音视频的时候，如何用文本描述，需要用超文本进行引入才可以正常显示。 HTML文件的特点： 浏览器根据标记来解析和描述内容（从html的第一行开始向下），如果遇到错误，浏览器不会指出也不会报错，会跳过此处继续加载，编辑人员需要根据显示效果去分析哪里出错误了——html不会报错 HTML的兼容问题： 因为浏览器是由不同厂商生产的，所以对html的解析有分歧，产生了页面效果显示不一致的情况，我们将这个问题叫做兼容问题。 超文本（标签） 标签语法： 由成对的尖括号和关键字组成，叫做标签。 关键字（标签名）：是已经规范过的，不是自己随便制造的。 例如：&lt;div&gt; , &lt;/h2&gt; , &lt;img/&gt; 标签属性 属性提供了这个元素的更多信息，语法：由属性名和属性值组成（键值对 key=”value”） 1234&lt;span style=&quot;font-family:宋体;&quot; title=&quot;标题&quot;&gt;span是标签名style是标签属性名&quot;font-family:宋体;标签属性值 一个标签可以由多个标签属性，每一个属性之间用空格隔开 标签的分类: 开始标签 &lt;div&gt; 结束标签 &lt;/div&gt; 自闭合标签(空标签) &lt;br/&gt; HTML元素 可以将元素理解成一个容器，容器中放置的就是 由标签和内容组成的，叫做元素。 &lt;div&gt;此处是内容&lt;/div&gt; 元素分类 由开始标签和结束标签组成的元素，可以进行嵌套（一个元素包着另一个元素），元素中可以添加内容，只有一个空标签，只能进行功能的添加，例如img元素 标签和元素是用来标记和描述内容的，所以这些标签和元素用户是看不到的，用户只能看到这个元素的内容。","categories":[],"tags":[{"name":"前端常识","slug":"前端常识","permalink":"http://yoursite.com/tags/前端常识/"}]},{"title":"Canvas动态案例","slug":"canvas动态案例","date":"2017-06-09T10:17:02.000Z","updated":"2017-09-09T12:26:32.983Z","comments":true,"path":"2017/06/09/canvas动态案例/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas动态案例/","excerpt":"","text":"12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;draw&quot; width=&quot;220&quot; height=&quot;320&quot; style=&quot;background-color: skyblue&quot;&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); var img=new Image; img.src=&apos;walkingdead.png&apos;;//添加图片地址 img.onload=function()&#123;//图片上有10张小图横着排列 var width=this.width/10; var height=this.height; var i=0; window.setInterval(function()&#123; cvs.clearRect(0,0,draw.width,draw.height);//清除上一个图片 cvs.drawImage(img,i*width,0,width,height,0,0,width,height); if(i==9)&#123; i=0 &#125;else&#123;i++;&#125; &#125;,200); &#125;&lt;/script&gt;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之4渐变","slug":"canvas之4渐变","date":"2017-06-09T06:56:44.000Z","updated":"2017-09-09T12:26:33.011Z","comments":true,"path":"2017/06/09/canvas之4渐变/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之4渐变/","excerpt":"","text":"1.线性渐变 var CLG=cvs.createLinearGradient(x0,y0,x1,y1); x0:渐变开始的x坐标 y0:渐变开始的y坐标 x1:渐变结束的x坐标 y1:渐变结束的y坐标 CLG.addColorStop(n,m); n:设置颜色的偏移量 m:颜色 例如: 12345678910111213function draw1()&#123; var CLG=cvs.createLinearGradient(0,0,200,200); //创建一个线性渐变 渐变开始的坐标0,0 渐变结束的坐标200,200 (即从左上角到右下角渐变) CLG.addColorStop(0,&apos;red&apos;);//设置渐变的偏移量0% 颜色红色 CLG.addColorStop(0.25,&apos;yellow&apos;);//设置渐变的偏移量25% 颜色黄色 CLG.addColorStop(0.5,&apos;skyblue&apos;);//设置渐变的偏移量50% 颜色天空蓝 CLG.addColorStop(0.75,&apos;orange&apos;);//设置渐变的偏移量75% 颜色橘黄 CLG.addColorStop(1,&apos;pink&apos;);//设置渐变的偏移量100% 颜色粉色 cvs.fillStyle=CLG;//设置填充样式是线性渐变 cvs.fillRect(0,0,200,200);//设置填充矩形 左上角坐标0,0 宽200px 高200px cvs.fill();//设置样式为填充样式&#125;draw1(); 2.径向渐变(发散性渐变) cvs.createRadialGradient(x0,y0,x1,y1,r1); x0:发散渐变开始中心的x坐标 y0：发散渐变开始中心的y坐标 r0:发散渐变开始的半径 x1:发散渐变结束中心的x坐标 y1：发散渐变结束中心的y坐标 r1:发散渐变结束的半径 例如:1234567891011121314function draw2()&#123; var CRG=cvs.createRadialGradient(200,200,200,200,200,10); //创建一个径向/发散性渐变 渐变开始的坐标200,200 渐变开始的半径200px 渐变结束的坐标200,200 渐变结束的半径10px CRG.addColorStop(0,&apos;purple&apos;); CRG.addColorStop(0.2,&apos;yellow&apos;); CRG.addColorStop(0.4,&apos;pink&apos;); CRG.addColorStop(0.6,&apos;lightblue&apos;); CRG.addColorStop(0.8,&apos;skyblue&apos;); CRG.addColorStop(1,&apos;white&apos;); cvs.fillStyle=CRG;//设置填充样式是径向渐变 cvs.fillRect(100,100,200,200); //设置填充矩形 左上角坐标100,100 宽200px 高200px&#125;draw2();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之3绘制矩形","slug":"canvas之3绘制矩形","date":"2017-06-09T05:07:19.000Z","updated":"2017-09-09T12:26:32.991Z","comments":true,"path":"2017/06/09/canvas之3绘制矩形/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之3绘制矩形/","excerpt":"","text":"cvs.fillRect(x,y,w,h); –&gt; 填充矩形 x,y 是这个矩形左上角的坐标 w,h 是这个矩形的宽高 cvs.strokeRect(x,y,w,h); –&gt; 带边框的矩形 x,y 是这个矩形左上角的坐标 w,h 是这个矩形的宽高 注意:如果设置边框 边框一半在里面一半在外面 cvs.clearRect(x,y,w,h); –&gt; 清除填充图的某一部分，清除的还是一个矩形 x,y 是这个矩形左上角的坐标 w,h 是这个矩形的宽高案例 案例1 12345678910function draw1()&#123; //填充矩形 cvs.fillStyle=&apos;#fccdda&apos;;//画之前填充颜色 cvs.fillRect(10,20,100,50);//设置填充矩形,矩形的左上角坐标为10,20 宽100px 高50px //边框矩形 cvs.strokeStyle=&apos;red&apos;;//设置边框的矩形边框颜色 cvs.lineWidth=20;//设置边框宽度20px cvs.strokeRect(150,20,100,50);//设置边框矩形， 矩形的左上角坐标为150,20 宽100px 高50px&#125;draw1(); 案例2 12345678910111213function draw2()&#123;//清除填充图的某一部分，清除的还是一个矩形cvs.clearRect(x,y,w,h) cvs.fillStyle=&apos;orange&apos;; //画之前填充颜色 cvs.fillRect(20,100,300,100); //设置填充矩形,矩形左上角坐标为20,100 宽300px 高100px cvs.clearRect(140,140,60,60); //清除填充图的矩形 清除的这个矩形左上角坐标140,140 宽60px 高60px cvs.clearRect(20,100,40,40); //清除填充图的矩形 清除的这个矩形左上角坐标20,100 宽40px 高40px cvs.clearRect(280,100,40,40); //清除填充图的矩形 清除的这个矩形左上角坐标280,100 宽40px 高40px&#125;draw2();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之5绘制文本","slug":"canvas之5绘制文本","date":"2017-06-09T04:55:35.000Z","updated":"2017-09-09T12:26:33.005Z","comments":true,"path":"2017/06/09/canvas之5绘制文本/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之5绘制文本/","excerpt":"","text":"1.阴影 cvs.shadowOffsetX//阴影的横向偏移量，默认值是0 cvs.shadowOffsetY//阴影的纵向偏移量，默认值是0 cvs.shadowColor//阴影的颜色 cvs.shadowBlur//阴影的模糊范围（值越大越模糊） 案例 123456789function draw1()&#123; cvs.shadowColor=&apos;#000fff&apos;;//设置阴影颜色 cvs.shadowOffsetX=30;//设置阴影的横向偏移量30px cvs.shadowOffsetY=20;//设置阴影的纵向偏移量20px cvs.shadowBlur=20;//设置阴影的模糊范围20px cvs.fillStyle=&apos;#449fdb&apos;;//设置填充的样式为颜色填充 cvs.fillRect(50,50,100,100);//设置填充矩形 左上角坐标50,50 宽100px 高100px&#125;draw1(); 2.绘制文本 设置字体样式 cvs.font=’字体大小font-size 字体样式font-family’ 水平对齐方式 cvs.textAlign(start,end,right,center); 垂直对齐方式 cvs.textBaseline=’’ 属性值:top,middle,hangle,bottom,alphabetic,ideographic 计算文本长度 var text=’dfbzbh’ console.log(cvs.measureText(text));//width:40.453125 填充文字 cvs.fillText(text,x,y,maxWidth); 1) text:文本内容 2) x:文字起始点的横坐标 3) y:文字起始点的纵坐标 绘制文字轮廓 cvs.strokeText(text,x,y,maxWidth); 1) text:文本内容 2) x:文字起始点的横坐标 3) y:文字起始点的纵坐标 案例1 12345678910function draw1()&#123; cvs.shadowColor=&apos;#000fff&apos;;//设置阴影颜色 cvs.shadowOffsetX=30;//设置阴影的横向偏移量30px cvs.shadowOffsetY=20;//设置阴影的纵向偏移量20px cvs.shadowBlur=20;//设置阴影的模糊范围20px cvs.fillStyle=&apos;#449fdb&apos;;//设置填充的样式为颜色填充 cvs.fillRect(50,50,100,100); //设置填充矩形 左上角坐标50,50 宽100px 高100px &#125; draw1(); 案例2 1234567891011121314151617function draw2()&#123; var text=&apos;hellow word&apos;;//设置文本内容 cvs.fillStyle=&apos;yellow&apos;;//设置填充样式颜色 cvs.font=&apos;40px verdana&apos;;//设置字体样式 cvs.textAlign=&apos;start&apos;;//设置字体的水平对齐方式 cvs.textBaseline=&apos;top&apos;;//设置字体的垂直对齐方式 cvs.fillText(text,10,10); //设置填充文字 文本内容text 文本起始点坐标10,10 var length=cvs.measureText(text); //获取文本宽度(长度)length console.dir(length); //TextMetrics--&gt;width:241.171875 //==&gt;length.width字体的宽度 cvs.fillText(&quot;字体长度为&quot;+length.width,10,60); //设置填充文字(通过字符串拼接方式) 文本起始点坐标10,60&#125;draw2(); 案例3:文本线性渐变 123456789101112131415161718192021222324function draw3()&#123; var CLG=cvs.createLinearGradient(0,0,300,100); //创建一个线性渐变 渐变开始的坐标0,0 渐变结束的坐标300,100 CLG.addColorStop(0,&apos;skyblue&apos;);//设置渐变的偏移量0% 天空蓝 CLG.addColorStop(0.25,&apos;plum&apos;);//设置渐变的偏移量25% 紫色 CLG.addColorStop(0.5,&apos;lightblue&apos;);//设置渐变的偏移量50% 蓝 CLG.addColorStop(0.75,&apos;skyblue&apos;);//设置渐变的偏移量75% 天空蓝 CLG.addColorStop(1,&apos;plum&apos;);//设置渐变的偏移量100% 紫色 var text=&apos;hellow word&apos;;//设置文本内容 cvs.fillStyle=CLG;//设置填充样式是线性渐变 cvs.shadowOffsetX=5;//设置阴影的横向偏移量5px cvs.shadowOffsetY=4;//设置阴影的纵向偏移量4px cvs.shadowColor=&apos;#ffb6c1&apos;;//设置阴影的颜色 cvs.shadowBlur=5;//设置阴影的模糊度 cvs.font=&apos;40px cursive&apos;;//设置字体样式 cvs.textAlign=&apos;top&apos;;//设置字体的水平对齐方式 cvs.fillText(text,50,150); //设置填充文字text 文本起始点坐标50,150 var width=cvs.measureText(text).width;//获取文本宽度(长度)length cvs.fillText(&quot;字体长度为：&quot;+width,10,200); //设置填充文字(通过字符串拼接方式) 文本起始点坐标10,200 &#125; draw3(); 案例4:文本径向渐变 123456789101112131415161718function draw4()&#123; var CRG=cvs.createLinearGradient(0,0,600,0,0,20); //创建一个径向渐变 渐变开始的坐标0,0 开始渐变的半径600px 渐变结束的坐标0,0 渐变结束的半径20px CRG.addColorStop(0,&apos;pink&apos;); CRG.addColorStop(0.25,&apos;skyblue&apos;); CRG.addColorStop(0.5,&apos;yellow&apos;); CRG.addColorStop(0.75,&apos;plum&apos;); CRG.addColorStop(1,&apos;skyblue&apos;); var text=&apos;I WANT EAT&apos;; cvs.fillStyle=CRG;//设置填充样式是径向渐变 cvs.font=&apos;80px simsun&apos;;//设置字体样式 cvs.textAlign=&apos;start&apos;;//设置文本横向对齐方式 cvs.textBaseline=&apos;top&apos;;//设置文本纵向对齐方式 cvs.shadowColor=&apos;lightblue&apos;;//设置阴影颜色 cvs.shadowBlur=10;//设置阴影的模糊范围10px cvs.fillText(text,10,10);//设置填充文字text 文本起始点坐标10,10&#125;draw4();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之2画圆","slug":"canvas之2画圆","date":"2017-06-08T11:56:51.000Z","updated":"2017-09-09T12:26:32.970Z","comments":true,"path":"2017/06/08/canvas之2画圆/","link":"","permalink":"http://yoursite.com/2017/06/08/canvas之2画圆/","excerpt":"","text":"cvs.arc(x,y,radius,startAngle,endAngle,anticlokwise); x,y 圆心坐标 radius半径r startAngle 起始角 以弧度计算(钟表的3点钟方向是0度,也就是x轴的正方向是0度,默认是顺时针) endAngle 结束角 anticlokwise 是否逆时针 默认值false false表示顺时针 案例 案例1:边框半圆 123456789function draw1()&#123;//边框圆 cvs.strokeStyle=&apos;#ffa50&apos;;//设置笔触样式(边框样式)颜色 cvs.beginPath();//开始一个路径 cvs.arc(500,500,100,0,Math.PI);//圆心坐标是500,500，半径是100px，起始角为0度，结束角为180度 cvs.closePath();//结束路径 cvs.lineWidth=10;//边框宽度为10px cvs.stroke();//绘制图形以边框样式绘制&#125;draw1(); 案例2:同心圆 12345678910111213141516171819202122function draw2()&#123; cvs.fillStyle=&apos;orange&apos;; cvs.beginPath(); //开始一个新的路径 cvs.arc(200,200,60,Math.PI/2,2*Math.PI); //圆心坐标是(200,200),半径为60px,起始角为90度,结束角为360度 cvs.closePath(); //结束一个路径 cvs.fill(); //绘制图形以填充样式绘制 cvs.strokeStyle=&apos;yellow&apos;; //设置 笔触样式(边框样式) 为黄色 cvs.lineWidth=40; //边框的宽度为40px cvs.beginPath(); //开始一个新的路径 cvs.arc(200,200,80,0,2*Math.PI); //圆心坐标是(200,200),半径为80px,起始角度为0度,结束角度为360度 cvs.closePath();//结束一个路径 cvs.stroke();//绘制图形以边框样式绘制&#125;draw2(); 案例3:每次调用fill绘制填充图的时候，会把当次路径的起始点和结束点分别连接，填充闭合部分(如果想让每个路径互不干扰 一定要记得写结束路径–&gt;关闭路径) 12345678910111213function draw3()&#123; cvs.strokeStyle=&apos;pink&apos;;//设置笔触样式(边框样式)颜色为粉色 cvs.beginPath();//开始一个路径 cvs.lineWidth=2;//边框的宽度为2px cvs.arc(100,100,100,0,Math.PI);//圆心坐标是100,100,半径为100,起始角度为0度,结束角度为180度 cvs.closePath();//结束一个路径 cvs.stroke();//绘制图形以边框样式绘制 cvs.fillStyle=&apos;gray&apos;;//设置填充颜色为灰色 cvs.arc(300,300,80,0,Math.PI/2);//圆心坐标是300,300，半径是80px，起始角度为0，结束角度为90度 cvs.closePath(); cvs.fill();&#125;draw3();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之1绘制线条的有关属性和步骤","slug":"canvas之1绘制线条的有关属性和步骤","date":"2017-06-08T11:44:17.000Z","updated":"2017-09-09T12:26:33.022Z","comments":true,"path":"2017/06/08/canvas之1绘制线条的有关属性和步骤/","link":"","permalink":"http://yoursite.com/2017/06/08/canvas之1绘制线条的有关属性和步骤/","excerpt":"","text":"&lt;canvas id=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt;&lt;/canvas&gt;canvas :H5标签 在页面上绘制图形用的（通常称他画布）canvas只是一个容器，我们用js脚本来控制他&lt;canvas id=&quot;draw&quot; width=&quot;600&quot; height=&quot;500&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; 绘制线条的有关属性和步骤 1.相关属性 1.填充的样式 cvs.fillStyle --&gt;fillStyle`填充样式 cvs.strokeStyle --&gt;strokeStyle笔触样式 主要用来画边框的 cvs.lineWidth --&gt; 边框的宽度 2.绘制图形有两种方式 cvs.fill(); --&gt; 填充样式 cvs.stroke(); --&gt; 边框样式 3.颜色值的四种书写方式 1).颜色名 –&gt;”red” 2).十六进制 –&gt;”#fff” 3).三色值 –&gt;rgb(0,0,0) 4).四色值 –&gt;rgba(0,0,0,0.3) 4.坐标: 1.)以画布为基准,距离画布的上边是y坐标值(top值),距离画布的左边是x坐标值(left值); cvs.moveTo(x,y); –&gt; 起始点坐标 cvs.lineTo(x,y); –&gt; 结束点的坐标 如果没有moveTo就把上一个挨着的lineTo作为起始坐标 例如:假如第一个不是moveTo而是lineTo,那么lineTo就是其实坐标 5.开始和关闭一个路径 cvs.beginPath(); –&gt; 开始一个新的路径 cvs.closePath(); –&gt; 关闭当前路径 注意:加上.closePath会自动闭合 会自动连接起始坐标和结束坐标 6.canvas中的圆角 1).设置线条交汇处的样式 cvs.lineJoin 他有三个属性： 1).尖角miter 2).斜角bevel 3).圆角round 2).设置一条线段两端点的样式 lineCap焦点样式 1)平的butt(默认值) 2.)圆角round 3.)方角square 2.步骤及案例 步骤1.获取出canvas标签,例如:var draw=document.getElementById(&#39;draw&#39;); 步骤2.设置绘制环境–2d 平面图,例如: 12var cvs=draw.getContext(&apos;2d&apos;);//cvs 这个就是你的画板 接下来就可以在cvs上进行绘制 步骤3 案例1:线段 123456789101112function draw1()&#123;var draw=document.getElementById(&apos;draw&apos;);var cvs=draw.getContext(&apos;2d&apos;);cvs.beginPath();cvs.moveTo(50,50);cvs.lineTo(150,50);cvs.closePath();cvs.strokeStyle=&apos;#800080&apos;;cvs.lineWidth=5;cvs.stroke();//以边框的形式显示&#125;draw1(); 案例2:等腰直角三角形 12345678910111213function draw2()&#123; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); cvs.beginPath(); cvs.lineTo(80,120); cvs.lineTo(80,240); cvs.lineTo(200,240); cvs.closePath(); cvs.strokeStyle=&apos;ec568c&apos;; cvs.lineWidth=10; cvs.stroke();&#125;draw2(); 案例3:圆角矩形 12345678910111213function draw3()&#123; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); cvs.beginPath(); cvs.lineCap=&apos;round&apos;; cvs.lineTo(50,50); cvs.lineTo(250,50); cvs.closePath();//关闭就没有圆角效果 cvs.lineWidth=100; cvs.strokeStyle=&apos;#896446&apos;; cvs.stroke();&#125;draw3(); 案例4:圆角三角形 1234567891011121314function draw4()&#123; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); cvs.beginPath(); cvs.lineJoin=&apos;round&apos;;//设置圆角 cvs.moveTo(200,100); cvs.lineTo(100,250); cvs.lineTo(300,250); cvs.closePath(); cvs.lineWidth=50; cvs.strokeStyle=&apos;#896446&apos;; cvs.stroke();&#125;draw4();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]}]}