{"meta":{"title":"高大秀博客","subtitle":null,"description":"本站内容涉及前端开发的相关内容,如Javascript、CSS、HTML、CSS3、较为简单的Node、jQuery插件等,为作者高大秀本人根据自己多年经验总结写成，如有异议欢迎留言，愿与大家共同进步。作者qq号:1260833716","author":"高大秀","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2017-07-26T11:43:03.000Z","updated":"2018-01-24T07:08:21.851Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于文档 Vue官方中文文档：https://cn.vuejs.org/ React官方中文文档：https://discountry.github.io/react/ Webpack文档：https://doc.webpack-china.org/ EsLint中文官网：http://eslint.cn/ React Native中文官网：https://reactnative.cn/ Node.js中文文档：http://nodejs.cn/api/ Git中文：https://git-scm.com/book/zh/v2/ Apizza(api接口文档)注册：http://apizza.cc/account/register 关于我 我的github地址：https://github.com/gaodaxiu0406"},{"title":"gitHub","date":"2017-07-29T15:46:57.000Z","updated":"2017-07-29T15:50:15.010Z","comments":true,"path":"gitHub/index.html","permalink":"http://yoursite.com/gitHub/index.html","excerpt":"","text":""},{"title":"分类目录","date":"2017-07-26T10:46:32.000Z","updated":"2017-08-18T12:14:00.674Z","comments":true,"path":"archive/index.html","permalink":"http://yoursite.com/archive/index.html","excerpt":"","text":""}],"posts":[{"title":"HTML特殊符号总结","slug":"HTML中特殊符号总结","date":"2018-01-26T03:28:23.000Z","updated":"2018-01-29T03:44:19.259Z","comments":true,"path":"2018/01/26/HTML中特殊符号总结/","link":"","permalink":"http://yoursite.com/2018/01/26/HTML中特殊符号总结/","excerpt":"","text":"符号 符号 符号 符号 &amp;aacute; &aacute; &amp;hArr; &hArr; &amp;para; &para; &amp;yacute; &yacute; &amp;Aacute; &Aacute; &amp;harr; &harr; &amp;part; &part; &amp;yen; &yen; &amp;Acirc; &Acirc; &amp;hearts; &hearts; &amp;permil; &permil; &amp;yuml; &yuml; &amp;acirc; &acirc; &amp;hellip; &hellip; &amp;perp; &perp; &amp;Yacute; &Yacute; &amp;acute; &acute; &amp;phi; &phi; &amp;Yuml; &Yuml; &amp;AElig; &AElig; &amp;pi; &pi; &amp;aelig; &aelig; &amp;piv; &piv; &amp;Agrave; &Agrave; &amp;plusmn; &plusmn; &amp;agrave; &agrave; &amp;pound; &pound; &amp;alefsym; &alefsym; &amp;prime; &prime; &amp;alpha; &alpha; &amp;prod; &prod; &amp;Alpha; &Alpha; &amp;prop; &prop; &amp;amp; &amp; &amp;psi; &psi; &amp;and; &and; &amp;Phi; &Phi; &amp;ang; &ang; &amp;Pi; &Pi; &amp;aring; &aring; &amp;Prime; &Prime; &amp;Aring; &Aring; &amp;Psi; &Psi; &amp;bdquo; &bdquo; &amp;iacute; &iacute; &amp;quot; &quot; &amp;zeta; &zeta; &amp;beta; &beta; &amp;icirc; &icirc; &amp;zwj; &zwj; &amp;brvbar; &brvbar; &amp;iexcl; &iexcl; &amp;zwnj; &zwnj; &amp;bull; &bull; &amp;igrave; &igrave; &amp;Zeta; &Zeta; &amp;Beta; &Beta; &amp;image; &image; &amp;infin; &infin; &amp;int; &int; &amp;iota; &iota; &amp;iquest; &iquest; &amp;isin; &isin; &amp;iuml; &iuml; &amp;Iacute; &Iacute; &amp;Icirc; &Icirc; &amp;Igrave; &Igrave; &amp;Iota; &Iota; &amp;Iuml; &Iuml; &amp;clubs; &clubs; &amp;kappa; &kappa; &amp;radic; &radic; &amp;cap; &cap; &amp;Kappa; &Kappa; &amp;rang; &rang; &amp;ccedil; &ccedil; &amp;lambda; &lambda; &amp;raquo; &raquo; &amp;cedil; &cedil; &amp;rarr; &rarr; &amp;cent; &cent; &amp;rArr; &rArr; &amp;chi; &chi; &amp;rceil; &rceil; &amp;circ; &circ; &amp;rdquo; &rdquo; &amp;clubs; &clubs; &amp;real; &real; &amp;cong; &cong; &amp;reg; &reg; &amp;copy; &copy; &amp;rfloor; &rfloor; &amp;crarr; &crarr; &amp;rho; &rho; &amp;cup; &cup; &amp;rlm; &rlm; &amp;curren; &curren; &amp;rsaquo; &rsaquo; &amp;Ccedil; &Ccedil; &amp;rsquo; &rsquo; &amp;Chi; &Chi; &amp;Rho; &Rho; &amp;dagger; &dagger; &amp;lang; &lang; &amp;sbquo; &sbquo; &amp;dArr; &dArr; &amp;laquo; &laquo; &amp;scaron; &scaron; &amp;darr; &darr; &amp;lArr; &lArr; &amp;sdot; &sdot; &amp;deg; &deg; &amp;larr; &larr; &amp;sect; &sect; &amp;delta; &delta; &amp;lceil; &lceil; &amp;shy; &shy; &amp;divide; &divide; &amp;ldquo; &ldquo; &amp;sigma; &sigma; &amp;Dagger; &Dagger; &amp;le; &le; &amp;sigmaf; &sigmaf; &amp;Delta; &Delta; &amp;lfloor; &lfloor; &amp;sim; &sim; &amp;lowast; &lowast; &amp;spades; &spades; &amp;loz; &loz; &amp;sub; &sub; &amp;lrm; &lrm; &amp;sube; &sube; &amp;lsaquo; &lsaquo; &amp;sum; &sum; &amp;lsquo; &lsquo; &amp;sup1; &sup1; &amp;lt; &lt; &amp;sup2; &sup2; &amp;Lambda; &Lambda; &amp;sup3; &sup3; &amp;sup; &sup; &amp;supe; &supe; &amp;szlig; &szlig; &amp;Scaron; &Scaron; &amp;Sigma; &Sigma; &amp;eacute; &eacute; &amp;macr; &macr; &amp;tau; &tau; &amp;ecirc; &ecirc; &amp;mdash; &mdash; &amp;there4; &there4; &amp;egrave; &egrave; &amp;micro; &micro; &amp;theta; &theta; &amp;empty; &empty; &amp;middot; &middot; &amp;thetasym; &thetasym; &amp;emsp; &emsp; &amp;minus; &minus; &amp;thinsp; &thinsp; &amp;ensp; &ensp; &amp;mu; &mu; &amp;thorn; &thorn; &amp;epsilon; &epsilon; &amp;Mu; &Mu; &amp;tilde; &tilde; &amp;equiv; &equiv; &amp;times; &times; &amp;eta; &eta; &amp;trade; &trade; &amp;eth; &eth; &amp;Tau; &Tau; &amp;euml; &euml; &amp;Theta; &Theta; &amp;euro; &euro; &amp;THORN; &THORN; &amp;exist; &exist; &amp;Eacute; &Eacute; &amp;Ecirc; &Ecirc; &amp;Egrave; &Egrave; &amp;Epsilon; &Epsilon; &amp;Eta; &Eta; &amp;ETH; &ETH; &amp;Euml; &Euml; &amp;fnof; &fnof; &amp;nabla; &nabla; &amp;uacute; &uacute; &amp;forall; &forall; &amp;nbsp; &nbsp; &amp;uarr; &uarr; &amp;frac12; &frac12; &amp;ndash; &ndash; &amp;uArr; &uArr; &amp;frac14; &frac14; &amp;ne; &ne; &amp;ucirc; &ucirc; &amp;frac34; &frac34; &amp;ni; &ni; &amp;ugrave; &ugrave; &amp;frasl; &frasl; &amp;not; &not; &amp;uml; &uml; &amp;notin; &notin; &amp;upsih; &upsih; &amp;nsub; &nsub; &amp;upsilon; &upsilon; &amp;ntilde; &ntilde; &amp;uuml; &uuml; &amp;nu; &nu; &amp;Uacute; &Uacute; &amp;Ntilde; &Ntilde; &amp;Ucirc; &Ucirc; &amp;Nu; &Nu; &amp;Ugrave; &Ugrave; &amp;Upsilon; &Upsilon; &amp;Uuml; &Uuml; &amp;gamma; &gamma; &amp;oacute; &oacute; &amp;weierp; &weierp; &amp;ge; &ge; &amp;ocirc; &ocirc; &amp;gt; &gt; &amp;oelig; &oelig; &amp;Gamma; &Gamma; &amp;ograve; &ograve; &amp;oline; &oline; &amp;xi; &xi; &amp;omega; &omega; &amp;Xi; &Xi; &amp;omicron; &omicron; &amp;oplus; &oplus; &amp;or; &or; &amp;ordf; &ordf; &amp;ordm; &ordm; &amp;oslash; &oslash; &amp;otilde; &otilde; &amp;otimes; &otimes; &amp;ouml; &ouml; &amp;Oacute; &Oacute; &amp;Ocirc; &Ocirc; &amp;OElig; &OElig; &amp;Ograve; &Ograve; &amp;Omega; &Omega; &amp;Omicron; &Omicron; &amp;Oslash; &Oslash; &amp;Oslash; &Oslash; &amp;Otilde; &Otilde; &amp;Ouml; &Ouml;","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"ReactNative环境搭建","slug":"ReactNative环境搭建","date":"2018-01-24T07:39:49.000Z","updated":"2018-01-26T03:22:30.352Z","comments":true,"path":"2018/01/24/ReactNative环境搭建/","link":"","permalink":"http://yoursite.com/2018/01/24/ReactNative环境搭建/","excerpt":"","text":"官方中文文档地址’https://reactnative.cn/docs/0.51/getting-started.html‘ 如果是ios并不长，如果是安卓相对繁琐一些 操作系统分为:macOS/Linux/Windows 在macOS下可以开发ios和安卓的，但是Linux/Windows只能开发安卓的(如果工作中老板要你用ReactNative，你尽量和老板申请个mac本) 步骤1.安装Node.js/Homebrew 百度搜索Node.js Mac环境(百度搜索Homebrew) 1-1.Node.js安装 安装后需要配置一下环境变量(我的电脑-属性-高级系统设置-环境变量(path中的数据新增nodejs路径)) 1-1-1.nodejs安装提示 window配置环境变量参考:https://jingyan.baidu.com/article/f3e34a128dc9aff5eb6535dc.html ReactNative和很多开发工具一样，会大量使用命令行工具，建议学习一些基本windows/unix/linux指令(mac和linux下是比较相似的，在windows下是不一样的) 参考:windows下的.bat文件、unix/linux下的.sh文件(dir/ls 列出文件;copy/cp 拷贝;cd/cd 切换目录) 1-1-2.关于Node.js版本(建议使用6以上的版本) 1-1-3.npm的作用和package.json npm是nodejs的包管理器，nodejs是一个开源的环境，所谓包管理器就是取之于开源贡献者的代码，用之于开发者，这样一个桥梁的一个作用。 包管理器主要源自于国外，国内做的比较好的就是淘宝(淘宝镜像)。 1-1-4.关于淘宝镜像的问题 有时候会有一定的同步问题，如果npm install的时候非常慢，建议安装，安装后先移除项目目录下node_modules文件夹12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/list --global 1-2.Homebrew安装 macOS需要安装Homebrew，前提是有Ruby，一般mac自带Ruby(可参考reactnative.cn官方中文文档) 通常情况下Homebrew已经有了，不需要安装 1-3.JDK安装 安卓的版是需要JAVA的，所以要安装JDK 1-3-1.JDK小贴士 目前jdk有两个版本(OPENJDK/Oracle Java JDK)，使用Android Studio开发需要JDK 1-3-2.注意事项 版本差别不大，1.7/1.8应该都可以 JAVA安装成功之后通常需要设置一个JAVA_HOME的环境变量，window参考:https://jingyan.baidu.com/article/f3e34a128dc9aff5eb6535dc.html;MacOS/Linux/Unix通常需要export JAVA_HOME=(java路径) 具体可以百度下。 2.开发工具 2-1.安装Xcode、Android Studio Mac(Xcode):开发ios用Xcode，必须用Mac开发。 Android Studio比较麻烦一些 官方做法：https://developer.android.com (在不翻墙的情况下到该地址下载Android Studio) 非官方做法：百度Android Studio，即可下载 2-2.工具任意以下其中之一 webstore(推荐使用，代码跟踪、代码提示做的比较好) Visual Studio Code Atom 2-3.语法设置 会用react的人都知道，react是使用JSX语法，而ReactNative也是使用JSX语法，在webstore中需要设置成react JSX，否则会有很多报错“webstore打开设置窗口”“JSX语法设置” 2-4.推荐使用Vim编辑器 可结合webstore/Visual Studio Code/Atom 这三款工具使用，特点就是快。 3.难点 3-1.什么是Android SDK 3-2.SDK安装步骤 1) 在AndroidStudio中点开偏好 2) 在搜索框中输入Android SDK 3) 然后勾选需要安装的SDK工具 4) 在SDK Platforms窗口中，选择Show Package Details,然后在Android6.0(Marshmallow)中勾选Google Apis、Android SDK Platform 23、Intel x86 Atom64 System Image以及Google APIs intel x86 Atom64 System Image 5) 在SDK Tools窗口中，选择Show Package Details，然后在Android SDK Build Tools中勾选Android SDK Build-Tools 23.0.1 6) 配置ANDROID_HOME环境变量 在MacOS下，在~/.bash_profile中添加 123export ANDROID_HOME=~/Library/Android/sdkexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/toolsexport PATH=$&#123;PATH&#125;:$&#123;ANDROID_HOME&#125;/platform-tools 在Linux下需要在.bashrc中添加相应内容 在windows下参考https://jingyan.baidu.com/article/f3e34a128dc9aff5eb6535dc.html 3-3.Android模拟器 建议使用Genymotion(建议) 建议使用Genymotion官网注册一个账号(注意:qq邮箱不好使，他不认数字的邮箱，必须是字母的) 下载一个genymotion软件 个人版是免费的，企业版收费 Genymotio实际用的是virtualbox Android Studio自带的AVD(不建议) 如果要在Android Studio中使用AVD必须安装HAXM否则会慢，可以在Android Studio中配置，首先需要安装(配置过程及其复杂) 大概需要安装的有:Android SDK、Android SDK Platform、Performance (Intel &reg; HAXM)、Android Virtual Device 3-4.windows下配置特别提醒 windows下配置较为困难，如果配置完成后发现红屏幕，有各种各样的原因，其中在windows7下通常需要设置Virtualbox的网络最为棘手","categories":[],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://yoursite.com/tags/ReactNative/"}]},{"title":"MongoDB启动与连接","slug":"MongoDB启动与连接","date":"2017-10-06T07:44:33.000Z","updated":"2017-10-07T11:27:00.732Z","comments":true,"path":"2017/10/06/MongoDB启动与连接/","link":"","permalink":"http://yoursite.com/2017/10/06/MongoDB启动与连接/","excerpt":"","text":"什么是MongoDB MongoDB是一个基于分布式文件存储的开源数据库系统 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 MongoDB安装windows安装 Windows官方安装指南 绿色版就是解压之后就可以用 mongodb32位绿色版 http://pan.baidu.com/s/1pLe3vM7 MongoDB64位绿色版 http://pan.baidu.com/s/1cMM9oq mongo客户端绿色版 http://pan.baidu.com/s/1kUIQlUZ Mac官方安装指南 1.先安装homebrew Homebrew简称brew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件 1http://brew.sh/ Homebrew的安装非常简单，打开终端复制、粘贴以下命令，回车，搞定 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 2.使用brew安装mongodb 1brew install mongodb 3.创建数据存放目录 1sudo mkdir -p /data/db 如果提示输入密码请输入正确的密码 4.启动mongodb1sudo mongod &amp; Mac可视化工具可安装Robomongomongodb启动与连接1.windows启动服务器端 1).找到mongodb安装目录,一般是 C:\\Program Files\\MongoDB 2.6 Standard\\bin (这里我下载到了C:\\Users\\Gao\\Downloads\\数据库\\MongoDB这个目录) 2).按下Shift+鼠标右键,选择在此处打开命令窗口 3)在除C盘外的盘符新建一个空目录,例如 D:\\Mongodb\\data(由于我的电脑没有分盘,所以我就建在C盘下了) 在命令行中输入mongod –dbpath=刚创建的空目录,如 1mongod --dbpath=C:\\data 注意：–dbpath后的值表示数据库文件的存储路径,而且后面的路径必须事先创建好，必须已经存在，否则服务开启失败 如果是windows32的系统用户，请加参数 –storageEngine=mmapv1 如 mongod --dbpath=C:\\data --storageEngine=mmapv1 4)再按回车键 如果出现waiting for connections on port 27017就表示启动成功,已经在27017端口上监听了客户端的请求 注意：这个命令窗体绝对不能关,关闭这个窗口就相当于停止了mongodb服务 如果mongoVUE客户端报错 “MongoDB.Bson.BsonObjectId”的类型初始值设定项引发异常 解决方案如下：在window中打开功能里输入regedit,回车打开注册器。然后进入如下路径中 HKEY_LOCAL_MACHINE\\system\\CurrentControlSet\\Control\\Lsa\\FipsAlgorithmPolicy 将enable设置为0 即可。 2.启动客户端连接服务器 1)找到mongodb安装目录,一般是 C:\\Program Files\\MongoDB 2.6 Standard\\bin 2)按下Shift+鼠标右键,选择在此处打开命令窗口 3)命令窗体中输入 mongo –host=127.0.0.1 或者 mongo 按回车键 4)命令窗体中输入 db 按回车键可进入测试 备注：–host后的值表示服务器的ip地址,–host=127.0.0.1 表示的就是本地服务器,每次数据库都会默认连接test数据库 MongoDB基本概念 数据库 MongoDB的单个实例可以容纳多个独立的数据库，比如一个学生管理系统就可以对应一个数据库实例 集合 数据库是由集合组成的,一个集合用来表示一个实体,如学生集合 文档 集合是由文档组成的，一个文档表示一条记录,比如一位同学张三就是一个文档","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"HTTP缓存机制详解(转载)","slug":"HTTP缓存机制详解-转载","date":"2017-09-10T13:42:31.000Z","updated":"2017-09-10T16:10:47.734Z","comments":true,"path":"2017/09/10/HTTP缓存机制详解-转载/","link":"","permalink":"http://yoursite.com/2017/09/10/HTTP缓存机制详解-转载/","excerpt":"","text":"原文链接http://www.cnblogs.com/chenqf/p/6386163.html","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"React.createClass和extends Component的区别(转载)","slug":"React-createClass和extends-Component的区别","date":"2017-09-09T10:06:01.000Z","updated":"2017-09-09T10:16:01.254Z","comments":true,"path":"2017/09/09/React-createClass和extends-Component的区别/","link":"","permalink":"http://yoursite.com/2017/09/09/React-createClass和extends-Component的区别/","excerpt":"","text":"createClass本质上是一个工厂函数，extends的方式更加接近最新的ES6规范的class写法。两种方式在语法上的差别主要体现在方法的定义和静态属性的声明上。createClass方式的方法定义使用逗号,隔开，因为creatClass本质上是一个函数，传递给它的是一个Object；而class的方式定义方法时务必谨记不要使用逗号隔开，这是ES6 class的语法规范。 React.createClass和extends Component的区别主要在于： 语法区别 propType 和 getDefaultProps 状态的区别 this区别 Mixins 1.语法区别 React.createClass 1234567891011import React from &apos;react&apos;;const Contacts = React.createClass(&#123; render() &#123; return ( &lt;div&gt;&lt;/div&gt; ); &#125;&#125;);export default Contacts; React.Component 1234567891011121314import React from &apos;react&apos;;class Contacts extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;div&gt;&lt;/div&gt; ); &#125;&#125;export default Contacts; 后一种方法使用ES6的语法，用constructor构造器来构造默认的属性和状态。 2.propType和getDefaultProps React.createClass:通过proTypes对象和getDefaultProps()方法来设置和获取props. 12345678910111213141516171819import React from &apos;react&apos;;const Contacts = React.createClass(&#123; propTypes: &#123; name: React.PropTypes.string &#125;, getDefaultProps() &#123; return &#123; &#125;; &#125;, render() &#123; return ( &lt;div&gt;&lt;/div&gt; ); &#125;&#125;);export default Contacts; React.Component：通过设置两个属性propTypes和defaultProps 123456789101112131415import React form &apos;react&apos;;class TodoItem extends React.Component&#123; static propTypes = &#123; // as static property name: React.PropTypes.string &#125;; static defaultProps = &#123; // as static property name: &apos;&apos; &#125;; constructor(props)&#123; super(props) &#125; render()&#123; return &lt;div&gt;&lt;/div&gt; &#125;&#125; 3.状态的区别 React.createClass：通过getInitialState()方法返回一个包含初始值的对象 123456789101112import React from &apos;react&apos;; let TodoItem = React.createClass(&#123; // return an object getInitialState()&#123; return &#123; isEditing: false &#125; &#125; render()&#123; return &lt;div&gt;&lt;/div&gt; &#125; &#125;) React.Component：通过constructor设置初始状态 123456789101112import React from &apos;react&apos;; class TodoItem extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; // define this.state in constructor isEditing: false &#125; &#125; render()&#123; return &lt;div&gt;&lt;/div&gt; &#125; &#125; 4.this区别 React.createClass：会正确绑定this 1234567891011121314import React from &apos;react&apos;;const Contacts = React.createClass(&#123; handleClick() &#123; console.log(this); // React Component instance &#125;, render() &#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt;&lt;/div&gt;//会切换到正确的this上下文 ); &#125;&#125;);export default Contacts; React.Component：由于使用了 ES6，这里会有些微不同，属性并不会自动绑定到 React 类的实例上。 1234567891011121314151617181920import React from &apos;react&apos;;class TodoItem extends React.Component&#123; constructor(props)&#123; super(props); &#125; handleClick()&#123; console.log(this); // null &#125; handleFocus()&#123; // manually bind this console.log(this); // React Component Instance &#125; handleBlur: ()=&gt;&#123; // use arrow function console.log(this); // React Component Instance &#125; render()&#123; return &lt;input onClick=&#123;this.handleClick&#125; onFocus=&#123;this.handleFocus.bind(this)&#125; onBlur=&#123;this.handleBlur&#125;/&gt; &#125;&#125; 我们还可以在 constructor 中来改变 this.handleClick 执行的上下文，这应该是相对上面一种来说更好的办法，万一我们需要改变语法结构，这种方式完全不需要去改动 JSX 的部分： 123456789101112131415161718import React from &apos;react&apos;;class Contacts extends React.Component &#123; constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; console.log(this); // React Component instance &#125; render() &#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt;&lt;/div&gt; ); &#125;&#125;export default Contacts; 5.Mixins 如果我们使用 ES6 的方式来创建组件，那么 React mixins 的特性将不能被使用了。123456789101112React.createClass：使用 React.createClass 的话，我们可以在创建组件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组的形式赋给 mixins。import React from &apos;react&apos;;let MyMixin = &#123; doSomething()&#123;&#125;&#125;let TodoItem = React.createClass(&#123; mixins: [MyMixin], // add mixin render()&#123; return &lt;div&gt;&lt;/div&gt; &#125;&#125;) 原文链接https://segmentfault.com/a/1190000005863630","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"JavaScript中toStirng()与Object.prototype.toString.call()方法浅谈转载","slug":"JavaScript中toStirng-与Object-prototype-toString-call-方法浅谈","date":"2017-09-09T06:38:40.000Z","updated":"2017-09-09T06:49:12.760Z","comments":true,"path":"2017/09/09/JavaScript中toStirng-与Object-prototype-toString-call-方法浅谈/","link":"","permalink":"http://yoursite.com/2017/09/09/JavaScript中toStirng-与Object-prototype-toString-call-方法浅谈/","excerpt":"","text":"一、toString()是一个怎样的方法？它是能将某一个值转化为字符串的方法。然而它是如何将一个值从一种类型转化为字符串类型的呢？通过下面几个例子，我们便能获得答案： 1.将boolean类型的值转化为string类型： 12console.log(true.toString());//&quot;true&quot;console.log(false.toString());//&quot;false&quot; 2.将string类型按其字面量形式输出： 12var str = &quot;test123y&quot;;console.log(str.toString());//&quot;test123y&quot; 3.将Object类型转化成string类型（JavaScript原生的Array类型、Date类型、RegExp类型以及Number、Boolean、String这些包装类型都是Object的子类型）：自定义Object类型（没有重新定义toString方法）： 12var obj = &#123;name:&quot;Tom&quot;, age:18&#125;;console.log(obj.toString());//&quot;[object Object]&quot;此时调用的是从Object继承来的原始的toString()方法 接下来的三个例子都是以重写的方式实现了toString()方法； 1.Array类型： 12var arr = [&quot;tom&quot;,12,&quot;rose&quot;,18];console.log(arr.toString());//&quot;tom,12,rose,18&quot; 2.RegExp类型 12var patten = new RegExp(&quot;\\\\[hbc\\\\]at&quot;, &quot;gi&quot;);console.log(patten.toString());//&quot;/\\[hbc\\]at/gi&quot; 3.Date类型 12var date = new Date(2014,02,26);//注意这种格式创建的日期，其月份是3月console.log(date.toString());//&quot;Wed Mar 26 2014 00:00:00 GMT+0800&quot;输出格式因浏览器不同而不同，此为firefox的输出格式； 4.Number类型也是以重写的方式实现toString()方法的，请看以下例子： (1)它可以接受一个整数参数，并将调用这个方法的数值转化成相应进制的字符串： 12345var num = 16;console.log(num.toString(2));//10000 二进制console.log(num.toString(8));//20 八进制console.log(num.toString(16));//10 十六进制console.log(num.toString(5));//31 虽然没有五进制，但是这样传参是可以被toString()方法接受的 (2)再看下面的代码： 1234567console.log(1.toString());//这种写法会报错语法错误，但是下面的写法都是合法的；console.log((1).toString());//&quot;1&quot;console.log(typeof (1).toString());//stringconsole.log(1..toString());//&quot;1&quot;console.log(typeof (1).toString());//stringconsole.log(1.2.toString());//&quot;1&quot;console.log(typeof (1).toString());//string 这是因为javascript引擎在解释代码时对于“1.toString()”认为“.”是浮点符号，但因小数点后面的字符是非法的，所以报语法错误； 而后面的“1..toString()和1.2.toStirng()”写法，javascript引擎认为第一个“.”小数点，的二个为属性访问语法，所以都能正确解释执行； 对于“(1).toStirng()”的写法，用“()”排除了“.”被视为小数点的语法解释，所以这种写法能够被解释执行； (3)纯小数的小数点后面有连续6或6个以上的“0”时，小数将用e表示法进行输出； 1234var num = 0.000006;//小数点后面有5个“0”console.log(num.toString());//&quot;0.000006&quot;var num = 0.0000006;//小数点后面有6个“0”console.log(num.toString());//&quot;6e-7&quot; (4)浮点数整数部分的位数大于21时，输出时采用e表示法； 12var num = 1234567890123456789012;console.log(num.toString());//&quot;1.2345678901234568e+21&quot; 看到这里大家难免会有些疑问，这些基本的数据类型的值都是常量，而常量是没有方法的，为什么能够调用方法呢？答案是这样的，五种基本类型除了null、undefined以外都有与之对应的特殊的引用类型——包装类型。当代码被解释执行时，底层会对基本类型做一个类型转换，即将基本类型转换成引用类型，这样就可以调用相应引用类型有权访问到的方法。 二、toString()方法定义在何处？ 运行以下代码： 12345678var pro = Object.prototype;var pr = pro.__proto__;//ie11之前版本不支持该属性console.log(typeof pro);//&quot;object&quot;console.log(String(pro));//&quot;[object Object]&quot;console.log(pro.hasOwnProperty(&quot;toString&quot;));//trueconsole.log(typeof pr);//&quot;object&quot;console.log(String(pr));//&quot;null&quot;console.log(pr.hasOwnProperty(&quot;toString&quot;));//报错 由此可知，toString()定义在Object.prototype上； 三、使用Object.prototype上的原生toString()方法判断数据类型，使用方法如下：Object.prototype.toString.call(value) 1.判断基本类型： 12345Object.prototype.toString.call(null);//”[object Null]”Object.prototype.toString.call(undefined);//”[object Undefined]”Object.prototype.toString.call(“abc”);//”[object String]”Object.prototype.toString.call(123);//”[object Number]”Object.prototype.toString.call(true);//”[object Boolean]” 2.判断原生引用类型： 函数类型 12Function fn()&#123;console.log(“test”);&#125;Object.prototype.toString.call(fn);//”[object Function]” 日期类型 12var date = new Date();Object.prototype.toString.call(date);//”[object Date]” 数组类型 12var arr = [1,2,3];Object.prototype.toString.call(arr);//”[object Array]” 正则表达式 12var reg = /[hbc]at/gi;Object.prototype.toString.call(arr);//”[object Array]” 自定义类型 123456function Person(name, age) &#123; this.name = name; this.age = age;&#125;var person = new Person(&quot;Rose&quot;, 18);Object.prototype.toString.call(arr); //”[object Object]” 很明显这种方法不能准确判断person是Person类的实例，而只能用instanceof 操作符来进行判断，如下所示： 1console.log(person instanceof Person);//输出结果为true 3.判断原生JSON对象： 12var isNativeJSON = window.JSON &amp;&amp; Object.prototype.toString.call(JSON);console.log(isNativeJSON);//输出结果为”[object JSON]”说明JSON是原生的，否则不是； 注意：Object.prototype.toString()本身是允许被修改的，而我们目前所讨论的关于Object.prototype.toString()这个方法的应用都是假设toString()方法未被修改为前提的。 本文所讨论内容多参考于《JavaScrip高级编程》第三版，另因个人水平有限，如有描述不当之处还请高手指正。 原文链接http://www.jianshu.com/p/5c6503279685","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"getter&setter","slug":"getter-setter","date":"2017-09-05T10:11:19.000Z","updated":"2017-09-05T10:20:34.009Z","comments":true,"path":"2017/09/05/getter-setter/","link":"","permalink":"http://yoursite.com/2017/09/05/getter-setter/","excerpt":"","text":"一般在书上看到都解释都是 把成员变量直接暴露在外不符合OOP的封装性原则，不安全，应该使用getter和setter方法来取值和赋值。但是没有解释为什么不符合OOP的封装性原则，为什么不安全，一个成员变量不就是取值和赋值这么两个操作吗，还能干什么，暴露出来又怎么样？ 的确可以暴露，如果 所有内外代码都是你自己写； 这个模块再也不改了； 不会继承它，或者继承但不改变语义。 David John Wheeler有一句名言：“All problems in computer science can be solved by another level of indirection(翻译:“计算机科学中的所有问题都可以通过另一种间接方式来解决).”getter、setter就是个很好的中间层。 直接摘录stackoverflow上一个不错的总结： oop - Why use getters and setters? 1.这两个方法可以方便增加额外功能（比如验证）。 2.内部存储和外部表现不同。 3.可以保持外部接口不变的情况下，修改内部存储方式和逻辑。 4.任意管理变量的生命周期和内存存储方式。提供一个debug接口。 5.能够和模拟对象、序列化乃至WPF库等融合。 6.允许继承者改变语义。 7.可以将getter、setter用于lambda表达式。（大概即作为一个函数，参与函数传递和运算） 8.getter和setter可以有不同的访问级别。 lambda表达式 Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。 lambda [&#39;læmdə] 希腊字母的第11个λ expression [ɪkˈspreʃn] 表达 abstraction [əb&#39;strækʃ(ə)n] 抽象概念以下为转载: Compiling the list up here at the top of what seemed winners to me, from the viewpoint of a Java web dev:(从Java web开发人员的角度来看，在我看来是赢家的列表上面列出了这个列表:) 1.When you realize you need to do more than just set and get the value, you don’t have to change every file in the codebase.当您意识到您需要做的不仅仅是设置和获取值时，您不必更改代码库中的每个文件。 2.You can perform validation here.您可以在这里执行验证。 3.You can change the value being set.您可以更改设置的值。 4.You can hide the internal representation. getAddress() could actually be getting several fields for you.您可以隐藏内部表示。getAddress()实际上可以为您获取多个字段。 5.You’ve insulated your public interface from changes under the sheets.您已经将您的公共接口与表单下的更改隔离了。 6.Some libraries expect this. Reflection, serialization, mock objects.一些图书馆预计。反射,序列化,模拟对象。 7.Inheriting this class, you can override default functionality.继承这个类，您可以覆盖默认的功能。 8.You can have different access levels for getter and setter.对于getter和setter，您可以有不同的访问级别。 9.Lazy loading.延迟加载；懒装载；懒加载 10.People can easily tell you didn’t use Python.人们可以很容易地告诉您，您没有使用Python。 参考链接: https://stackoverflow.com/questions/1568091/why-use-getters-and-setters https://www.zhihu.com/question/21401198/answer/18113707","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"ios和android 浏览器适配问题总结","slug":"ios和android-浏览器适配问题总结","date":"2017-09-03T10:14:04.000Z","updated":"2017-09-03T10:48:53.108Z","comments":true,"path":"2017/09/03/ios和android-浏览器适配问题总结/","link":"","permalink":"http://yoursite.com/2017/09/03/ios和android-浏览器适配问题总结/","excerpt":"","text":"1.防止手机中网页放大和缩小1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0&quot; /&gt; 2.安卓浏览器看背景图片,有些设备会模糊? 用同等比例的图片在PC机上很清楚，但是手机上很模糊，原因是什么呢？ 经过研究,发现是devicePixelRatio作怪，因为手机分辨率太小，如果按照分辨率来显示网页，这样字会非常小，所以苹果当初就把iPhone 4的960640分辨率，在网页里只显示了480320，这样devicePixelRatio＝2。现在android比较乱，有1.5的，有2的也有3的。 想让图片在手机里显示更为清晰，必须使用2x的背景图来代替img标签（一般情况都是用2倍）。 例如一个div的宽高是100，背景图必须得宽高是200，然后background-size:contain;这样显示出来的图片就比较清晰了。123456background:url(../images/icon/all.png) no-repeat center center;-webkit-background-size:50px 50px;background-size: 50px 50px;display:inline-block;width:100%;height:50px; 3.一些情况下对非可点击元素(如label/span)监听click事件，ios下不会触发 解决方案:css增加cursor:pointer; 4.在ios和andriod中,audio元素和video元素无法自动播放 这个不是 BUG，由于自动播放网页中的音频或视频，会给用户带来一些困扰或者不必要的流量消耗，所以苹果系统和安卓系统通常都会禁止自动播放和使用 JS 的触发播放，必须由用户来触发才可以播放。 解决方法思路:先通过用户 touchstart 触碰,触发播放并暂停(音频开始加载,后面用 JS 再操作就没问题了)。1234document.addEventListener(&apos;touchstart&apos;,function() &#123; document.getElementsByTagName(&apos;audio&apos;)[0].play(); document.getElementsByTagName(&apos;audio&apos;)[0].pause();&#125;); 5.fixed定位缺陷 ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位, android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位 , ios4下不支持position:fixed; 解决方案:可用iScroll插件解决这个问题 6.Input的placeholder会出现文本位置偏上的情况 PC端设置line-height等于height能够对齐，而移动端仍然是偏上 解决方案:设置line-height:normal; 7.圆角bug 某些Android手机圆角失效 解决方案:1background-clip:padding-box; 8.IOS中input键盘事件keyup、keydown、keypress支持不是很好 问题是这样的，用input search做模糊搜索的时候，在键盘里面输入关键词，会通过ajax后台查询，然后返回数据，然后再对返回的数据进行关键词标红。用input监听键盘keyup事件，在安卓手机浏览器中是可以的，但是在ios手机浏览器中变红很慢，用输入法输入之后，并未立刻响应keyup事件，只有在通过删除之后才能相应！ 解决办法:可以用html5的oninput事件去代替keyup,然后就达到类似keyup的效果！123456&lt;input type=&quot;text&quot; id=&quot;testInput&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;document.getElementById(&apos;testInput&apos;).addEventListener(&apos;input&apos;,function(e)&#123; var value = e.target.value;&#125;);&lt;/script&gt; 9.部分机型存在type为search的input,自带close按钮样式修改方法; 有些机型的搜索input控件会自带close按钮(一个伪元素)，而通常为了兼容所有浏览器，我们会自己实现一个，此时去掉原生close按钮的方法为: 123#Search::-webkit-search-cancel-button&#123; display:none;&#125; 如果想使用原生close按钮，又想使其符合设计风格，可以对这个伪元素的样式进行修改。 10.手机浏览器独有的四个事件 onTouchmove,ontouchend,ontouchstart,ontouchcancel 11.为什么要用Zepto? jquery适用于PC端桌面环境，桌面环境更加复杂，jquery需要考虑的因素非常多，尤其表现在兼容性上面，相对于PC端，移动端的发展都远不及PC端,手机上的带宽永远比不上pc端。pc端下载jquery到本地只需要1~3秒（90+K），但是移动端就慢了很多，2G网络下你会看到一大片空白网页在加载，相信用户第二次就没打开的欲望了。zepto解决了这个问题，只有不到10K的大小，2G网络环境下也毫无压力，表现不逊色于jquery。 IOS移动端click事件300ms的延迟响应 详解地址https://gaodaxiu0406.github.io/2017/07/28/%E7%A7%BB%E5%8A%A8%E7%AB%AFclick300-380ms%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98/,这是之前做的关于这个问题的详细讲解地址 点击穿透问题,input、select、a等元素可以被点击和focus 这个在特定需求下才会有，因此如果没有类似问题的可以不看。首先需求是浮层操作，在手机上被遮罩的元素依然可以获取focus、click、change)，有两种解决方案： 1.是通过层显示以后加入对应的class名控制，截断显示层下方可获取焦点元素的事件获取 2.是通过将可获取焦点元素加入的disabled属性，也可以利用属性加dom锁定的方式（disabled的一种变换方式）","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"vertical-align","slug":"vertical-align","date":"2017-09-01T12:25:47.000Z","updated":"2017-09-05T11:32:16.941Z","comments":true,"path":"2017/09/01/vertical-align/","link":"","permalink":"http://yoursite.com/2017/09/01/vertical-align/","excerpt":"","text":"vertical-align 改变基线对齐方式 vertical-align: top; 顶部对齐 vertical-align: bottom; 底部对齐 vertical-align: middle; 中部对齐 值 描述 长度 通过距离升高（正值）或降低（负值）元素。’0cm’等同于’baseline’ 百分值 – % 通过距离（相对于1line-height1值的百分大小）升高（正值）或降低（负值）元素。’0%’等同于’baseline’ baseline 默认。当前元素的基线与父元素的基线对齐。 sub 降低元素的基线到父元素合适的下标位置。 super 升高元素的基线到父元素合适的上标位置。 top 所有平级元素,去找最高(高度最高)元素的顶部进行对齐 text-top 把元素的顶端与父元素内容区域的顶端对齐。 middle 所有平级元素,去找最高(高度最高)元素的中部进行对齐 bottom 所有平级元素,去找最高(高度最高)元素的底部进行对齐 text-bottom 把元素的底端与父元素内容区域的底端对齐。 inherit 采用父元素相关属性的相同的指定值 浏览器支持 所有浏览器都支持 vertical-align 属性。 注释：任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 “inherit”。 深入理解line-height与vertical-align推荐地址:http://www.cnblogs.com/xiaohuochai/p/5271217.html","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS盒子模型(border画三角形)及常见兼容问题解决方案","slug":"CSS盒子模型(border画三角形)及常见兼容问题解决方案","date":"2017-08-21T06:28:00.000Z","updated":"2017-09-10T13:49:11.916Z","comments":true,"path":"2017/08/21/CSS盒子模型(border画三角形)及常见兼容问题解决方案/","link":"","permalink":"http://yoursite.com/2017/08/21/CSS盒子模型(border画三角形)及常见兼容问题解决方案/","excerpt":"","text":"每一个元素在html中都是一个盒子,用来装其他盒子或者是内容 可以将html页面看做是一个仓库,仓库中从上到下摆了很多箱子,易碎品(盒子和盒子之间要有间距 内容和盒子之间要有填充 盒子本身要有厚度) 宽高属性 1.height: 100%; 指的是继承父级元素内容的高度 2.width: 100%; 指的是继承父级元素内容的宽度 特性 1.父子关系的时候,在设置margin值的时候,一般只设置上和左,不会设置下和右 2.盒子自身的宽度是由左侧边框的宽度+左侧内边距+内容的宽度+右侧内边距+右侧边框的宽度: 1ALLwidth=(border-left-width)+(padding-left)+width+(padding-right)+(border-right-width) padding和margin123456padding:1px 2px 3px 4px;//上 右 下 左 //top right bottom leftpadding:1px 2px 3px;//上 左右 下 //top left/right bottompadding:1px 2px;//上下 左右 //top/bottom left/right border12345678910111213141516border-top-width: 1px; //上边框的宽度border-top-style: solid; //上边框的样式border-top-color: red; //上边框的颜色border-color:red green yellow pink;//上 右 下 左//上边框红色 右边框绿色 下边框黄色 左边框粉色border-color:red green yellow;//上 左右 下//上边框红色 左右边框绿色 下边框黄色border-color:red green;//上下 左右//上下边框红色 左右边框绿色//合并缩写设置:border-top:1px solid pink;//上边框1px 实线 粉色border-bottom:1px solid pink;border-right:1px solid pink;border-left:1px solid pink;border:1px solid pink; 利用border画三角形123456789&lt;style&gt; div&#123; border:100px solid/* red*/; /*border-color: yellow red blue pink;*/ border-color: black transparent transparent; /*transparent透明的*/ width: 0; &#125;&lt;/style&gt; “利用border画三角形” 常见问题解决方案1.margin支持负值 margin-left和margin-top为负值的时候 跑出浏览器的部分会被吃掉,不会撑开整个页面. 2.margin-top的传递问题 如果父级没有padding-top或border-top值得时候,子元素设置margin-top值,会将这个值传递给父元素 12345678910111213141516171819202122232425262728&lt;style&gt; html,body,div&#123; padding: 0; margin: 0; background: blue; &#125; .box3&#123; width: 300px; height: 300px; background-color: green; &#125; .parent&#123; width: 200px; height: 200px; background-color: red; &#125; .son&#123; width: 100px; height: 100px; background-color: yellow; /*margin-top: 20px;*/ &#125;&lt;/style&gt;&lt;div class=&quot;box3&quot;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 此时:在IE5~11,以及谷歌浏览器中的显示都是一致的,如下图(图片以IE浏览器截图为主) 当给子元素.son设置margin-top:20px;值后 IE5~7中并没有出现margin值的传递问题(IE7同IE5,这里就没有截图了) IE8~11以及谷歌中均出现margin-top值传递问题 解决方法:方法一) 给父级元素一个属性,overflow:hidden;- 弊端: - overflow:hidden;有溢出隐藏的含义,若给父级元素添加这个属性,子级元素超出父级盒子部分将不能显示,例如子级元素的阴影 方法二) 将子级元素的margin-top值去掉,改成父级元素的padding-top值(建议使用这个方法)- 但是此方法也有弊端: - IE5中父级盒子的高度并没有改变 ![Alt margin-top传递问题](/img/margin-top传递问题5.png) - IE7~11及谷歌浏览器中,父级盒子的高度都增加了20px; ![Alt margin-top传递问题](/img/margin-top传递问题6.png) 方法三) 给父级元素上添加一个透明的border处理 弊端: 在IE5~7中确实解决了问题 但是在IE8~11及谷歌浏览器中仍然存在margin-top的传递问题 3.margin-left/margin-right 在ie6中会双倍 当元素浮动的时候,有左右的外边距,有时候ie6会出现双倍边距的问题 解决方案:解决双边距这个方法叫css hack方案一). 给这个元素添加overflow:hidden;方案二). 写ie6的兼容方式,例如:123456div&#123;float:left;margin-left:10px !important;_margin-left:5px;&lt;!-- 当浏览器是ie6的时候 读取_margin-left:5px;这句话 --&gt;&#125; 注意:!important出现在css里面的时候,这个属性会覆盖掉所有之前设置的样式权重最大,比id选择器还大 overflow盒子内容多余部分的处理方式 overflow:hidden; 直接将多余隐藏 overflow:auto; 如果有多余部分出现滚动条,如果没有就不出现 overflow:scroll; 不论是否有多余部分,都会出现滚动条","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"box-shadow&text-shadow","slug":"box-shadow","date":"2017-08-20T09:48:16.000Z","updated":"2017-09-03T10:11:39.016Z","comments":true,"path":"2017/08/20/box-shadow/","link":"","permalink":"http://yoursite.com/2017/08/20/box-shadow/","excerpt":"","text":"box-shadow 属性向框添加一个或多个阴影 相关小项目地址:https://github.com/gaodaxiu0406/HEXOcase(CSS/小项目练习) 语法CSS语法1box-shadow: h-shadow v-shadow blur spread color inset; 注释 box-shadow 向框添加一个或多个阴影。该属性是由逗号分隔的阴影列表，每个阴影由 2-4 个长度值、可选的颜色值以及可选的 inset 关键词来规定。省略长度的值是 0。 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅 CSS 颜色值。 inset 可选。将外部阴影 (outset) 改为内部阴影。 1box-shadow: 10px 20px 30px 40px #000 inset; JavaScript语法1object.style.boxShadow=&quot;10px 10px 5px #888888&quot; text-shadow语法CSS语法1text-shadow: h-shadow v-shadow blur color; 注释 text-shadow 属性向文本添加一个或多个阴影。该属性是逗号分隔的阴影列表，每个阴影有两个或三个长度值和一个可选的颜色值进行规定。省略的长度是 0。 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊的距离。 color 可选。阴影的颜色。参阅 CSS 颜色值。 1text-shadow: 10px 20px 30px #000;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"display","slug":"display","date":"2017-08-20T09:47:11.000Z","updated":"2017-09-05T10:34:28.412Z","comments":true,"path":"2017/08/20/display/","link":"","permalink":"http://yoursite.com/2017/08/20/display/","excerpt":"","text":"根据这个属性可以将元素分成不同的类型,也会显示出不同的状态,例如属性值为block的时候,这个元素会独占一行,如果属性值为inline的时候,所有这个属性值得元素都会在一行显示,属性值为none,元素会在页面上消失. 所有元素都有天生自带的display属性和属性值,叫做内置属性 display:block; 块级元素(块状元素) 特点: 独占一行,在所在父元素内依次向下排列,从左上角开始 宽度在不设置的情况下,宽度继承父级元素内容的宽,高度由本身内容决定 可以直接设置盒子模型的所有属性(width,height,padding,border,margin) 可以嵌套其他元素(p,dt,h1-h6不能嵌套块级) dt/p 不能嵌套其他块级元素,可以嵌套行内元素等 永远会在父级盒子的左上角开始排布,从上到下排. 人为设置的样式要比自带的样式权重高块级元素这些特点,我们将其称作BFC(Block Fomatting Context–&gt;块级盒子在上下文中的渲染模式) display:inline; 行内元素 特点: 在一行显示 不能设置宽度 高度 padding margin的上下值设置不生效,左右值生效 默认宽度高度是本身内容的宽高 几个行内元素默认的垂直方向的对齐方式是基线对齐 在编辑代码时,如果行内元素之间有回车或者空格,那么在页面显示的时候,就会默认有间隙() 将父级的font-size设置为0,可以解决这个问题. 行内元素不能嵌套块级元素 display:inline-block; 行内块级元素 特点: 在一行显示 可以直接设置宽度高度padding、margin值 默认宽度高度是本身内容的宽高 几个行内元素默认的垂直方向对齐方式是基线对齐 在编辑代码时,如果行内元素之间有回车或者空格,那么在页面显示的时候,就会默认有间隙 将父级的font-size设置为0,可以解决这个问题. 行内元素不能嵌套块级元素 vertical-align改变行内元素和行内块级元素的基线对其方式 top 所有平级元素,去找最高(高度最高)元素的顶部进行对齐 bottom 所有平级元素,去找最高(高度最高)元素的底部进行对齐 middle 所有平级元素,去找最高(高度最高)元素的中部进行对齐 length(数值) px 或 % 改变对齐方式的时候,所有元素都要添加vertical-align这个属性 display:none; 将这个元素在页面上隐藏起来 如何再让设置display:none;的元素显示出来? 将none用其他的属性替换 例如:重新设置display属性为==&gt;display:block;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HEXO主题设置","slug":"HEXO主题设置","date":"2017-07-31T14:13:32.000Z","updated":"2017-08-21T10:26:49.598Z","comments":true,"path":"2017/07/31/HEXO主题设置/","link":"","permalink":"http://yoursite.com/2017/07/31/HEXO主题设置/","excerpt":"","text":"目前使用的主题是：huno 在博客的根目录下（即上一篇文章基于GitHub创建自己的博客https://gaodaxiu0406.github.io/2017/04/25/%E5%9F%BA%E4%BA%8EGitHub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/中提到的 HEXO 文件夹下） 克隆主题 克隆主题1git clone git://github.com/someus/huno.git themes/huno 提示:huno的github地址:https://github.com/gaodaxiu0406/huno 执行：1vim _config.yml 执行此命令后可以对此文档进行编辑 输入o进入编辑状态 将 theme 对应的值进行修改1theme: huno 修改完成 按esc键退出编辑状态 再输入:wq退出编辑窗口模式 自动部署1npm install hexo-deployer-git --save 发布1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 稍等片刻看一下自己的博客主页，你想要的效果就出现了。也可以在github或百度中搜索更多主题，挑选自己喜欢的主题进行修改，只要你快乐就好 主题配置 现在主题是更改过来了，但还有许多细节需要处理，比如说你需要修改头像等等。 每个人的设置风格不同,但基本的设置在你下载的主题中的README文件中都有介绍,你可以按照文件中的介绍配置属于自己的博客。动气手来，让你的博客亮起来 返回上篇:基于GitHub创建自己的博客https://gaodaxiu0406.github.io/2017/04/25/%E5%9F%BA%E4%BA%8EGitHub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","categories":[],"tags":[{"name":"基于GitHub创建自己的HEXO博客","slug":"基于GitHub创建自己的HEXO博客","permalink":"http://yoursite.com/tags/基于GitHub创建自己的HEXO博客/"}]},{"title":"2.react轮播图项目开写","slug":"2-react轮播图项目开写","date":"2017-07-30T17:49:58.000Z","updated":"2017-09-09T12:26:32.998Z","comments":true,"path":"2017/07/31/2-react轮播图项目开写/","link":"","permalink":"http://yoursite.com/2017/07/31/2-react轮播图项目开写/","excerpt":"","text":"关于react轮播图的源码,无缝版已上传至github,https://github.com/gaodaxiu0406/React-Slider 用react+webpack写一个的轮播图项目(项目配置请看上篇react轮播图项目配置及原理概要) 先将整个文件写在一个文件中,1.画结构 新建一个components文件夹 components文件夹下新建Slider.js文件和Slider.less文件(Slider.less文件是用来给Slider.js写样式的) 2.在indix.js中引入组件 渲染到页面中 打开src文件夹中的index.html文件 1&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 2-1).在这个id为root的标签中渲染元素 2-2).回到index.js中,写一个轮播图组件，渲染到index.html中 12345678910import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import Slider from &apos;./components/Slider&apos;;let images=[ &#123;src:require(&apos;./images/1.jpg&apos;)&#125;, &#123;src:require(&apos;./images/2.jpg&apos;)&#125;, &#123;src:require(&apos;./images/3.jpg&apos;)&#125;, &#123;src:require(&apos;./images/4.jpg&apos;)&#125;];ReactDOM.render(&lt;Slider images=&#123;images&#125;/&gt;,document.querySelector(&apos;#root&apos;)); 解释1)引入React，引入ReactDOM，引入Slider组件 然后通过ReactDOM.render将Slider组件渲染到index.html的id为root的div标签中 解释2)Slider组件需要图片参数 src文件夹下新建一个images文件夹，存入轮播的图片 将图片路径通过require存入images数组中 通过组件Slider标签将所需的images参数传入组件Slider(让images参数变量等于images数组) 3.开始写Slider.js中的代码 需要默认导出一个组件Slider供外面文件(index.js)调用;还需要接收一个images属性进行轮播 1234567891011121314151617181920import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;require(&apos;./Slider.less&apos;);export default class Slider extends React.Component&#123; render()&#123; let images=this.props.images; return( &lt;div className=&quot;slider-wrapper&quot;&gt; &lt;ul className=&quot;sliders&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;li className=&quot;slider&quot;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125; 1)require(&#39;./Slider.less&#39;);–&gt;这里引入Slider.less用import和require都是一样的效果，都是加载一个模块的意思,模块可能是图片，可能是less/css/js/json文件,都可以–&gt;在webpack中一切皆模块,不管是什么资源，都可以作为模块来加载 2)li的数量取决于images数据,images中有几张图片，就有几个li 在render中let一个变量images来接收index.js传入的images,然后用map方法遍历整个数组 在Slider.less中写好轮播图的样式 123456789101112131415161718192021222324252627*&#123; padding: 0; margin: 0;&#125;ul,li&#123; list-style: none;&#125;.wrapper&#123; width: 400px; height: 400px; position: relative; margin: 30px auto; .sliders&#123; height: 400px; position: absolute; left:0; .slider&#123; float: left; width: 400px; height: 400px; img&#123; width: 100%; height: 100%; &#125; &#125; &#125;&#125; 宽高为400px的轮播图 4.写配置文件 在webpack.config.js中加loaders 1234567module:&#123; loaders:[ &#123;test:/\\.js$/,loader:&apos;babel-loader&apos;,exclude:/node_modules/&#125;, &#123;test:/\\.less$/,loader:&apos;style-loader!css-loader!less-loader&apos;&#125;, &#123;test:/\\.(jpg|png|gif)$/,loader:&apos;url-loader&apos;&#125; ] &#125; babel默认情况下什么都不做，需要一个配置文件.babelrc文件 新建一个.babelrc配置文件123&#123; &quot;presets&quot;: [&quot;es2015&quot;,&quot;stage-0&quot;,&quot;react&quot;]&#125; presets预设,”es2015”将es6编译成es5,”stage-0”将es7编译成es5,”react”将react编译成es5 原理1:{test:/\\.js$/,loader:&#39;babel-loader&#39;,exclude:/node_modules/}–&gt;处理(编译)js文件:如果发现文件是js,用babel-loader加载,加载的时候需要读配置文件.babelrc,如果代码时es6/es7/react都要通过babel转成es5;同时通过exclude将node_modules文件夹下的所有js文件排除掉 原理2:{test:/\\.less$/,loader:&#39;style-loader!css-loader!less-loader&#39;}–&gt;如果发现文件以.less结尾的,第一步通过less-loader将less编译成css,然后通过css-loader进行加载,然后通过style-loader将他通过style标签的形式插入到页面中去，变成一个行内样式 原理3:{test:/\\.(jpg|png|gif)$/,loader:&#39;url-loader&#39;}–&gt;凡是资源文件都可以用url-loader来加载,不论是图片、图标、字体、视频、音频;后面可以通过问号传参,有个参数limit(例如:{test:/\\.(jpg|png|gif)$/,loader:&#39;url-loader?limit=8192&#39;}–&gt;小于8K的资源文件将直接以base64的形式内联在代码中，可以减少一次http请求) 此时执行npm run build,将代码打包到出口文件中,打开build文件夹下的index.html文件就可以直接预览效果了 此时会发现控制台有个报错 123Warning: Each child in an array or iterator should have a unique &quot;key&quot; prop. Check the render method of `Slider`. See https://fb.me/react-warning-keys for more information. in li (created by Slider) in Slider 需要唯一的key属性,在Slider.js文件中的li需要唯一的key属性，给li标签加上key属性即可 1&lt;li className=&quot;slider&quot; key=&#123;index&#125;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; 关掉浏览器,重新执行npm run build，再打开build文件夹下的index.html文件预览,控制台就没有报错了 5.写功能 让图片动起来,需要给Slider.js加个状态,需要有个定时器让他动起来 写在周期函数componentDidMount中 1234567891011constructor()&#123; super(); this.state=&#123;pos:0&#125;;//默认索引 &#125; componentDidMount()&#123; this.$timer=setInterval(()=&gt;&#123; let pos=this.state.pos; pos++;//每隔2s让pos加1，pos值影响ul的左偏移量left的值 所以ul应该有个style属性 left值应该变化 this.setState(&#123;pos:pos&#125;) &#125;,this.props.interval*1000) pos++;–&gt;每隔2s让pos加1，pos值影响ul的左偏移量left的值 所以ul应该有个style属性 left值应该变化 ul应该有个style属性123456789101112131415161718192021render()&#123; let images=this.props.images; let style=&#123; width:400*images.length, left:this.state.pos*-400 &#125;; return( &lt;div className=&quot;slider-wrapper&quot;&gt; &lt;ul style=&#123;style&#125; className=&quot;sliders&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;li className=&quot;slider&quot; key=&#123;index&#125;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; this.props.interval*1000–&gt;每隔2s轮播一次,需要有变量传进来–&gt;在index.js中新增一个interval变量(间隔时间让外面可以控制) 1).这里通过this.props获取index.js中传递进来的的interval变量this.props.interval*1000 2).index.js中新增一个interval变量12345ReactDOM.render( &lt;Slider images=&#123;images&#125; interval=&#123;2&#125; /&gt;,document.querySelector(&apos;#root&apos;)); 写功能步骤总结: 第一步:定义一个默认索引pos,默认值是0 第二步:在组件加载完成之后创建定时器setInterval赋给this.$timer 第三步:每隔2s让图片向左偏移一个宽度的距离(interval是外界传进来的,是图片轮播的间隔时间),在index中要给组件Slider传进来一个2,2*1000意味着2s变一次 this.$timer中先取出老的pos值，第一次轮播pos就是0，然后pos++，pos变成1，然后setState重新设置pos值,让pos值往上 pos会影响ul的left值，一张图片的宽度是400px，向左偏移400，就是*-400 ul的宽度应该是宽度400乘以图片的数量images.length,4张图就是1600px执行npm run dev 注意,执行npm run dev可自动将文件编译更新打包到出口文件index.html中，并且只要更改文件，页面就会自动刷新,但是如果更改配置文件,需要重新启动npm run dev服务 此时执行npm run dev命令,轮播图就动起来了，但是越界了,因为此时还没有做边界处理 7.完善功能 将Slider需要的属性(可外界控制的)，在index.js的Slider组件标签中传入 1234567891011ReactDOM.render( &lt;Slider images=&#123;images&#125;//图片 interval=&#123;2&#125;//多长时间轮播一次 speed=&#123;1&#125;//每次轮播的速度 pause=&#123;true&#125;//当鼠标移动上去之后自动暂停 autoplay=&#123;true&#125;//是否启用自动轮播，false不自动轮播 - 在Slider.js中 dots=&#123;true&#125;//是否有点状导航 arrows=&#123;true&#125;//是否有箭头导航 /&gt;,document.querySelector(&apos;#root&apos;)); 添加transitionDuration–&gt;规定完成过渡效果需要花费的时间 speed默认值是1 这里就是1s 12345let style=&#123; width:400*images.length, left:this.state.pos*-400, transitionDuration:this.props.speed+&apos;s&apos; &#125;; 在Slider.js的周期函数中添加一个判断 123456789componentDidMount()&#123; if(this.props.autoPlay)&#123; this.$timer=setInterval(()=&gt;&#123; let pos=this.state.pos; pos++; this.setState(&#123;pos:pos&#125;) &#125;,this.props.interval*1000) &#125;&#125; this.props.autoPlay 是否自动轮播 如果外界传入true就是自动轮播，传入false就是不自动轮播 8.将轮播切换单独拎出来写成一个方法turn12345turn(n)&#123; let pos=this.state.pos; pos+=n; this.setState(&#123;pos:pos&#125;)&#125; 或者使用es6的箭头函数 12345turn=(n)=&gt;&#123; let pos=this.state.pos; pos+=n; this.setState(&#123;pos:pos&#125;) &#125; let pos=this.state.pos;获取旧索引 turn表示切换,n表示切换的步长,方便以后操作:例如往左走传1进来即可，往右走传-1进来即可 那么此时在周期函数中,直接调用这个turn方法即可,默认往右轮播，传入-11234567componentDidMount()&#123; if(this.props.autoplay)&#123; this.timer=setInterval(()=&gt;&#123; this.turn(1); &#125;,this.props.interval*1000) &#125;&#125; 9.实现鼠标移上去停止轮播 给div加onMouseOver和onMouseOut事件123&lt;ul onMouseOver=&#123;()=&gt;clearInterval(this.timer)&#125; onMouseOut=&#123;this.play&#125; style=&#123;style&#125; className=&quot;sliders&quot;&gt;...&lt;/ul&gt; 10.自动轮播部分也封装成一个函数play12345play=()=&gt;&#123; this.timer=setInterval(()=&gt;&#123; this.turn(1); &#125;,this.props.interval*1000) &#125;; play表示开启定时器进行自动轮播 那么此时在周期函数中直接调用this.play()即可12345componentDidMount()&#123; if(this.props.autoplay)&#123; this.play(); &#125;&#125; 11.边界判断12345678turn=(n)=&gt;&#123; let pos=this.state.pos; pos+=n; if(pos&gt;=this.props.images.length)&#123; pos=0; &#125; this.setState(&#123;pos:pos&#125;) &#125;; 当索引为图片总张数的时候 让索引变为012.写左右箭头 在ul下加一个div 1234&lt;div className=&quot;arrows&quot;&gt; &lt;span className=&quot;arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span className=&quot;arrow-right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt; 在Slider.less中写样式 123456789101112131415161718192021222324252627.arrows&#123; position: absolute; width: 100%; height: 20px; top:50%; margin-top:-10px; .arrow&#123; width: 20px; height: 20px; line-height: 20px; text-align: center; cursor: pointer; font-size: 30px; background-color: #eee; &amp;:hover&#123; background-color: #999; &#125; &#125; .arrow-left&#123; margin-left: 5px; float: left; &#125; .arrow-right&#123; margin-right: 5px; float: right; &#125;&#125; 给左右arrow绑定事件 1234&lt;div className=&quot;arrows&quot;&gt; &lt;span onClick=&#123;()=&gt;this.turn(-1)&#125; className=&quot;arrow arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span onClick=&#123;()=&gt;this.turn(1)&#125; className=&quot;arrow arrow-right&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt; 13.处理左边界 在turn中做个判断 1234567891011turn=(n)=&gt;&#123; let pos=this.state.pos; pos+=n; if(pos&gt;=this.props.images.length)&#123; pos=0; &#125; if(pos&lt;0)&#123; pos=this.props.images.length-1; &#125; this.setState(&#123;pos:pos&#125;)&#125;; 当索引小于0的时候,让索引等于images的长度-1 14.根据传进来的arrows值判断是否有左右箭头切换效果 第一种方法(看着比较乱) 123456&#123; this.props.arrows?&lt;div className=&quot;arrows&quot;&gt; &lt;span onClick=&#123;()=&gt;this.turn(-1)&#125; className=&quot;arrow arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span onClick=&#123;()=&gt;this.turn(1)&#125; className=&quot;arrow arrow-right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt;:null &#125; 第二种,在render中 123456789let arrows=null; if(this.props.arrows)&#123; arrows=( &lt;div className=&quot;arrows&quot;&gt; &lt;span onClick=&#123;()=&gt;this.turn(-1)&#125; className=&quot;arrow arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span onClick=&#123;()=&gt;this.turn(1)&#125; className=&quot;arrow arrow-right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt; ) &#125; 那么ul下面就可以直接用{arrows}代替了(看着很清晰明了) 123456789101112&lt;div className=&quot;slider-wrapper&quot;&gt; &lt;ul onMouseOver=&#123;()=&gt;clearInterval(this.timer)&#125; onMouseOut=&#123;this.play&#125; style=&#123;style&#125; className=&quot;sliders&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;li className=&quot;slider&quot; key=&#123;index&#125;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &#123;arrows&#125;&lt;/div&gt; 15.根据传进来的dots值判断是否有点状导航123456789101112let dots=null; if(this.props.dots)&#123; dots=( &lt;div className=&quot;dots&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;span className=&quot;dot&quot; key=&#123;index&#125;&gt;&lt;/span&gt; )) &#125; &lt;/div&gt; ) &#125; dots直接放到最下面即可123...&#123;arrows&#125;&#123;dots&#125; 15-1.在Slider.less中写dots的样式12345678910111213141516171819.dots&#123; width: 100%; height: 20px; position: absolute; bottom: 10px; text-align: center; .dot&#123; display: inline-block; width: 20px; height: 20px; border-radius: 50%; margin-left: 5px; background-color: #abcdef; cursor: pointer; &amp;:hover&#123; background-color: #999999; &#125; &#125;&#125; 16.点状导航的点击跟随事件 给span加onClick事件123···&lt;span className=&quot;dot&quot; key=&#123;index&#125; onClick=&#123;()=&gt;this.turn(index-this.props.pos)&#125;&gt;&lt;/span&gt;··· 16-1.轮播点状导航自动跟随事件 在Slider.less中加一个active样式 123.active&#123; background-color: #999999; &#125; 给span标签添加active属性 1&lt;span className=&#123;&quot;dot &quot;+(index==this.state.pos?&apos;active&apos;:&apos;&apos;)&#125; key=&#123;index&#125; onClick=&#123;()=&gt;this.turn(index-this.state.pos)&#125;&gt;&lt;/span&gt;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"1.react轮播图项目配置及原理概要","slug":"1-react轮播图项目配置及原理概要","date":"2017-07-30T17:47:17.000Z","updated":"2017-09-09T12:26:33.016Z","comments":true,"path":"2017/07/31/1-react轮播图项目配置及原理概要/","link":"","permalink":"http://yoursite.com/2017/07/31/1-react轮播图项目配置及原理概要/","excerpt":"","text":"项目配置及原理概要1.初始化项目1npm init -y 生成package.json文件 2.安装依赖包 开发依赖1npm install webpack webpack-dev-server babel-core babel-loader babel-preset-react babel-preset-es2015 babel-preset-stage-0 style-loader css-loader less-loader less file-loader url-loader html-webpack-plugin -D webpack 打包 webpack-dev-server 用来启动一个HTTP服务器预览我们的项目 babel-core babel-loader 进行转译 把es6和react代码转译成es5 babel-preset-react 用来转译react babel-preset-es2015 用来转译es6 babel-preset-stage-0 用来转译es7 style-loader css-loader 用来处理css less-loader less 编译less file-loader url-loader 用来处理资源文件 html-webpack-plugin 用来自动产出html文件 open-browser-webpack-plugin 自动打开浏览器 3.安装生产依赖1npm install react react-dom -S 4.配置文件的出入口路径 新建一个webpack.config.js文件，在文件中配置入口文件和出口路径12345678let path=require(&apos;path&apos;);module.exports=&#123; entry:&apos;./src/index.js&apos;,//入口文件 output:&#123;//出口配置 path:path.resolve(&apos;build&apos;),//出口文件路径 filename:&apos;bundle.js&apos;//出口文件名称 &#125;&#125;; 5.启动安装的模块文件夹node_modules–&gt;.bin–&gt;webpack.cmd和webpack-dev-server.cmd文件 在package.json文件中的scripts标签进行匹配1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;:&quot;webpack-dev-server&quot; &#125;, 5-1.启动webpack和webpack-dev 在cmd中执行命令 1npm run build 1)在cmd窗口中显示 123 Asset Size Chunks Chunk Namesbundle.js 2.52 kB 0 [emitted] main [0] ./src/index.js 43 bytes &#123;0&#125; [built] 表示生成bundle.js一个文件 2)在当前项目文件夹下会自动生成一个build文件夹，同时在build文件夹下会自动生成bundle.js文件，我们的入口文件(src文件夹下的index.js)会自动打包到出口文件bundle.js中 6.自动产出html文件6-1.现在我们需要在build文件夹中新建一个index.html文件，然后引入bundle.js进行预览;但是现在我们希望这个文件不要手动创建了，希望他可以自动生成，要做到这一点，我们需要引入插件html-webpack-plugin(此插件在最初已经安装过,如果没有安装需安装后才可使用) 1) 在webpack.config.js中引入html-webpack-plugin 1let HtmlWebPackPlugin=require(&apos;html-webpack-plugin&apos;); 2) 同时给插件再添加个配置项plugins,plugins是个数组 12345plugins:[ new HtmlWebPackPlugin(&#123; template:&apos;./src/index.html&apos; &#125;)] 3) template 模板 配置到时候会按照哪个模板来自动产出html文件 并且把它自动放到配置目录下–&gt;一般会在src文件夹下新建一个模板叫index.html 4) 执行npm run build 4-1).原理:此时如果再执行npm run build的话，就会执行上面配置的plugins插件,插件会读取src文件夹下的index.html模板文件，把他自动插入到打包后的bundle.js，并且把bundle.js保存到build目录下(每次执行npm run build命令，都会重新生成bundle.js和index.html两个文件) 4-2).在cmd命令行执行npm run build,命令行显示: 1234 Asset Size Chunks Chunk Names bundle.js 2.52 kB 0 [emitted] mainindex.html 188 bytes [emitted] [0] ./src/index.js 43 bytes &#123;0&#125; [built] 表示生成bundle.js和index.html两个文件,与之前执行npm run build相比多了一个html文件 4-3).打开我们的项目文件夹下的build文件会发现，已经自动生成了一个出口index.html出口文件,打开这个index.html出口文件会发现,index.html中已经自动引入了bundle.js文件 关于react轮播图的源码,无缝版已上传至github,https://github.com/gaodaxiu0406/React-Slider","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"CSS选择器种类和兼容性总结大全","slug":"css选择器种类和兼容性总结大全","date":"2017-07-21T07:57:22.000Z","updated":"2017-08-16T15:33:05.869Z","comments":true,"path":"2017/07/21/css选择器种类和兼容性总结大全/","link":"","permalink":"http://yoursite.com/2017/07/21/css选择器种类和兼容性总结大全/","excerpt":"","text":"css5选择器 名称 举例 描述 详细 权重 ie6-7 ie8 ie9+ 其他 标签选择器 p{} 直接使用元素标签进行选择 1 yes yes yes 类选择器 .sum{} 类选择器最前方一定要有点 通过元素的类名，来选择元素，一个元素可以有多个类名，都代表这个元素,类名是元素class属性中的属性值，例如&lt;p class=&#39;sum&#39;&gt;&lt;/p&gt; 10 yes yes yes id选择器 #tytle{color:red;} id在html中具有唯一性,这个属性值前面加一个“#” 一个html元素，id属性值只能用一次 100 yes yes yes 通配符选择器 *{key:value} 匹配全部html元素 一般不使用，因为全部匹配耗性能 0&lt;通配符选择器&lt;1 yes yes yes yes (标签)属性选择器 [type]或[type=text] [标签属性名]{}或[标签属性名=属性值]{} 利用标签的属性名和属性值来选择html元素 10 yes yes yes 属性选择器在使用的时候，如果一个元素有两个类名，那么是不生效的 分组选择器 .box,li,.p1{color: red}; 选择器1，选择器2，选择器3{} 同一份css样式，可以一次性的添加给多个不同的html元素 分组选择器将不同的html分为一组，权重计算的时候都是独立计算，不会叠加。 yes yes yes 交集选择器 h2[title]{} 两种选择器同属于一个元素的时候，我们可以使用交集选择器来进行元素的准确选择 所有组合选择器权重之和 yes yes yes 作用：精确查找元素，增加选择器的权重 子级选择器 ul&gt;li{color:red;} 父级选择器&gt;子级选择器{} 存在包含关系的元素选择，通过父级确定选择子级 所有选择器之和 yes yes yes 子级选择器必须是紧邻的父子关系 后代选择器(派生选择器) .div1 ul span{} 祖辈选择器 要查找的后代选择器{},中间用空格连接 后代选择器在写的时候尽量控制在３个左右 yes yes yes 在一个根元素的范围内，查找到它的后代元素，选择器过多浪费性能，不建议使用 相邻兄弟选择器 .list1+li{color: red;} 哥哥选择器+弟弟选择器{} 通过各个元素选择弟弟选择器，两个选择器之间用“+”连接 选择器之和 yes yes yes 伪类选择器 a:hover{color: red}鼠标经过的状态,或a:link{color: blue}默认状态,或a：active{color: green}鼠标点击的状态,或a:visited{color: blanchedalmond}鼠标点击后的状态 10 yes yes yes .input:focus{border-color: blue};input:focus 鼠标聚焦后的状态，input独有的属性 伪元素 div:before{}；或div:after{} 通过css代码向指定元素内添加假的（html中不存在的）元素 before 会出现在div所有内容之前，after 会出现在div所有内容之后 no yes yes 使用伪元素的时候要保证两个前提：1.要有display这个属性2.要有content这个属性，这个属性的属性值可以为空，但是引号不能少content:&quot;&quot; visited security issue yes yes security issue css3选择器 名称 举例 描述 详细 权重 ie6-7 ie8 ie9+ 其他 属性选择器 E[attr~=value]{} 指定属性名,并且具有属性值,此属性值是一个此列表(类名),并且以空格隔开,其中词列表中包含了一个value词,并且等号前的~不能省略. E[attr^=value]{} ^ 表示以谁为开头的,value可以是首字母或者类名 必须是第一个类名 E[attr$=value]{} $ 表示以谁为结尾,value可以是末尾字母或者类名 必须是最后一个类名 E[attr\\=value]{}(由于编辑呈现问题，此处用斜杠代替竖杠,正确写法是E[attr竖杠=value]{}) 如果只有一个类名,没有”-“,也可以选中 value必须后面带”-“，value必须是第一个类名 伪类选择器1. .dome p:nth-child(3){background: red;}选择dome下的第三个p标签为背景色红色 no no yes 2. .dome p:first-child{background: yellow;}选择dome下的第一个p标签为背景色黄色 no almost yes 3. .dome p:last-child{background: black;}选择dome下的最后一个p标签为背景色黑色 伪类选择器是针对列表或者很多同级的标签使用,img下是没有效果的也用不到伪类选择器 no no yes 4. .dome p:nth-child(nlength){}；选择dome下所有的p标签 no no yes 5. .dome p:nth-child(2n){}；选择dome下的所有偶数个的p标签 no no yes 6. .dome p:nth-child(3n)选择dome下的所有3的倍数的p标签 no no yes 7. .dome p:nth-child(n+length) 从第length个开始改变,包括第length个(n是从0开始取值的) 选择大于length后面的元素 no no yes 8. .dome p:nth-child(-n+length) 包括length，length是从0开始的 选择小于length前面的元素及length元素 no no yes 9. p:nth-last-child(3) 选择倒数第三个元素 no no yes 10. p:nth-child(n) 从大盒子的第一个元素开始 nth-child选择同级元素 no no yes 11. p:nth-of-type(n) 从大盒子的第一个p元素开始 nth-of-type 选择指定的元素 no no yes 12. p:nth-last-of-type(n) 倒数第n个 在同级元素中 no no yes 13. p:first-of-type{} 同类型的第一个 选择一个上级元素下的同类子元素 no no yes 14. p:last-of-type{} 同类型的最后一个 no no yes 15. p:only-child{} 在父元素中,里面的子元素是唯一的 no no yes 16. p:only-of-type{} 在父元素中,里面有很多的子元素,但是有一个子元素是唯一的 no no yes 空标签 p:empty{display:none;} empty 隐藏空标签 no no yes 否定选择器 not input:not([type=submit]){} no yes yes 根元素 root :root{} 选择文档的根元素 no no yes 目标元素 :target{} 选择器可用于选取当前活动的目标元素 no no no CSS选择器优先级 当两个规则都作用到了同一个html元素上时，如果定义的属性有冲突，那么应该用谁的值的，CSS有一套优先级的定义 不同级别 1.在属性后面使用important会覆盖页面内任何位置定义的元素样式 2.作为style属性写在元素内的样式 3.id选择器 4.类选择器 5.标签选择器 6.通配符选择器 7.浏览器自定义或继承 总结CSS选择器优先级排序: !important&gt;行内样式&gt;ID选择器&gt;类选择器&gt;标签&gt;通配符&gt;继承&gt;浏览器默认属性 CSS样式应用，有个简单的计算方式(权值实际并不是按照十进制，用数字表示只是说明思想，一万个class可能也不如一个id权值高) 内联样式表的权值为 1000 ID选择器的权值为 100 Class类选择器的权值为 10 HTML标签选择器的权值为 1","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"IP分类","slug":"IP分类","date":"2017-07-05T11:49:07.000Z","updated":"2017-09-09T12:23:10.903Z","comments":true,"path":"2017/07/05/IP分类/","link":"","permalink":"http://yoursite.com/2017/07/05/IP分类/","excerpt":"","text":"每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。IP地址根据网络ID的不同分为5种类型，A类地址、B类地址、C类地址、D类地址和E类地址A类ip地址 A:0-127 A类ip地址的第一组数字为1～126。 其中0代表任何地址，127为回环测试地址 注意，数字0和 127不作为A类地址，数字127保留给内部回送函数，而数字0则表示该地址是本地宿主机，不能传送。 A类地址的表示范围为：0.0.0.0~126.255.255.255,默认网络掩码为：255.0.0.0；A类地址分配给规模特别大的网络使用。A类网络用第一组数字表示网络本身的地址，后面三组数字作为连接于网络上的主机的地址。分配给具有大量主机（直接个人用户）而局域网络个数较少的大型网络。例如IBM公司的网络。 一个A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”， 地址范围从1.0.0.0 到126.0.0.0。可用的A类网络有126个，每个网络能容纳1亿多个主机。 B类ip地址 B类地址的第一组数字为128～191。 其中128.0.0.0和191.255.0.0为保留ip。 B类地址的表示范围为:128.0.0.0~191.255.255.255，默认网络掩码为:255.255.0.0;实际范围是128.1.0.0–191.254.0.0;B类地址分配给一般的中型网络。B类网络用第一、二组数字表示网络的地址，后面两组数字代表网络上的主机地址。 一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围从128.0.0.0到191.255.255.255。可用的B类网络有16382个，每个网络能容纳6万多个主机 。 C类ip地址 C类地址的第一组数字为192～223。 其中192.0.0.0和223.255.255.0为保留ip C类地址的表示范围为:192.0.0.0~223.255.255.255,默认网络掩码为：255.255.255.0;实际范围是192.0.1.0–223.255.254.0;C类地址分配给小型网络，如一般的局域网和校园网，它可连接的主机数量是最少的，采用把所属的用户分为若干的网段进行管理。C类网络用前三组数字表示网络的地址，最后一组数字作为网络上的主机地址。 一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围从192.0.0.0到223.255.255.255。C类网络可达209万余个，每个网络能容纳254个主机。 D类ip地址 224.0.0.0到239.255.255.255用于多点广播 D类IP地址第一个字节以“lll0”开始，它是一个专门保留的地址。它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中。多点广播地址用来一次寻址一组计算机，它标识共享同一协议的一组计算机。 D类地址称为广播地址，供特殊协议向选定的节点发送信息时用 E类ip地址 240.0.0.0到255.255.255.254 255.255.255.255用于广播地址 以“llll0”开始，为将来使用保留。 E类地址保留给将来使用。 全零（“0．0．0．0”）地址对应于当前主机。全“1”的IP地址（“255．255．255．255”）是当前子网的广播地址。保留地址的分配一个机构网络要连入Internet，必须申请公用IP地址。但是考虑到网络安全和内部实验等特殊情况，在IP地址中专门保留了三个区域作为私有地址，其地址范围如下：10.0.0.0/8:10.0.0.0-10.255.255.255172.16.0.0/12:172.16.0.0-172.31.255.255192.168.0.0/16:192.168.0.0-192.168.255.255使用保留地址的网络只能在内部进行通信，而不能与其他网络互连。因为本网络中的保留地址同样也可能被其它网络使用，如果进行网络互连，那么寻找路由时就会因为地址的不唯一而出现问题。但是这些使用保留地址的网络可以通过将本网络内的保留地址翻译转换成公共地址的方式实现与外部网络的互连。这也是保证网络安全的重要方法之一。 特殊IP地址(保留IP地址)介绍就像我们每个人都有一个身份证号码一样，网络里的每台电脑(更确切地说，是每一个设备的网络接口)都有一个IP地址用于标示自己。我们可能都知道这些地址由四个字节组成，用点分十进制表示以及它们的A，B，C分类等，然而，在总数大约为四十多亿个可用IP 地址里，你知道下面一些常见的有特殊意义地址吗？我们一起来看看吧： 一、0.0.0.0严格说来，0.0.0.0已经不是一个真正意义上的IP地址了。它表示的是这样一个集合：所有不清楚的主机和目的网络。这里的“不清楚”是指在本机的路由表里没有特定条目指明如何到达。对本机来说，它就是一个“收容所”，所有不认识的“三无”人员，一 律送进去。如果你在网络设置中设置了缺省网关，那么Windows系统会自动产生一个目的地址为0.0.0.0的缺省路由。 二、255.255.255.255限制广播地址。对本机来说，这个地址指本网段内(同一广播域)的所有主机。如果翻译成人类的语言，应该是这样：“这个房间里的所有人都注意了！”这个地址不能被路由器转发。 三、127.0.0.1本机地址，主要用于测试。用汉语表示，就是“我自己”。在Windows系统中，这个地址有一个别名“Localhost”。寻址这样一个地址，是不能把它发到网络接口的。除非出错，否则在传输介质上永远不应该出现目的地址为“127.0.0.1”的 数据包。 四、224.0.0.1组播地址，注意它和广播的区别。从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机，224.0.0.2特指所有路由器。这样的地址多用于一些特定的程序以及多媒体程序。如果你的主机开启了IRDP (Internet路由发现协议，使用组播功能)功能，那么你的主机路由表中应该有这样一条路由。 五、169.254.x.x如果你的主机使用了DHCP功能自动获得一个IP地址，那么当你的DHCP服务器发生故障，或响应时间太长而超出了一个系统规定的时间，Wingdows系统会为你分配这样一个地址。如果你发现你的主机IP地址是一个诸如此类的地址，很不幸，十有八九 是你的网络不能正常运行了。 六、10.x.x.x、172.16。x。x～172.31。x。x、192.168。x。x私有地址，这些地址被大量用于企业内部网络中。一些宽带路由器，也往往使用192.168.1.1作为缺省地址。私有网络由于不与外部互连，因而可能使用随意的IP地址。保留这样的地址供其使用是为了避免以后接入公网时引起地址混乱。使用私有地址的私 有网络在接入Internet时，要使用地址翻译(NAT)，将私有地址翻译成公用合法地址。在Internet上，这类地址是不能出现的。对一台网络上的主机来说，它可以正常接收的合法目的网络地址有三种：本机的IP地址、广播地址以及组播地址。","categories":[],"tags":[{"name":"前端常识","slug":"前端常识","permalink":"http://yoursite.com/tags/前端常识/"}]},{"title":"CSS属性的继承及相关面试题","slug":"CSS属性的继承及相关面试题","date":"2017-06-30T08:56:14.000Z","updated":"2017-08-16T15:32:20.878Z","comments":true,"path":"2017/06/30/CSS属性的继承及相关面试题/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS属性的继承及相关面试题/","excerpt":"","text":"CSS属性的继承 子级元素从父级元素身上继承的一些可继承的css属性 1234&lt;style&gt;div&#123;color:red;&#125;&lt;/style&gt;&lt;p&gt;woshiyige[biaoqian&lt;/p&gt; 根据 CSS，子元素从父元素继承属性。看看下面这条规则： body {font-family: Verdana, sans-serif;} 根据上面这条规则，站点的 body 元素将使用 Verdana 字体（假如访问者的系统中存在该字体的话）。 继承的权重较小，可被其他选择器的样式覆盖 面试题： 哪些css样式可以被继承：和文字有关的css样式 和列表有关的css样式总结： 1.可继承属性 1)可以继承的文本相关属性： 1&lt;azimuth&gt;&lt;border-collapse&gt;&lt;border-spacing&gt;&lt;caption-side&gt;&lt;color&gt;&lt;cursor&gt;&lt;direction&gt;&lt;elevation&gt;&lt;empty-cells&gt;&lt;font-family&gt;&lt;font-size&gt;&lt;font-style&gt;&lt;font-variant&gt;&lt;font-weight&gt;&lt;font&gt;&lt;letter-spacing&gt;&lt;line-height&gt;&lt;list-style-image&gt;&lt;list-style-position&gt;&lt;list-style-type&gt;&lt;list-style&gt;&lt;orphans&gt;&lt;pitch-range&gt;&lt;pitch&gt;&lt;quotes&gt;&lt;richness&gt;&lt;speak-header&gt;&lt;speaknumeral&gt;&lt;speak-punctuation&gt;&lt;speak&gt;&lt;speechrate&gt;&lt;stress&gt;&lt;text-align&gt;&lt;text-indent&gt;&lt;texttransform&gt;&lt;visibility&gt;&lt;voice-family&gt;&lt;volume&gt;&lt;whitespace&gt;&lt;widows&gt;&lt;word-spacing&gt; 2)可以继承的列表相关属性： 1&lt;azimuth&gt;&lt;border-collapse&gt;&lt;border-spacing&gt;&lt;caption-side&gt;&lt;color&gt;&lt;cursor&gt;&lt;direction&gt;&lt;elevation&gt;&lt;empty-cells&gt;&lt;font-family&gt;&lt;font-size&gt;&lt;font-style&gt;&lt;font-variant&gt;&lt;font-weight&gt;&lt;font&gt;&lt;letter-spacing&gt;&lt;line-height&gt;&lt;list-style-image&gt;&lt;list-style-position&gt;&lt;list-style-type&gt;&lt;list-style&gt;&lt;orphans&gt;&lt;pitch-range&gt;&lt;pitch&gt;&lt;quotes&gt;&lt;richness&gt;&lt;speak-header&gt;&lt;speaknumeral&gt;&lt;speak-punctuation&gt;&lt;speak&gt;&lt;speechrate&gt;&lt;stress&gt;&lt;text-align&gt;&lt;text-indent&gt;&lt;texttransform&gt;&lt;visibility&gt;&lt;voice-family&gt;&lt;volume&gt;&lt;whitespace&gt;&lt;widows&gt;&lt;word-spacing&gt; 2.不可继承属性 1&lt;display&gt;&lt;margin&gt;&lt;border&gt;&lt;padding&gt;&lt;background&gt;&lt;height&gt;&lt;min-height&gt;&lt;max-height&gt;&lt;width&gt;&lt;min-width&gt;&lt;max-width&gt;&lt;overflow&gt;&lt;position&gt;&lt;left&gt;&lt;right&gt;&lt;top&gt;&lt;bottom&gt;&lt;z-index&gt;&lt;float&gt;&lt;clear&gt;&lt;table-layout&gt;&lt;vertical-align&gt;&lt;page-break-after&gt;&lt;page-bread-before&gt;和&lt;unicode-bidi&gt; 3.所有元素可继承： &lt;visibility&gt;（可见性）和&lt;cursor&gt;(光标) 4.终端块状元素可继承： &lt;text-indent&gt;和&lt;text-align&gt; 5.如果css属性不带有继承性，如何继承父级身上的属性，可以将要继承的属性的属性值写上inherit12ul&#123;float:left;&#125;li&#123;float:inherit;&#125;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS中的form表单与table表格","slug":"CSS中的form表单与table表格","date":"2017-06-30T08:15:23.000Z","updated":"2017-08-16T15:32:15.668Z","comments":true,"path":"2017/06/30/CSS中的form表单与table表格/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS中的form表单与table表格/","excerpt":"","text":"form表单 用来获取用户信息&lt;form&gt;&lt;/form&gt; 12345678910111213141516171819202122&lt;form&gt; &lt;input type=&quot;radio&quot; name=&quot;ok&quot; checked=&quot;checked&quot;&gt;&lt;!--单选按钮--&gt;&lt;label&gt;满意&lt;/label&gt;&lt;!--label 描述表单元素功能--&gt; &lt;!--type 类型--&gt; &lt;!--name 名字--&gt; &lt;!--checked 选中--&gt; &lt;input type=&quot;radio&quot; name=&quot;ok&quot;&gt;&lt;!--单选按钮--&gt;&lt;label&gt;不满意&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;篮球&lt;/label&gt; &lt;input type=&quot;checkbox&quot; checked&gt;&lt;label&gt;美女&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;彭于晏&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;陈冠希&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;杨颖&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;维密&lt;/label&gt; &lt;textarea maxlength=&quot;10&quot; minlength=&quot;1&quot;&gt;&lt;/textarea&gt;&lt;!--文本域--&gt; &lt;!--maxlength 字符输入的最大长度--&gt; &lt;br&gt; &lt;label&gt;姓名&lt;/label&gt;&lt;input type=&quot;text&quot;&gt; &lt;br&gt; &lt;label&gt;手机&lt;/label&gt;&lt;input type=&quot;text&quot;&gt; &lt;br&gt; &lt;label&gt;密码&lt;/label&gt;&lt;input type=&quot;password&quot;&gt;&lt;/form&gt; radio 单选按钮 name=”ok”（name的值相同情况下）同时给到input type=”radio”，表示单选只能选中其中的一个 lable描述表单元素功能 type 类型 name 名字 cheked 选中 单独写checked也可以达到选中的效果 &lt;input type=&quot;checkbox&quot;&gt;checkbox 多选按钮 textarea 文本域 &lt;textarea maxlength=&quot;10&quot; minlength=&quot;1&quot;&gt;&lt;/textarea&gt; maxlength字符输入的最大长度 table表格 &lt;caption&gt;标题&lt;/caption&gt; &lt;thead&gt;表头&lt;/thead&gt; tr&gt;th（标题单元格，th加粗居中） &lt;tfoot&gt; 表尾 tr&gt;th（普通单元格） tr&gt;td（普通单元格，td不加粗不居中） tbody 表身 tr&gt;th（普通单元格） thead和tfoot分别有一个 tbody可以有多个tfoot一般放置在thead的后面，为了防止tbody中的内容过多，tfoot加载过慢的情况，但是虽然书写位置在前面，在页面中显示的时候，这部分依然在整个表格的最后面如果table用来搭建结构，我们只需写tr和td 123456789101112&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"标签语义化","slug":"CSS标签语义化","date":"2017-06-30T08:11:33.000Z","updated":"2017-08-16T15:32:38.255Z","comments":true,"path":"2017/06/30/CSS标签语义化/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS标签语义化/","excerpt":"","text":"标签语义化的重要性/为什么要遵循标签语义化：合理的标签做合理的事情 1、重要的内容，要放在语义重要的标签中，利于SEO优化(搜索引擎榨取),利于SEO优化(也就是搜索引擎的抓取，搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重); 浏览器会按照每个标签的意义去解析这个标签中的内容:h1–&gt;这是一个大标题，意义很重要，搜索引擎会重点抓取这个里面的内容 p–&gt;段落 浏览器在展现这一部分的时候，会独立成一块，让网页结构更加清晰，给用户更好的浏览体验 2、在没有css样式的时候，页面也可以整齐的显示效果 3、更好的支持各种终端，例如无障碍阅读和有声小说等； 4、利于团队协作和后期维护 日常工作中怎样遵循标签语义化： 1、尽量减少使用无意义标签，例如span和div； 2、尽量不使用标签本身的css属性，例如b、font、s等标签，如果需要这些样式，那么使用css样式来进行添加； 3、在需要强调的部分，使用strong、em，但是样式尽量使用css样式来描述； 4、表格搭建时，使用`表格头部 表格身体 表格尾部； 5、列表搭建时，使用无序列表 有序列表 定义列表；` 国家评比一个网站的关键点：访问量（流量/点击量）","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML标签分类","slug":"HTML标签分类","date":"2017-06-30T08:09:06.000Z","updated":"2018-02-10T11:43:48.836Z","comments":true,"path":"2017/06/30/HTML标签分类/","link":"","permalink":"http://yoursite.com/2017/06/30/HTML标签分类/","excerpt":"","text":"html标签分类 html标签又叫做html元素，它分为块级元素和内联元素（也可以叫做行内元素），都是html规范中的概念。 块级元素 块级元素是指本身属性为display:block;的元素。因为它自身的特点，我们通常使用块级元素来进行大布局（大结构）的搭建 块级元素的特点： 独占一行，每一个块级元素都会从新的一行重新开始，从上到下排布 可以直接控制宽度、高度以及盒子模型的相关css属性 在不设置宽度的情况下，块级元素的宽度是它父级元素内容的宽度 在不设置高度的情况下，块级元素的高度是它本身内容的高度 常用的块级元素: div 常用块级容器，也是css layout的主要标签 h1 大标题 h2 副标题 h3 三级标题 h4 四级标题 h5 五级标题 h6 六级标题12345678910标题：&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;h$&#123;$级标题&#125;*6+tab生成：&lt;h1&gt;1级标题&lt;/h1&gt;&lt;h2&gt;2级标题&lt;/h2&gt;&lt;h3&gt;3级标题&lt;/h3&gt;&lt;h4&gt;4级标题&lt;/h4&gt;&lt;h5&gt;5级标题&lt;/h5&gt;&lt;h6&gt;6级标题&lt;/h6&gt; hr 水平分隔线 menu 菜单列表 ol 有序列表 li列表项 123456789有序列表&lt;ol&gt; &lt;li&gt;盗天仙图&lt;/li&gt; &lt;li&gt;名侦探&lt;/li&gt; &lt;li&gt;鬼吹灯&lt;/li&gt; &lt;li&gt;盗墓笔记&lt;/li&gt; &lt;li&gt;名侦探&lt;/li&gt; &lt;li&gt;鬼吹灯&lt;/li&gt;&lt;/ol&gt; ul 无序列表 li列表项 123456789无序列表&lt;ul&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;有保证&lt;/b&gt;&lt;/span&gt;:先学习考试后入学&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;有实力&lt;/b&gt;&lt;/span&gt;:专注JS培训七年铸就传奇就业,平均工资超12K&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;有深度&lt;/b&gt;&lt;/span&gt;:结合的大学算法和数据结构的基础课&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;重原生&lt;/b&gt;&lt;/span&gt;:狠练原生代码,原生JS+Node才是王道&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;重应用&lt;/b&gt;&lt;/span&gt;:PC+移动端+H5+CSS3+node的前后台全栈项目&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;重未来&lt;/b&gt;&lt;/span&gt;:app开发,微信开发,angular,es6,前沿技术&lt;/li&gt;&lt;/ul&gt; dl 定义列表 dt 定义术语 dd定义描述 table 表格 p 段落1234567891011&lt;div class=&quot;poem&quot;&gt;&lt;h4&gt;早发白帝城&lt;/h4&gt;&lt;h5&gt;作者：李白&lt;/h5&gt;&lt;p&gt;朝辞白帝彩云间，&lt;br&gt; 千里江陵一日还。&lt;br&gt; 两岸猿声啼不尽，&lt;br&gt; 轻舟已过万重山。&lt;br&gt; &lt;img src=&quot;timg.jpg&quot; alt=&quot;李白&quot;&gt;&lt;/p&gt;&lt;/div&gt; 123456789&lt;div&gt; &lt;h4 align=&quot;center&quot;&gt;早发白帝城&lt;/h4&gt; &lt;h5 align=&quot;center&quot;&gt;作者：李白&lt;/h5&gt; &lt;p align=&quot;center&quot;&gt;朝辞白帝彩云间，&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;千里江陵一日还。&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;两岸猿声啼不尽，&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;轻舟已过万重山。&lt;/p&gt; &lt;img src=&quot;timg.jpg&quot; alt=&quot;李白&quot;&gt;&lt;/div&gt; form 交互表单 内联元素 内联元素是指本身属性为display:inline;的元素。因为它自身的特点，我们通常使用块级元素来进行文字、小图标（小结构）的搭建。 内联元素的特点： 和其他内联元素从左到右在一行显示 2.不能直接控制宽度、高度以及盒子模型的相关css属性，但是直接设置内外边距的左右值是可以的 3.内联元素的宽高是由本身内容的大小决定（文字、图片等） 4.内联元素只能容纳文本或者其他内联元素（此处请注意，不要在内联元素中嵌套块级元素） 常用的内联元素: span 常用内联容器，定义文本内区块 a 锚点 文本设置类: b 加粗 strong 加粗强调 i 斜体 em 斜体强调 s 中划线（不推荐使用） strike 中划线 del 文档中已被删除的文本 big 大字体文本、small小字体文本） small 小字体文本 br 强制换行 u 下划线 textarea 多行文本输入框 input 输入框 select 下拉列表 label（input 元素定义标注/标记）、img sub 下标 sup 上标","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML基本结构","slug":"HTML基本结构","date":"2017-06-30T07:59:54.000Z","updated":"2017-09-09T12:23:51.210Z","comments":true,"path":"2017/06/30/HTML基本结构/","link":"","permalink":"http://yoursite.com/2017/06/30/HTML基本结构/","excerpt":"","text":"html的基本结构123456789101112&lt;!DOCTYPE html&gt;文档声明：必须放在html文件的第一行；如果没有文档声明会触发浏览器的怪异模式&lt;html&gt;html元素：告知浏览器，我是一个html文件 &lt;head&gt; head元素：文档的头部，一般放在文档头部的内容不会显示在浏览器的可视区内 &lt;meta charset=&quot;utf-8&quot;&gt;规定一个语法 必须放在head的第一部分 &lt;title&gt;标题，显示在浏览器的页卡位置，title中的内容也会被seo抓取&lt;/title&gt; &lt;body&gt;供用户浏览的所有内容，标签、图片、文本、视频···&lt;/body&gt; &lt;/head&gt;&lt;/html&gt; 一个html文件也叫做一个网页，可以称作是一个文档(document) 这个文档从html元素开始，一致向下分支延伸，像一颗大树一样，所以我们将html元素叫做这个文档的根元素 &lt;!DOCTYPE html&gt;html5的文档声明 作用：定义这个文档类型，浏览器先识别这句话，会按照定义的类型去解析这个文档 html5的文档声明，那么浏览器就会按照html5的规则解析整个页面`&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;html4版本的文档声明` 所有高版本都会向下兼容，所以在以后的工作中，我们直接将文档声明写错html5就可以了 文档声明必须写在html文件的第一行 文档声明不区分大小写 如果html文件没有文档声明，会触发浏览器的怪异模式 文档声明不是一个html标签 1.html元素此元素告知浏览器其自身是一个html元素是由开始和结束标签组成的，html文件里面所有的内容都会放在这个这个元素内 2.head元素- 整个文档的头部，head元素自带隐藏功能，display:none;里面的内容不会隐藏，只不过一般放置在head元素中的其他元素和内容也是自带隐藏功能的，例如link、script、meta··· - `&lt;script&gt;&lt;/script&gt;与head标签一样具有隐藏功能，写在其内的内容在网页不显示` 3.&lt;meta charset=&quot;UTF-8&quot;&gt;4.&lt;meta&gt;规定了html文档的元信息 charset=”UTF-8” 文档的编码 UTF-8 国际通用编码 gbk 国标 gb2312 国标 name=”keyword” content=”关键词” name=”keyword” content=”HTML5J5…” SEO优化有关 SEO搜索引擎&lt;meta name=&quot;keyword&quot; content=&quot;关键词&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;勿忘初心,方得始终&quot;&gt; 5.title元素 html文档名称 一个页面只有一个title元素放文字 显示在浏览器的页卡（页头）位置6.link标签 &lt;link href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; rel=&quot;shortcut icon&quot;&gt; 图标让设计师生成 一般整个图片放在整个项目的根目录下 显示在浏览器页卡位置，title内容之前 &lt;link rel=&quot;stylesheet&quot; herf=&quot;url&quot; type=&quot;texe/css&quot;&gt; 引入一个外部的css文件 rel不能缺少 stylesheet样式表 type可以省略 但是建议写全 7.body元素 定义整个文档的主体部分，所有展示给用户的内容都要放在这个元素中 body中有常用的html元素（div、ul），文本内容、音频、视频、图片、表单1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UIF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS的引入方式","slug":"CSS的引入方式","date":"2017-06-30T07:27:20.000Z","updated":"2017-08-16T15:22:11.645Z","comments":true,"path":"2017/06/30/CSS的引入方式/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS的引入方式/","excerpt":"","text":"css如何在html中使用（html引入css的四种方法） 行内式：直接写在标签内，通过标签属性style引入 媒介：style属性&lt;style type=&quot;text/css&quot;&gt;选择器{}&lt;/style&gt;12&lt;div style=&quot;css属性名:属性值；&quot;&gt;&lt;/div&gt;&lt;img style=&quot;css属性名:属性值；&quot;alt=&quot;&quot;&gt; css想要生效，html中必须有这个元素才可以 内嵌式（内联式）:将css代码写在style元素内，通过css选择器选择html元素，将css样式添加个这个元素 媒介：style标签+选择器 style这个元素一般放在head元素内 style元素：盛装css样式12345&lt;style&gt;div&#123;height:100px;&#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 外联式（外链式）：将css代码单独放置在一个css文件中，再通过link标签将这个css文件引入到html文件中 媒介：link标签+选择器1&lt;link rel=&quot;stylesheet&quot; herf=&quot;css文件链接地址&quot; type=&quot;text/css&quot;&gt; css这个文件中不能出现标签 导入式：都是引入一个单独的css文件 媒介：@import”css文件链接地址”; 当有多个css文件的时候，可以使用导入式先导入到一个css文件中，再用外链式link外链进html文件 @import”css文件链接地址”;既不是html标签，也不是css属性，他是一条声明语句 这条语句必须写在style元素内,或者css文件内 这条语句必须在所在文件内的第一行 外链式和导入式的差别： link和@import虽然都是引入外部的css文件，但是他们是由天差地别的区别的 1) link是html标签，@import完全是css提供的方式，要写在css文件或者style标签中。 2) 他们的加载顺序也是有区别的，当一个页面被加载的时候，link引用的css文件会被同时加载，而@import引入的css文件会等页面全部下载完后再加载。 3) 当使用javascript控制DOM去改变css样式的时候，只能使用link标签，因为import是不能被DOM控制的。 在工作中常用的引入方式是外链式 四种引入方式的权重（一个html元素最终加载的css样式是谁决定的） 有行内式的时候，听行内的 在选择器相同的情况下，谁最后加载就听谁的 外链式和内嵌式一般都放在head元素内 CSS层叠样式表 css的作用： 给html文档添加静态或者动态的样式 css和html如何融合到一起 在css文件中如何选择一个html元素，将样式添加给这个元素","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS常用选择器","slug":"CSS常用选择器","date":"2017-06-30T07:14:52.000Z","updated":"2017-08-21T08:15:50.083Z","comments":true,"path":"2017/06/30/CSS常用选择器/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS常用选择器/","excerpt":"","text":"CSS选择器 因为html和css分离，那么就出现一个问题，如何选择一个元素，将样式添加给这个元素–&gt;css选择器 选择器是css属性和html元素的连接桥梁，通过正确的选择器来找到想要操作的元素，添加一定的样式。 选择器{} 1.语法选择器{key:value;key:value;} 可以批量选择选择器名称相同的元素 通过选择器类型不同，可以选择不同的html元素 2.CSS基础选择器分类1) 标签选择器 1-1).说明:直接使用元素标签进行选择 例如：&lt;p&gt;&lt;/p&gt; p{color:red;} 1-2).权重:11234&lt;style&gt;h1&#123;color:red;&#125;&lt;/style&gt;&lt;h1&gt;标签选择器&lt;/h1&gt; 2) 类选择器 2-1).说明: 1).将html元素的class标签属性值当作选择器使用，需要在这个属性值前面加一个“.” 2).通过元素的类名，来选择元素，一个元素可以有多个类名，都代表这个元素 3).类名是元素class属性中的属性值，例如(下例中的sum即为类名) 12&lt;p class=&apos;sum&apos;&gt;&lt;/p&gt;&lt;style&gt;.sum&#123;&#125;&lt;/style&gt; 4).一个html元素可以有多个css属性值（可以有多个类名，每一个类名之间用空格隔开） 5).类名可以重复使用 2-2).权重:10 类选择器最前方一定要有点,例如:123456&lt;style&gt;.title&#123;color:red;&#125;&lt;/style&gt;&lt;h1 class=&quot;title title1&quot;&gt;标签选择器&lt;/h1&gt;&lt;h1 class=&quot;title&quot;&gt;标签选择器&lt;/h1&gt;//以上class属性名为title中的文字颜色都讲被设置为红色 3) id选择器 3-1).说明: 1).一个html元素，id属性值只能用一次，id在html中具有唯一性 2).类选择器最前方一定要有# 3).通过元素的id名，来选择元素 4).类名是元素id属性中的属性值(title/title1)，例如:12345&lt;style&gt;#title&#123;color:red;&#125;&lt;/style&gt;&lt;h1 id=&quot;title title1&quot;&gt;id选择器&lt;/h1&gt;&lt;h1 id=&quot;title&quot;&gt;错误的，不识别&lt;/h1&gt; 3-2).权重:100 总结(根据权重)： 标签选择器相当于人的姓名,类选择器相当于人的名字,id选择器相当于身份证号码,是独一无二的。 4) 通配符选择器 4-1). 说明: 1).通过*匹配全部html元素，包括根元素 2).一般不使用，因为全部匹配耗性能 3)语法:*{}1*&#123;key:value&#125; 4-2). 权重&lt;1,可被覆盖 5) 并集选择器 5-1).说明: 1). 你可以对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。用逗号将需要分组的选择器分开。在下面的例子中，我们对所有的标题元素进行了分组。所有的标题元素都是绿色的。 例如：1h1,h2,h3,h4,h5,h6&#123;color:green;&#125; 6) 属性选择器 6-1).说明: 1). 对带有指定属性的 HTML 元素设置样式，可以为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。 下面的例子为带有 title 属性的所有元素设置样式：123[title]&#123; color:red; &#125; 2). 利用标签的属性名和属性值来选择html元素 3). 属性选择器在使用的时候，如果一个元素有两个类名，那么是不生效的。 4). 属性选择器我们一般不会使用class,因为class可以直接使用类选择器12345&lt;!--有多少种方法只获取div?--&gt; /*如果class值有两个，不能这样使用*/&lt;style&gt;[class=div1]&#123;&#125;;&lt;/style&gt;&lt;div class=&quot;div1 p1&quot; id=&quot;div2&quot;&gt;&lt;/div&gt;&lt;p class=&quot;p1&quot;&gt;&lt;/p&gt; 6-2). 语法： [标签属性名]{} [标签属性名=属性值]{}123456789&lt;style&gt;h1[title]&#123;&#125; //交集选择器//权重:标签+属性的权重=11[type]&#123;&#125;//权重：10[type=text]&#123;&#125;//权重:10&lt;/style&gt;&lt;a href=&quot;&quot; title=&quot;&quot;&gt;link&lt;/a&gt; 6-3). 权重:10 7)属性和值选择器 7-1). 说明: 1). 下面的例子为 title=”xx” 的所有元素设置样式： 1234[title=xx] &#123; border:5px solid blue; &#125; 2). 设置表单的样式 12345678input[type=&quot;text&quot;]&#123; width:150px; display:block; margin-bottom:10px; background-color:yellow; font-family: Verdana, Arial;&#125; 8)分组选择器 8-1).作用(应用场景): 1). 同一份css样式，可以一次性的添加给多个不同的html元素 8-2).语法： 选择器1,选择器2,选择器3{};例如:12.box,li,.p1&#123;color: red&#125;.box&#123;color:green&#125; 8-3).权重 1)分组选择器将不同的html分为一组，权重计算的时候都是独立计算，不会叠加。 9)交集选择器 9-1).一个元素具有两个属性(两种属性同属一个元素的时候)，可以使用交集选择器来进行元素的准确选择 9-2).组成选择器的两部分，必须属于同一个 反例(错误用法): 123&lt;style&gt;h1.p1&#123;&#125; //--&gt;什么都选择不到&lt;/style&gt;&lt;p class=&quot;p1&quot;&gt;&lt;/p&gt;&lt;h1&gt;&lt;/h1&gt; 正例(正确用法): 123456789&lt;p class=&apos;name1 name2&apos; id=&apos;id1&apos;&gt;&lt;/p&gt;&lt;style&gt;//第一种:p.name1&#123;&#125;//第二种:p#id1&#123;&#125;//第三种:.name1.name2&#123;&#125;&lt;/style&gt; 使用解说(正确用法): 1.组合选择器之间没有任何的符号和空格 2.标签选择器和其他选择器组合的时候，标签选择器要放在前面 3.交集选择器是两个选择器组合在一起，可以是1)标签和类名,2)标签和属性选择器,3)标签和id,4)两个类选择器。 9-3). 作用 精确查找元素，增加选择器的权重1234567891011121314151617181920212223242526&lt;style&gt;h1&#123;&#125;//标签选择器 权重:1[title]&#123;&#125;//属性选择器 权重:10[title=xx]&#123;&#125;//属性选择器 权重:10h2[title]&#123;&#125;//交集选择器 权重:11h2[title=xx]&#123;&#125;//交集选择器 权重:11&lt;/style&gt;&lt;h1 title=&quot;xx&quot;&gt;&lt;/h1&gt;&lt;h2 title=&quot;xx&quot;&gt;&lt;/h2&gt;&lt;style&gt;p.p1&#123;&#125;//交集选择器 权重:11&lt;/style&gt;&lt;p class=&quot;p1&quot;&gt;&lt;/p&gt;&lt;style&gt;.p1.p2&#123;&#125;//交集选择器 权重:20&lt;/style&gt;&lt;p class=&quot;p1 p2&quot;&gt;&lt;/p&gt; 10)子集选择器 10-1). 说明: 1). 与后代选择器相比，子元素选择器只能选择作为某元素子元素的元素。 2). 父级选择器是用来确定范围的， 3). 子级选择器才是我们要添加样式的那个元素 4). 子级选择器必须是紧邻的父子关系 10-2). 语法: 父级选择器&gt;子级选择器 10-3). 权重 所有选择器之和 1234567&lt;style&gt;ul&gt;li&#123;color:red;&#125;//选择ul下的li 权重:2&lt;/style&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 11)后代选择器(派生选择器) 11-1). 说明: 1). 在一个根元素的范围内，查找到它的后代元素 2). 后代选择器在写的时候尽量控制在３个左右 3). 选择器过多浪费性能，不建议使用 11-2). 举例: 1). html结构： 1234&lt;ol&gt; &lt;li&gt;&lt;strong&gt;我是斜体字。这是因为 strong 元素位于 li 元素内。&lt;/strong&gt; &lt;/li&gt;&lt;/ol&gt; 2). 列表中的 strong 元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器： 1234li strong &#123; font-style: italic; font-weight: normal; &#125; 3). 后代选择器在写的时候尽量控制在３个左右,选择器过多浪费性能: 12345678910&lt;style&gt;.div ul span&#123;&#125;&lt;/style&gt;&lt;div class=&quot;div&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;只选择这个span元素&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 11-3). 语法: 祖辈选择器 要查找的后代选择器{};(中间用空格连接) 12)相邻兄弟选择器 12-1). 说明: 1). 相邻兄弟选择器可选择紧接在另一元素后的元素，且二者有相同父元素。 2). 通过各个元素选择弟弟选择器,两个选择器之间用“+”连接;例如: h1 + p {margin-top:50px;} 12-2).语法: 哥哥选择器+弟弟选择器{};123456789101112&lt;style&gt; .list1+li&#123;color:red;&#125; //22222变为红色 .list3+li&#123;color:green;&#125; //4444变为绿色&lt;/style&gt;&lt;ul&gt; &lt;li class=&quot;list1&quot;&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li class=&quot;list3&quot;&gt;33333&lt;/li&gt; &lt;li&gt;4444&lt;/li&gt;&lt;/ul&gt; 12-3).权重:选择器之和 13)伪类选择器 13-1).说明: 1). 给一个元素添加某种状态 例如:鼠标经过时/获取焦点时/鼠标点击时 13-2). 权重:10 13-3).举例: 1). a标签 CSS 伪类用于向某些选择器添加特殊的效果 12345678910111213&lt;style&gt; a:link &#123;color: #FF0000&#125; /* 未访问的链接 是默认状态*/ a:visited &#123;color: #00FF00&#125; /* 已访问的链接 鼠标点击后的状态*/ a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 鼠标经过的状态*/ a:active &#123;color: #0000FF&#125; /* 选定的链接 鼠标点击的状态*/&lt;/style&gt;&lt;a href=&quot;javascript:void (0)&quot;&gt;最初形态&lt;/a&gt;&lt;a href=&quot;javascript:void 0&quot;&gt;赛亚人形态&lt;/a&gt;&lt;a href=&quot;javascript:&quot;&gt;超级赛亚人形态&lt;/a&gt; 2). input标签 1234567&lt;style&gt; .input&#123;border: 1px solid gainsboro&#125; .input:hover&#123;border-color: gray&#125; .input:focus&#123;border-color: blue&#125; /*input:focus 鼠标聚焦后的状态，input独有的属性*/&lt;/style&gt;&lt;input type=&quot;text&quot; class=&quot;input&quot;&gt; 14)CSS 伪元素 14-1). 说明: 1). 通过css代码向指定元素内添加假的（html中不存在的）元素 14-2). 举例: CSS 伪元素用于向某些选择器设置特殊效果 1)before “before”会出现在div所有内容之前 “:before”伪元素可以在元素的内容前面插入新内容。 下面的例子在每个 &lt;h1&gt; 元素前面插入内容:’我是一个伪元素’： 1234h1:before &#123; content:&apos;我是一个伪元素&apos;; &#125; 2)after 会出现在div所有内容之后使用伪元素的时候要保证两个前提 2-1)要有display这个属性 2-2)要有content这个属性，这个属性的属性值可以为空，但是引号不能少(content:&quot;&quot;): 12345678910111213141516171819202122&lt;style&gt; div&#123; width: 300px; height: 300px; background-color: red; &#125; div:before&#123; display: block; content: &quot;我是before&quot;; font-size: 40px; color: white; &#125; div:after&#123; display: block; content: &quot;我是aftre&quot;; font-size: 40px; color: blue; &#125;&lt;/style&gt;&lt;div&gt; &lt;span&gt;我是span&lt;/span&gt;&lt;/div&gt; 网页显示：“伪元素选择器” 注意1.选择器的查找机制 选择器的查找机制是从右向左,例如:123456&lt;style&gt;.div ul li&#123;&#125;&lt;!-- 第一步选择这个文档中所有的li第二步选择哪些li是ul下面的第三步选择哪些li是ul下面，ul还是.div1下面的 --&gt;&lt;/style&gt; 2.选择器的组成最好不要超过三个3.后代选择器没有必要将每一层元素都写出来，只写那些关键节点即可(具有代表性的)","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS中常用的HTML元素及标签","slug":"CSS中常用的HTML元素及标签","date":"2017-06-30T06:35:23.000Z","updated":"2017-08-16T15:32:09.916Z","comments":true,"path":"2017/06/30/CSS中常用的HTML元素及标签/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS中常用的HTML元素及标签/","excerpt":"","text":"常用的HTML标签总结 div 无意义标签，用来区分网页大模块，例如网页头部、主题内容、尾部&lt;div&gt;无意义元素，用它来区分网页大模块&lt;/div&gt;123456789banner&lt;div&gt;区分模块 &lt;a href=&quot;http://www.baidu.com&quot;&gt; &lt;img src=&quot;pic.jpg&quot; alt=&quot;备注/描述&quot;&gt; &lt;/a&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;&quot; alt=&quot;图片加载出问题了&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt; &lt;/a&gt;&lt;/div&gt; span 无意义标签,用来描述行内某个小模块 p &lt;p&gt;段落&lt;/p&gt; ul li 无序列表 ol li 有序列表 b 加粗 strong 加粗,浏览器解析的时候,有强调作用 body 身体,网页主体部分 （内容在浏览器可视区显示） a 超链接,描点123点击元素可以进行跳转的&lt;a href=&quot;链接路径&quot; target=&quot;_blank&quot;&gt;珠峰培训&lt;/a&gt;&lt;a href=&quot;pic.jpg&quot; target=&quot;_blank&quot;&gt;珠峰培训&lt;/a&gt; img 插入图片12&lt;img src=&quot;图片路径&quot; alt=&quot;备注/描述&quot;&gt;&lt;img src=&quot;pic.jpg&quot; alt=&quot;备注/描述&quot;&gt; i 作用：斜体 em 强调 作用：*斜体 h1-h6 标题 dl-dt-dd定义列表 常用在新闻标题和摘要 dt 定义标题 dd 定义描述 一个dt可以多个dd进行描述 标签 标签（由尖括号和关键字组成的超文本） 关键字（就是普通文本），在编辑html这门语言的时候，相关组织将这些文本归纳到了一定的规则中，是他有了特殊的含义和作用 标签的分类：开始标签、结束标签、空标签 12345678&lt;开始标签&gt;&lt;空标签 /&gt;&lt;div&gt;&lt;/div&gt;&lt;b&gt;&lt;/b&gt;&lt;strong&gt;&lt;/strong&gt;&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;···&lt;/结束标签&gt; 标签属性：用来描述标签功能的，一般写在开始标签中，跟在标签名的后面，用空格隔开，一个标签可以有很多标签属性，每一个属性都用空格隔开 12&lt;开始标签 属性名=&quot;属性值&quot; 属性名1=&quot;属性值&quot;&gt;&lt;结束标签&gt;&lt;img src=&quot;url&quot; alt=&quot;备注&quot; /&gt; html标签 html标签HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。 标签不会出现在页面中，只有标签中的内容才会显示在页面上 ：也就是&lt;html&gt;此处为内容&lt;/html&gt; 标签不区分大小写，但是推荐使用小写 ：(X)HTML 版本中强制使用小写，这样更加严谨 标签分为闭合标签和空标签 ：闭合标签是指由开始标签和结束标签组成的一对标签，这种标签允许嵌套和承载内容，例如：&lt;html&gt;&lt;/html&gt;、&lt;p&gt;&lt;/p&gt;；空标签是没有内容的标签，在开始标签中自动闭合，例如：&lt;img /&gt;、&lt;br /&gt;、&lt;hr /&gt;等 元素 由标签（开始和结束标签中有内容）和内容组成，元素中内容可以为空，一个空标签也叫做一个元素 12&lt;div&gt;content&lt;/div&gt;--&gt;div元素&lt;img src=&quot;url&quot; alt=&quot;备注&quot; /&gt;--&gt;img元素 标签属性经过html的进化，舍弃了有关样式的标签属性，保留功能的标签属性 例如舍弃width bgcolor align，这些样式描述都放在css里面 保留alt title src href··· iframe标签在引入其他文件的时候，必须写宽度和高度","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"“前端三层”","slug":"“前端三层”","date":"2017-06-30T06:26:17.000Z","updated":"2017-09-09T12:22:08.765Z","comments":true,"path":"2017/06/30/“前端三层”/","link":"","permalink":"http://yoursite.com/2017/06/30/“前端三层”/","excerpt":"","text":"前端三层 html结构 是直接被浏览器解析加载 CSS样式 是在html结构之上去装点网站 javascript 交互 动态效果/数据交互 基础知识 网页 网页是构成网站的基本元素，通俗来讲，一个html文件就是一个网页 网站 是由很多个网页组成的，共同为一个目标服务的网页集合 站群（流水线统一化管理） 由很多网站组成的，为同一个公司服务。 例如整个百度下所属的子公司都有自己的网站。例如：百度搜索/糯米/音乐/手机助手/百度金融等组成的就是一个站群。 HTTP（超文本传输协议） HyperText Transfer Protocol 在万维网上提供一种发布和接收HTML页面（网页）的方法。 eg：http://www.baidu.com 404服务器无响应 步骤: 输入网址，建立链接，建立客户端和服务端的连接。 发送请求信息：客户端发送一个请求给服务器 发送相应信息：服务器找到请求后，给予相应的响应信息 关闭连接：客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接 服务器 服务器，是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。 在网络环境下，根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，WEB服务器等。 防篡改：WEB端服务器一旦受到攻击，在0.0n秒做出反应，将内网服务器中的内容，马上覆盖在WEB服务器上。 负载均衡：平均WEB服务器压力，将用户访问进行分流。 vpn：用来翻墙，有指定账号就可以通过这个产品进行内网访问。 浏览器 浏览器是指可以显示网页服务器或者文件系统的HTML文件（标准通用标记语言的一个应用）内容，并让用户与这些文件交互的一种软件。 html，css，js都是运行在这个软件中，浏览器是一个工厂，html/css/js是工人和原料。 IE6–&gt;IE7（很快淘汰）–&gt;IE8(时间较长，稳定性好)–&gt;IE9(半年到一年)–&gt;IE10–&gt;IE11–&gt;IE11–&gt;IE(Edge) 最好用的浏览器–&gt;谷歌 网页的基本组成 HTML:是网页的骨架,支撑起血肉(文字,图片,音视频等) CSS:表皮和衣服、化妆品 javascript：动态和交互 HTML（超文本标记语言） 网页本身就是一种文本文件（除了文字再无其他），只有通过特定的标记描述，那些普通文本才能在浏览器中正常显示。 在页面中如果遇到图片、音视频的时候，如何用文本描述，需要用超文本进行引入才可以正常显示。 HTML文件的特点： 浏览器根据标记来解析和描述内容（从html的第一行开始向下），如果遇到错误，浏览器不会指出也不会报错，会跳过此处继续加载，编辑人员需要根据显示效果去分析哪里出错误了——html不会报错 HTML的兼容问题： 因为浏览器是由不同厂商生产的，所以对html的解析有分歧，产生了页面效果显示不一致的情况，我们将这个问题叫做兼容问题。 超文本（标签） 标签语法： 由成对的尖括号和关键字组成，叫做标签。 关键字（标签名）：是已经规范过的，不是自己随便制造的。 例如：&lt;div&gt; , &lt;/h2&gt; , &lt;img/&gt; 标签属性 属性提供了这个元素的更多信息，语法：由属性名和属性值组成（键值对 key=”value”） 1234&lt;span style=&quot;font-family:宋体;&quot; title=&quot;标题&quot;&gt;span是标签名style是标签属性名&quot;font-family:宋体;标签属性值 一个标签可以由多个标签属性，每一个属性之间用空格隔开 标签的分类: 开始标签 &lt;div&gt; 结束标签 &lt;/div&gt; 自闭合标签(空标签) &lt;br/&gt; HTML元素 可以将元素理解成一个容器，容器中放置的就是 由标签和内容组成的，叫做元素。 &lt;div&gt;此处是内容&lt;/div&gt; 元素分类 由开始标签和结束标签组成的元素，可以进行嵌套（一个元素包着另一个元素），元素中可以添加内容，只有一个空标签，只能进行功能的添加，例如img元素 标签和元素是用来标记和描述内容的，所以这些标签和元素用户是看不到的，用户只能看到这个元素的内容。","categories":[],"tags":[{"name":"前端常识","slug":"前端常识","permalink":"http://yoursite.com/tags/前端常识/"}]},{"title":"markdown的简单使用","slug":"markdown的简单使用","date":"2017-06-30T06:18:07.000Z","updated":"2017-08-16T15:25:32.687Z","comments":true,"path":"2017/06/30/markdown的简单使用/","link":"","permalink":"http://yoursite.com/2017/06/30/markdown的简单使用/","excerpt":"","text":"#–&gt; 一级标题 相当于html中的h1标签 [TOC]–&gt;目录 ##–&gt; 二级标题 相当于html中的h2标签 ###–&gt; 三级标题 相当于html中的h3标签 ####–&gt; 四级标题 相当于html中的h4标签 #####–&gt; 五级标题 相当于html中的h5标签 ######–&gt; 六级标题 相当于html中的h6标签 在每个段落或标题结束后 增加一个回车（一行空白） 普通段落相当于html中的p标签 列表： -+空格（-列表-） -+空格+tab（二级列表） -+空格+tab+tab（三级列表） 如何缩进 –&gt; 点击tab键 编辑新的内容（英文状态下，按住shift+“—”） &gt; (大于号加空格)–&gt; 摘要或标注编辑表格:左边有冒号代表左对齐,右边有冒号代表右对齐,两边都有冒号代表居中 快捷键：ctrl+alt+T |标题|标题|标题| |:—-|—-:|:—-:| |左对齐|右对齐|居中| 例如: 标题 标题 标题 左对齐左对齐左对齐 右对齐右对齐右对齐 居中居中居中居中 内容 内容 内容 编辑代码块&lt;div&gt;div&lt;/div&gt;123&lt;div&gt;div&lt;/div&gt;&lt;div&gt;div&lt;/div&gt;&lt;div&gt;div&lt;/div&gt; 编辑行内代码:独立的行间代码 html中的p标签：&lt;p&gt; 插入图片 可以直接复制粘贴 快捷键：ctrl+G 插入链接： ctrl+L 保存笔记的方法: 点击【账号】选择【导出】 –&gt; 可以导出md格式，pdf格式，html格式 md格式：再次打开时，可以使用文本文档打开，将内容复制一份粘到markdown软件中 pdf格式：直接观看，但不能修改 html格式：可以浏览器中直接观看，可以在代码编辑器中修改 快捷键： 文档管理 –&gt; Ctrl+O 帮助 –&gt; Ctrl+/ 最大化编辑器 –&gt; Ctrl+Enter 预览文档 –&gt; Ctrl+Alt+Enter 同步文档 –&gt; Ctrl+S 创建文档 –&gt; Ctrl+Alt+N 系统菜单 –&gt; Ctrl+M 斜体 –&gt; Ctrl+I 粗体 –&gt; Ctrl+B","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]},{"title":"Nodejs的全局对象和全局变量","slug":"Nodejs的全局对象和全局变量","date":"2017-06-27T06:32:40.000Z","updated":"2017-08-16T15:28:38.300Z","comments":true,"path":"2017/06/27/Nodejs的全局对象和全局变量/","link":"","permalink":"http://yoursite.com/2017/06/27/Nodejs的全局对象和全局变量/","excerpt":"","text":"全局对象 所有模块都可以调用 global：表示Node所在的全局环境，类似于浏览器中的window对象。 你可以通过console.log(global);来输出一下global; 1-1. global全局对象里常用的变量 1). __dirname 存储的是在nodejs中执行javascript所在的绝对目录 12 console.log(__dirname);//C:\\Users\\Gao\\Documents\\webstore学习文件\\node 2). __filename 文件名 12console.log(__filename);//C:\\Users\\Gao\\Documents\\webstore学习文件\\node\\global.js process 程序所执行的一些相关的内容信息的封装对象 指向Node内置的process模块，允许开发者与当前进程互动。 例如你在DOS或终端窗口直接输入node，就会进入NODE的命令行方式（REPL环境）。如果要退出的话，可以输入 process.exit(); 2-1. 和输出相关的 process.stdout/process.stderr 1) process.stdout –&gt; standard output –&gt; 标准的信息输出 2) process.stderr –&gt; standard error –&gt; 标准的错误输出 console.info和console.error这些相关的输出功能就是调用的process.stdout和process.stderr来完成的12process.stdout.write(&quot;this is stdout&quot;);process.stderr.write(&quot;this is stderr&quot;);//红色的 2-2. process如何去监听一些事件 1) process.stdin.on() 监听用户输入的键盘信息 2)process.on()监听操作系统对node发出的一些信号 2-3. 如何读取输入用户的键盘输入 1).process.stdin 在使用process.stdin之前 要先对他进行一下编码设置```process.stdin.setEncoding(“utf-8”);//这里的编码设置和平常编写网页时候的文本编码不一样//在这里如果想读取纯文本信息 只要把他的编码设置成utf-8就可以了 不需要去考虑类似jbk或者jb2312来区分是不是中文//on方法来监听用户相关的输入事件// process.stdin.on(“data”,function (data) {// console.log(data);// });process.stdin.on(“readable”,function () { var data=process.stdin.read(); //回调函数没有参数 需要通过process.stdin.read来读取用户的键盘输入信息 console.log(data);}); //exit事件process.on(“exit”,function () { console.log(“programe will exit”);});//在程序正常退出的之前 会触发exit事件 //SIGINT –&gt; signal interrupted 信号 被中断//当一个信号被中断的时候就会触发SIGINT事件(cmd 中 ctrl+c会中断信号) process.on(“SIGINT”,function () {//会改变程序默认的退出行为 console.log(“programe has a sigint”); process.exit();//让程序正常退出}); console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。通常是写console.log();全局函数 定时器函数：共有4个，分别是setTimeout(), clearTimeout(), setInterval(), clearInterval()。 require：用于加载模块 全局变量： _filename：指向当前运行的脚本文件名。 _dirname：指向当前运行的脚本所在的目录 准全局变量 模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。 module变量指代当前模块。module.exports变量表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。 module.id 模块的识别符，通常是模块的文件名。 module.filename 模块的文件名。 module.loaded 返回一个布尔值，表示模块是否已经完成加载。 module.parent 返回使用该模块的模块。 module.children 返回一个数组，表示该模块要用到的其他模块。 这里需要特别指出的是，exports变量实际上是一个指向module.exports对象的链接，等同在每个模块头部，有一行这样的命令。var exports = module.exports; 这造成的结果是，在对外输出模块接口时，可以向exports对象添加方法，但是不能直接将exports变量指向一个函数：exports = function (x){ console.log(x);}; 上面这样的写法是无效的，因为它切断了exports与module.exports之间的链接。 如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。","categories":[],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://yoursite.com/tags/Nodejs/"}]},{"title":"caller和callee","slug":"JS中的caller和callee","date":"2017-06-26T10:02:17.000Z","updated":"2017-08-16T15:33:35.844Z","comments":true,"path":"2017/06/26/JS中的caller和callee/","link":"","permalink":"http://yoursite.com/2017/06/26/JS中的caller和callee/","excerpt":"","text":"caller 检验函数被谁调用过 检验函数被谁调用过 返回值是调用这个函数的函数本身,没有的话返回nullarguments.callee 函数本身12345678910function Fn() &#123; console.log(arguments.callee.caller);//--&gt;function fn() &#123;Fn()&#125; //--&gt;arguments.callee 函数本身 //caller:检验函数被谁调用过 返回值是调用这个函数的函数本身,没有的话返回null console.log(Fn.prototype.constructor === arguments.callee);//--&gt;true&#125;function fn() &#123; Fn()&#125;fn(); 12345678910function sum(n) &#123; console.log(arguments.callee===arguments.callee.caller); //-&gt;第一次输出false，因为第一次是函数自己执行，即自调用 自调用的时候console.log(arguments.callee.caller) 输出null 而此时arguments.callee 函数本身仍然是sun函数本身 所以输出false; // --&gt;当自调用执行完成后 arguments.callee===arguments.callee.caller===sum这个函数本身 ---&gt; 返回true if(n&lt;=0)&#123; return 0 &#125; return n+sum(--n);&#125;console.log(sum(10));//55","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"JS中的同步异步编程思想","slug":"JS中的同步异步编程思想","date":"2017-06-23T14:22:04.000Z","updated":"2017-08-16T15:33:43.772Z","comments":true,"path":"2017/06/23/JS中的同步异步编程思想/","link":"","permalink":"http://yoursite.com/2017/06/23/JS中的同步异步编程思想/","excerpt":"","text":"JS是单线程的-&gt;JS就是个傻子,脑子一根筋,做着当前的这件事情,没有完成之前,绝对不会做下一件是事情 JS中的两种编程思想:同步、异步 1、同步编程-&gt;上一件事情没有完成,继续处理上一件事情,只有上一件事情完成了,才会做下一件事情(JS中大部分都是同步编程的) 123456for (var i = 0; i &lt; 100000; i++) &#123; if (i == 99999) &#123; console.log(&quot;循环结束了~~&quot;);//-&gt;(1) &#125;&#125;console.log(&quot;ok&quot;);//-&gt;(2) 1) for循环就是同步编程的,只有循环结束后,才会继续执行下面的代码 1234while (1) &#123;&#125;console.log(&quot;ok&quot;);//-&gt;永远都不会执行的,因为上面的循环是死循环,循环永远都不会结束 2、异步-&gt;规划要做一件事情,但是不是当前立马去执行这件事情,需要等一定的时间,这样的话,我们不会等着它执行,而是继续执行下面的操作,”只有当下面的事情都处理完成了,才会返回头处理之前的事情;如果下面的事情并没有处理完成,不管之前的事情有没有到时间,都踏踏实实的给我等着” 在JS中异步编程只有四种情况: 1)定时器都是异步编程的 2)所有的事件绑定都是异步编程的 3)Ajax读取数据的时候,我们一般都设置为异步编程 4)回调函数也是异步编程的123456var n = 0;window.setTimeout(function () &#123; n++; console.log(n);//-&gt;1 (2)&#125;, 1000);console.log(n);//-&gt;0 (1) 3.定时器 1) 每一个浏览器对于定时器的等待时间都有一个最小的值,谷歌:5~6ms IE:10~13ms,如果设置的等待时间小于这个值,不起作用,还是需要等到最小时间才执行的;尤其是写0也不是立即执行; 1234567var n = 0;window.setTimeout(function () &#123; n++; console.log(n);//-&gt;1 (2)&#125;, 0);console.log(n);//-&gt;0 (1)//--&gt;先输出0 再输出1 2) 我们定时器设置的等待时间不一定就是最后执行的时间,如果定时器之后还有其他的事情正在处理中,不管定时器的时间有没有到,都是不会执行定时器的 12345678910111213141516171819202122 var n = 0; window.setTimeout(function () &#123; n++; console.log(n);//-&gt;不执行的 &#125;, 0); console.log(n);//-&gt;0 (1) while (1) &#123;//-&gt;死循环 n++; &#125;console.log(n);//-&gt;不执行 var n = 0; window.setTimeout(function () &#123; n += 2; console.log(n); //-&gt;7 (4) &#125;, 20); window.setTimeout(function () &#123; n += 5; console.log(n); //-&gt;5 (3) &#125;, 5); console.log(n);//-&gt;0 (1) for (var i = 0; i &lt; 10000000; i++) &#123;&#125; console.log(n);//-&gt;0 (2) 3)事件绑定 123456var oLis=document.getElementsByTagName(&quot;li&quot;); for(var i=0;i&lt;oLis.length;i++)&#123; oLis[i].onclick=function()&#123; tabChange(i); &#125; &#125;","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"IE版本条件注释语句(全)","slug":"IE版本条件注释语句-全","date":"2017-06-20T08:47:12.000Z","updated":"2017-09-09T12:23:26.091Z","comments":true,"path":"2017/06/20/IE版本条件注释语句-全/","link":"","permalink":"http://yoursite.com/2017/06/20/IE版本条件注释语句-全/","excerpt":"","text":"123&lt;!--[if lt IE 9]&gt;&lt;script charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;js/html5.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 1、只有IE才能识别 123&lt;!--[if IE]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 因为只有IE5以上的版本才开始支持IE条件注释，所有“只有IE”才能识别的意思是“只有IE5版本以上”才能识别。 2、只有特定版本才能识别 123&lt;!--[if IE 8]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 识别特定的IE版本，高了或者低了都不可以。上例只有IE8才能识别。 3、只有不是特定版本的才能识别 123&lt;!--[if !IE 7]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 上例中特定IE7版本不能识别，其他版本都能识别，当然要在IE5以上。 4、只有高于特定版本才能识别 123&lt;!--[if gt IE 7]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 上例中只有高于IE7的版本才能识别。IE7无法识别。 5、等于或者高于特定版本才能识别 123&lt;!--[if gte IE 7]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 上例中IE7和更高的版本都能识别。 6、只有低于特定版本的才能识别 123&lt;!--[if lt IE 7]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 上例中只有低于IE7的版本才能识别，IE7无法识别。 7、等于或者低于特定版本的才能识别 123&lt;!--[if lte IE 7]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 上例中IE7和更低的版本可以识别。 关键词解释 上面那些代码好像很难记的样子，其实只要稍微解释一下关键字就很容易记住了。 lt ：就是Less than的简写，也就是小于的意思。 lte ：就是Less than or equal to的简写，也就是小于或等于的意思。 gt ：就是Greater than的简写，也就是大于的意思。 gte：就是Greater than or equal to的简写，也就是大于或等于的意思。 !：就是不等于的意思，跟javascript里的不等于判断符相同。 特别提示： １、有人会试图使用&lt;!–[if !IE]&gt;来定义非IE浏览器下的状况，但注意：条件注释只有在IE浏览器下才能执行，这个代码在非IE浏览下被当做注释视而不见。 ２、我们通常用IE条件注释根据浏览器不同载入不同css，从而解决样式兼容性问题的。其实它可以做的更多。它可以保护任何代码块——HTML代码块、JavaScript代码块、服务器端代码……看看下面的代码。12345&lt;!--[if IE]&gt;&lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;你使用的是IE浏览器！&quot;);&lt;/script&gt;&lt;![endif]--&gt; 12345678910111213141516171819202122232425262728293031323334353637&lt;!–[if !IE]&gt;&lt;!–&gt;&lt;!–&lt;![endif]–&gt;&lt;!–除IE外都可识别（IE10版本以上也可以识别）–&gt;&lt;!–[if IE]&gt;&lt;![endif]–&gt;&lt;!–IE9以及以下版本可识别–&gt;&lt;!–[if IE 5]&gt;&lt;![endif]–&gt;&lt;!–仅IE5可识别–&gt;&lt;!–[if IE 5.0]&gt;&lt;![endif]–&gt;&lt;!–仅IE5.0可识别–&gt;&lt;!–[if IE 5.5]&gt;&lt;![endif]–&gt;&lt;!–仅IE5.5可识别–&gt;&lt;!–[if IE 6]&gt;&lt;![endif]–&gt;&lt;!–仅IE6可识别–&gt;&lt;!–[if IE 7]&gt;&lt;![endif]–&gt;&lt;!–仅IE7可识别–&gt;&lt;!–[if IE 8]&gt;&lt;![endif]–&gt;&lt;!–仅IE8可识别–&gt;&lt;!–[if IE 9]&gt;&lt;![endif]–&gt;&lt;!–仅IE9可识别–&gt;&lt;!–[if lt IE 5]&gt;&lt;![endif]–&gt;&lt;!–IE5以下版本可识别–&gt;&lt;!–[if lt IE 5.0]&gt;&lt;![endif]–&gt;&lt;!–IE5.0以下版本可识别–&gt;&lt;!–[if lt IE 5.5]&gt;&lt;![endif]–&gt;&lt;!–IE5.5以下版本可识别–&gt;&lt;!–[if lt IE 6]&gt;&lt;![endif]–&gt;&lt;!–IE6以下版本可识别–&gt;&lt;!–[if lt IE 7]&gt;&lt;![endif]–&gt;&lt;!–IE7以下版本可识别–&gt;&lt;!–[if lt IE 8]&gt;&lt;![endif]–&gt;&lt;!–IE8以下版本可识别–&gt;&lt;!–[if lt IE 9]&gt;&lt;![endif]–&gt;&lt;!–IE9以下版本可识别–&gt;&lt;!–[if lte IE 5]&gt;&lt;![endif]–&gt;&lt;!–IE5以及IE5以下版本可识别–&gt;&lt;!–[if lte IE 5.0]&gt;&lt;![endif]–&gt;&lt;!–IE5.0以及IE5.0以下版本可识别–&gt;&lt;!–[if lte IE 5.5]&gt;&lt;![endif]–&gt;&lt;!–IE5.5以及IE5.5以下版本可识别–&gt;&lt;!–[if lte IE 6]&gt;&lt;![endif]–&gt;&lt;!–IE6以及IE6以下版本可识别–&gt;&lt;!–[if lte IE 7]&gt;&lt;![endif]–&gt;&lt;!–IE7以及IE7以下版本可识别–&gt;&lt;!–[if lte IE 8]&gt;&lt;![endif]–&gt;&lt;!–IE8以及IE8以下版本可识别–&gt;&lt;!–[if lte IE 9]&gt;&lt;![endif]–&gt;&lt;!–IE9以及IE9以下版本可识别–&gt;&lt;!–[if gt IE 5]&gt;&lt;![endif]–&gt;&lt;!–IE5以上版本可识别–&gt;&lt;!–[if gt IE 5.0]&gt;&lt;![endif]–&gt;&lt;!–IE5.0以上版本可识别–&gt;&lt;!–[if gt IE 5.5]&gt;&lt;![endif]–&gt;&lt;!–IE5.5以上版本可识别–&gt;&lt;!–[if gt IE 6]&gt;&lt;![endif]–&gt;&lt;!–IE6以上版本可识别–&gt;&lt;!–[if gt IE 7]&gt;&lt;![endif]–&gt;&lt;!–IE7以上版本可识别–&gt;&lt;!–[if gt IE 8]&gt;&lt;![endif]–&gt;&lt;!–IE8以上版本可识别–&gt;&lt;!–[if gt IE 9]&gt;&lt;![endif]–&gt;&lt;!–IE9以上版本可识别–&gt;&lt;!–[if gte IE 5]&gt;&lt;![endif]–&gt;&lt;!–IE5以及IE5以上版本可识别–&gt;&lt;!–[if gte IE 5.0]&gt;&lt;![endif]–&gt;&lt;!–IE5.0以及IE5.0以上版本可识别–&gt;&lt;!–[if gte IE 5.5]&gt;&lt;![endif]–&gt;&lt;!–IE5.5以及IE5.5以上版本可识别–&gt;&lt;!–[if gte IE 6]&gt;&lt;![endif]–&gt;&lt;!–IE6以及IE6以上版本可识别–&gt;&lt;!–[if gte IE 7]&gt;&lt;![endif]–&gt;&lt;!–IE7以及IE7以上版本可识别–&gt;&lt;!–[if gte IE 8]&gt;&lt;![endif]–&gt;&lt;!–IE8以及IE8以上版本可识别–&gt;&lt;!–[if gte IE 9]&gt;&lt;![endif]–&gt;&lt;!–IE9以及IE9以上版本可识别–&gt;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"DOS基本命令大全","slug":"DOS基本命令大全","date":"2017-06-20T06:41:46.000Z","updated":"2017-09-09T12:24:13.677Z","comments":true,"path":"2017/06/20/DOS基本命令大全/","link":"","permalink":"http://yoursite.com/2017/06/20/DOS基本命令大全/","excerpt":"","text":"基本命令 1、列出文件 ls 参数 目录名 例: 看看驱动目录下有什么:ls /System/Library/Extensions 参数 -w 显示中文，-l 详细信息， -a 包括隐藏文件 2、转换目录 cd 例：想到驱动目录下溜达一圈 cd /System/Library/Extensions 3、建立新目录 mkdir 目录名 例：在驱动目录下建一个备份目录 backup mkdir /System/Library/Extensions/backup 在桌面上建一个备份目录 backup mkdir /User/用户名/Desktop/backup 4、拷贝文件 cp 参数 源文件 目标文件 例：想把桌面的Natit.kext 拷贝到驱动目录中 cp -R /User/用户名/Desktop/Natit.kext /System/Library/Extensions 参数R表示对目录进行递归操作，kext在图形界面下看起来是个文件，实际上是个文件夹。 把驱动目录下的所有文件备份到桌面backup cp -R /System/Library/Extensions/* /User/用户名/Desktop/backup 5、删除文件 rm 参数 文件 例：想删除驱动的缓存 rm -rf /System/Library/Extensions.kextcache rm -rf /System/Library/Extensions.mkext 参数－rf 表示递归和强制，千万要小心使用，如果执行了 rm -rf / 你的系统就全没了 6、移动文件 mv 文件 例：想把AppleHDA.Kext 移到桌面 mv /System/Library/Extensions/AppleHDA.kext /User/用户名/Desktop 想把AppleHDA.Kext 移到备份目录中 mv /System/Library/Extensions/AppleHDA.kext /System/Library/Extensions/backup 7、文本编辑 nano 文件名 例：编辑natit Info.plist nano /System/Library/Extensions/Natit.kext/Info.plist 目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la 文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename 选择操作 命令名 功能描述 使用举例 head 显示文件的最初几行 head -20 filename tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 diff 比较并显示两个文件的差异 diff file1 file2 sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142 时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.NET.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftpftp.sp.net.edu.cn rcp 在本地主机与远程主机 之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的 几条命令及编号 history r 重复执行最近执行过的 某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir df /tmp 显示文件系统的总空间和可用空间 w 显示当前系统活动的总信息","categories":[],"tags":[{"name":"前端常识","slug":"前端常识","permalink":"http://yoursite.com/tags/前端常识/"}]},{"title":"Canvas动态案例","slug":"canvas动态案例","date":"2017-06-09T10:17:02.000Z","updated":"2017-09-09T12:26:32.983Z","comments":true,"path":"2017/06/09/canvas动态案例/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas动态案例/","excerpt":"","text":"12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;draw&quot; width=&quot;220&quot; height=&quot;320&quot; style=&quot;background-color: skyblue&quot;&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); var img=new Image; img.src=&apos;walkingdead.png&apos;;//添加图片地址 img.onload=function()&#123;//图片上有10张小图横着排列 var width=this.width/10; var height=this.height; var i=0; window.setInterval(function()&#123; cvs.clearRect(0,0,draw.width,draw.height);//清除上一个图片 cvs.drawImage(img,i*width,0,width,height,0,0,width,height); if(i==9)&#123; i=0 &#125;else&#123;i++;&#125; &#125;,200); &#125;&lt;/script&gt;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之8图形组合","slug":"canvas之8图形组合","date":"2017-06-09T09:41:16.000Z","updated":"2017-09-09T12:26:32.938Z","comments":true,"path":"2017/06/09/canvas之8图形组合/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之8图形组合/","excerpt":"","text":"图形组合 cvs.globalCompositeOperation=type; type的值: 1.source-over 默认值 覆盖 在原来的图形上绘制新图 新图在上 2.source-out 显示新图的非交集部分 3.source-in 显示新图和图形的交集，颜色是新图的颜色 4.source-atop 显示旧图和交集部分 交集是新图颜色 5.destination-over 在原来图形的下面绘制新图 旧图在上 6.destination-out 显示旧图的非交集部分 7.destination-in 显示交集 颜色是旧图颜色 8.destination-atop 显示新图和交集部分 交集是旧图颜色 9.lighter:全部显示 交集部分是叠加颜色 10.xor:显示新旧图的非交集部分 11.copy 只显示新图 案例1:在原来的图形上绘制新图 新图在上 12345678910var draw=document.getElementById(&apos;draw&apos;);var cvs=draw.getContext(&apos;2d&apos;);function draw1()&#123; cvs.fillStyle=&apos;gold&apos;; cvs.fillRect(10,10,100,100); cvs.globalCompositeOperation=&apos;source-over&apos;; cvs.fillStyle=&apos;pink&apos;; cvs.fillRect(50,50,100,100);&#125;draw1();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之7变形","slug":"canvas之7变形","date":"2017-06-09T09:19:54.000Z","updated":"2017-09-09T12:26:32.953Z","comments":true,"path":"2017/06/09/canvas之7变形/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之7变形/","excerpt":"","text":"平移translate(x,y);x:坐标原点向x轴平移的距离y:坐标原点向y轴平移的距离 案例 1234567891011121314function draw1()&#123; cvs.fillStyle=&apos;skyblue&apos;; //设置填充颜色天空蓝 cvs.fillRect(0,0,200,100); //矩形左上角坐标0,0 宽200px 高100px cvs.translate(50,50); //设置平移 坐标原点向x轴(向右)平移50px 坐标原点向y轴(向下)偏移50px //--&gt;这个平移只会对后面的矩形造成影响 不会影响前面的 cvs.fillStyle=&apos;pink&apos;; //设置填充颜色粉色 cvs.fillRect(0,0,180,80); //矩形左上角坐标0,0 宽180px 高80px&#125;draw1(); 缩放 vas.scale(x0,y0);x0:x轴按照x0的比例缩放y0:y轴按照x0的比例缩放 案例 12345678function draw2()&#123; cvs.scale(1,2);//设置缩放 x轴不变 y轴是之前的2倍 cvs.fillStyle=&apos;plum&apos;;//设置填充样式为颜色填充 cvs.fillRect(0,0,200,100); //矩形左上角坐标0,0 宽200px 高100px //--&gt;那么转化后的矩形宽200px 高200px&#125;draw2(); 3.旋转 vas.rotate(angle); angle:坐标轴转的角度 他是一个弧度(和画圆的计算是一样的) 案例 123456function draw3()&#123; cvs.rotate(Math.PI/4);//设置旋转 旋转角度为45度 cvs.fillStyle=&apos;lightblue&apos;; cvs.fillRect(100,100,200,100);&#125;draw3(); 注意：平移、缩放、旋转都是对原始坐标（画布）操作的 例如:1234567function draw3()&#123; cvs.translate(200,0);//此时的原点已经变到200,0的位置 cvs.rotate(Math.PI/4);//设置旋转 旋转角度为45度 cvs.fillStyle=&apos;lightblue&apos;; cvs.fillRect(100,100,200,100);&#125;draw3();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之6绘制图片","slug":"canvas之6绘制图片","date":"2017-06-09T08:51:59.000Z","updated":"2017-09-09T12:26:32.922Z","comments":true,"path":"2017/06/09/canvas之6绘制图片/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之6绘制图片/","excerpt":"","text":"绘图 cvs.drawImage(Image,x,y,w,h); Image 就是可以放在DOM中的真实图片，可以动态创建，也可以获取页面上的 x,y 图片放入画布,在画布左上角的坐标 w,h 绘制图片的宽高 案例:将图片放在画布上 123456789function draw1()&#123; var img=new Image;//动态创建一个img img.src=&apos;default.gif&apos;;//添加图片链接 img.onload=function()&#123;//如果图片地址真实存在 执行这个函数 cvs.drawImage(this,0,100,100,90); //将图片放在画布上 图片左上角的坐标0,100 图片宽100px 高90px &#125;&#125;draw1(); cvs.drawImage(img_elem,sx,sy,sw,sh,dx,dy,dw,dh); sx,sy 图片左上角的坐标 sw,sh 矩形区域的宽高 用来截取图片 dx,dy 截取出来放在画布canvas上的坐标 dw,dh 画在canvas上的宽高 总结: sw,sy,sx,sy 是用来截取图片的过程 dx,dy,dw,dh 把截取出来的图片放在canvas上的过程 案例:截取图片 123456789 function draw2()&#123; var img=new Image;//动态创建一个img img.src=&apos;1.jpg&apos;;//添加图片链接 img.onload=function()&#123;//如果图片地址真实存在 执行这个函数 cvs.drawImage(this,480,150,440,410,0,0,200,200); //this就是img 将图片放在画布上 需要截取的图片在原图片左上角的坐标480,150 截取图片的大小为440px*410px 截取出来的图片放入画布的坐标0,0 截取出来的图片画在画布canvas的宽200px 高200px &#125; &#125;// draw2(); 设置平铺 cvs.creatPattern(image,type) Image 就是可以放在DOM中的真实图片，可以动态创建，也可以获取页面上的 type: no-repeat 不平铺 repeat 全方向平铺 repeat-x x轴方向平铺 repeat-y y轴方向平铺 案例 123456789101112function draw3()&#123; var img=new Image; img.src=&apos;default.gif&apos;; img.onload=function()&#123; var rep=cvs.createPattern(this,&apos;repeat&apos;);//设置图片平铺 cvs.fillStyle=rep;//设置填充样式为图片平铺 cvs.fillRect(0,0,draw.width,draw.height); //draw.width画布的宽 draw.height画布的高 //设置填充矩形 矩形左上角坐标0,0 矩形的宽为画布的宽 矩形的高为画布的高 &#125;&#125;//draw3();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之4渐变","slug":"canvas之4渐变","date":"2017-06-09T06:56:44.000Z","updated":"2017-09-09T12:26:33.011Z","comments":true,"path":"2017/06/09/canvas之4渐变/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之4渐变/","excerpt":"","text":"1.线性渐变 var CLG=cvs.createLinearGradient(x0,y0,x1,y1); x0:渐变开始的x坐标 y0:渐变开始的y坐标 x1:渐变结束的x坐标 y1:渐变结束的y坐标 CLG.addColorStop(n,m); n:设置颜色的偏移量 m:颜色 例如: 12345678910111213function draw1()&#123; var CLG=cvs.createLinearGradient(0,0,200,200); //创建一个线性渐变 渐变开始的坐标0,0 渐变结束的坐标200,200 (即从左上角到右下角渐变) CLG.addColorStop(0,&apos;red&apos;);//设置渐变的偏移量0% 颜色红色 CLG.addColorStop(0.25,&apos;yellow&apos;);//设置渐变的偏移量25% 颜色黄色 CLG.addColorStop(0.5,&apos;skyblue&apos;);//设置渐变的偏移量50% 颜色天空蓝 CLG.addColorStop(0.75,&apos;orange&apos;);//设置渐变的偏移量75% 颜色橘黄 CLG.addColorStop(1,&apos;pink&apos;);//设置渐变的偏移量100% 颜色粉色 cvs.fillStyle=CLG;//设置填充样式是线性渐变 cvs.fillRect(0,0,200,200);//设置填充矩形 左上角坐标0,0 宽200px 高200px cvs.fill();//设置样式为填充样式&#125;draw1(); 2.径向渐变(发散性渐变) cvs.createRadialGradient(x0,y0,x1,y1,r1); x0:发散渐变开始中心的x坐标 y0：发散渐变开始中心的y坐标 r0:发散渐变开始的半径 x1:发散渐变结束中心的x坐标 y1：发散渐变结束中心的y坐标 r1:发散渐变结束的半径 例如:1234567891011121314function draw2()&#123; var CRG=cvs.createRadialGradient(200,200,200,200,200,10); //创建一个径向/发散性渐变 渐变开始的坐标200,200 渐变开始的半径200px 渐变结束的坐标200,200 渐变结束的半径10px CRG.addColorStop(0,&apos;purple&apos;); CRG.addColorStop(0.2,&apos;yellow&apos;); CRG.addColorStop(0.4,&apos;pink&apos;); CRG.addColorStop(0.6,&apos;lightblue&apos;); CRG.addColorStop(0.8,&apos;skyblue&apos;); CRG.addColorStop(1,&apos;white&apos;); cvs.fillStyle=CRG;//设置填充样式是径向渐变 cvs.fillRect(100,100,200,200); //设置填充矩形 左上角坐标100,100 宽200px 高200px&#125;draw2();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之3绘制矩形","slug":"canvas之3绘制矩形","date":"2017-06-09T05:07:19.000Z","updated":"2017-09-09T12:26:32.991Z","comments":true,"path":"2017/06/09/canvas之3绘制矩形/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之3绘制矩形/","excerpt":"","text":"cvs.fillRect(x,y,w,h); –&gt; 填充矩形 x,y 是这个矩形左上角的坐标 w,h 是这个矩形的宽高 cvs.strokeRect(x,y,w,h); –&gt; 带边框的矩形 x,y 是这个矩形左上角的坐标 w,h 是这个矩形的宽高 注意:如果设置边框 边框一半在里面一半在外面 cvs.clearRect(x,y,w,h); –&gt; 清除填充图的某一部分，清除的还是一个矩形 x,y 是这个矩形左上角的坐标 w,h 是这个矩形的宽高案例 案例1 12345678910function draw1()&#123; //填充矩形 cvs.fillStyle=&apos;#fccdda&apos;;//画之前填充颜色 cvs.fillRect(10,20,100,50);//设置填充矩形,矩形的左上角坐标为10,20 宽100px 高50px //边框矩形 cvs.strokeStyle=&apos;red&apos;;//设置边框的矩形边框颜色 cvs.lineWidth=20;//设置边框宽度20px cvs.strokeRect(150,20,100,50);//设置边框矩形， 矩形的左上角坐标为150,20 宽100px 高50px&#125;draw1(); 案例2 12345678910111213function draw2()&#123;//清除填充图的某一部分，清除的还是一个矩形cvs.clearRect(x,y,w,h) cvs.fillStyle=&apos;orange&apos;; //画之前填充颜色 cvs.fillRect(20,100,300,100); //设置填充矩形,矩形左上角坐标为20,100 宽300px 高100px cvs.clearRect(140,140,60,60); //清除填充图的矩形 清除的这个矩形左上角坐标140,140 宽60px 高60px cvs.clearRect(20,100,40,40); //清除填充图的矩形 清除的这个矩形左上角坐标20,100 宽40px 高40px cvs.clearRect(280,100,40,40); //清除填充图的矩形 清除的这个矩形左上角坐标280,100 宽40px 高40px&#125;draw2();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之5绘制文本","slug":"canvas之5绘制文本","date":"2017-06-09T04:55:35.000Z","updated":"2017-09-09T12:26:33.005Z","comments":true,"path":"2017/06/09/canvas之5绘制文本/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之5绘制文本/","excerpt":"","text":"1.阴影 cvs.shadowOffsetX//阴影的横向偏移量，默认值是0 cvs.shadowOffsetY//阴影的纵向偏移量，默认值是0 cvs.shadowColor//阴影的颜色 cvs.shadowBlur//阴影的模糊范围（值越大越模糊） 案例 123456789function draw1()&#123; cvs.shadowColor=&apos;#000fff&apos;;//设置阴影颜色 cvs.shadowOffsetX=30;//设置阴影的横向偏移量30px cvs.shadowOffsetY=20;//设置阴影的纵向偏移量20px cvs.shadowBlur=20;//设置阴影的模糊范围20px cvs.fillStyle=&apos;#449fdb&apos;;//设置填充的样式为颜色填充 cvs.fillRect(50,50,100,100);//设置填充矩形 左上角坐标50,50 宽100px 高100px&#125;draw1(); 2.绘制文本 设置字体样式 cvs.font=’字体大小font-size 字体样式font-family’ 水平对齐方式 cvs.textAlign(start,end,right,center); 垂直对齐方式 cvs.textBaseline=’’ 属性值:top,middle,hangle,bottom,alphabetic,ideographic 计算文本长度 var text=’dfbzbh’ console.log(cvs.measureText(text));//width:40.453125 填充文字 cvs.fillText(text,x,y,maxWidth); 1) text:文本内容 2) x:文字起始点的横坐标 3) y:文字起始点的纵坐标 绘制文字轮廓 cvs.strokeText(text,x,y,maxWidth); 1) text:文本内容 2) x:文字起始点的横坐标 3) y:文字起始点的纵坐标 案例1 12345678910function draw1()&#123; cvs.shadowColor=&apos;#000fff&apos;;//设置阴影颜色 cvs.shadowOffsetX=30;//设置阴影的横向偏移量30px cvs.shadowOffsetY=20;//设置阴影的纵向偏移量20px cvs.shadowBlur=20;//设置阴影的模糊范围20px cvs.fillStyle=&apos;#449fdb&apos;;//设置填充的样式为颜色填充 cvs.fillRect(50,50,100,100); //设置填充矩形 左上角坐标50,50 宽100px 高100px &#125; draw1(); 案例2 1234567891011121314151617function draw2()&#123; var text=&apos;hellow word&apos;;//设置文本内容 cvs.fillStyle=&apos;yellow&apos;;//设置填充样式颜色 cvs.font=&apos;40px verdana&apos;;//设置字体样式 cvs.textAlign=&apos;start&apos;;//设置字体的水平对齐方式 cvs.textBaseline=&apos;top&apos;;//设置字体的垂直对齐方式 cvs.fillText(text,10,10); //设置填充文字 文本内容text 文本起始点坐标10,10 var length=cvs.measureText(text); //获取文本宽度(长度)length console.dir(length); //TextMetrics--&gt;width:241.171875 //==&gt;length.width字体的宽度 cvs.fillText(&quot;字体长度为&quot;+length.width,10,60); //设置填充文字(通过字符串拼接方式) 文本起始点坐标10,60&#125;draw2(); 案例3:文本线性渐变 123456789101112131415161718192021222324function draw3()&#123; var CLG=cvs.createLinearGradient(0,0,300,100); //创建一个线性渐变 渐变开始的坐标0,0 渐变结束的坐标300,100 CLG.addColorStop(0,&apos;skyblue&apos;);//设置渐变的偏移量0% 天空蓝 CLG.addColorStop(0.25,&apos;plum&apos;);//设置渐变的偏移量25% 紫色 CLG.addColorStop(0.5,&apos;lightblue&apos;);//设置渐变的偏移量50% 蓝 CLG.addColorStop(0.75,&apos;skyblue&apos;);//设置渐变的偏移量75% 天空蓝 CLG.addColorStop(1,&apos;plum&apos;);//设置渐变的偏移量100% 紫色 var text=&apos;hellow word&apos;;//设置文本内容 cvs.fillStyle=CLG;//设置填充样式是线性渐变 cvs.shadowOffsetX=5;//设置阴影的横向偏移量5px cvs.shadowOffsetY=4;//设置阴影的纵向偏移量4px cvs.shadowColor=&apos;#ffb6c1&apos;;//设置阴影的颜色 cvs.shadowBlur=5;//设置阴影的模糊度 cvs.font=&apos;40px cursive&apos;;//设置字体样式 cvs.textAlign=&apos;top&apos;;//设置字体的水平对齐方式 cvs.fillText(text,50,150); //设置填充文字text 文本起始点坐标50,150 var width=cvs.measureText(text).width;//获取文本宽度(长度)length cvs.fillText(&quot;字体长度为：&quot;+width,10,200); //设置填充文字(通过字符串拼接方式) 文本起始点坐标10,200 &#125; draw3(); 案例4:文本径向渐变 123456789101112131415161718function draw4()&#123; var CRG=cvs.createLinearGradient(0,0,600,0,0,20); //创建一个径向渐变 渐变开始的坐标0,0 开始渐变的半径600px 渐变结束的坐标0,0 渐变结束的半径20px CRG.addColorStop(0,&apos;pink&apos;); CRG.addColorStop(0.25,&apos;skyblue&apos;); CRG.addColorStop(0.5,&apos;yellow&apos;); CRG.addColorStop(0.75,&apos;plum&apos;); CRG.addColorStop(1,&apos;skyblue&apos;); var text=&apos;I WANT EAT&apos;; cvs.fillStyle=CRG;//设置填充样式是径向渐变 cvs.font=&apos;80px simsun&apos;;//设置字体样式 cvs.textAlign=&apos;start&apos;;//设置文本横向对齐方式 cvs.textBaseline=&apos;top&apos;;//设置文本纵向对齐方式 cvs.shadowColor=&apos;lightblue&apos;;//设置阴影颜色 cvs.shadowBlur=10;//设置阴影的模糊范围10px cvs.fillText(text,10,10);//设置填充文字text 文本起始点坐标10,10&#125;draw4();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之2画圆","slug":"canvas之2画圆","date":"2017-06-08T11:56:51.000Z","updated":"2017-09-09T12:26:32.970Z","comments":true,"path":"2017/06/08/canvas之2画圆/","link":"","permalink":"http://yoursite.com/2017/06/08/canvas之2画圆/","excerpt":"","text":"cvs.arc(x,y,radius,startAngle,endAngle,anticlokwise); x,y 圆心坐标 radius半径r startAngle 起始角 以弧度计算(钟表的3点钟方向是0度,也就是x轴的正方向是0度,默认是顺时针) endAngle 结束角 anticlokwise 是否逆时针 默认值false false表示顺时针 案例 案例1:边框半圆 123456789function draw1()&#123;//边框圆 cvs.strokeStyle=&apos;#ffa50&apos;;//设置笔触样式(边框样式)颜色 cvs.beginPath();//开始一个路径 cvs.arc(500,500,100,0,Math.PI);//圆心坐标是500,500，半径是100px，起始角为0度，结束角为180度 cvs.closePath();//结束路径 cvs.lineWidth=10;//边框宽度为10px cvs.stroke();//绘制图形以边框样式绘制&#125;draw1(); 案例2:同心圆 12345678910111213141516171819202122function draw2()&#123; cvs.fillStyle=&apos;orange&apos;; cvs.beginPath(); //开始一个新的路径 cvs.arc(200,200,60,Math.PI/2,2*Math.PI); //圆心坐标是(200,200),半径为60px,起始角为90度,结束角为360度 cvs.closePath(); //结束一个路径 cvs.fill(); //绘制图形以填充样式绘制 cvs.strokeStyle=&apos;yellow&apos;; //设置 笔触样式(边框样式) 为黄色 cvs.lineWidth=40; //边框的宽度为40px cvs.beginPath(); //开始一个新的路径 cvs.arc(200,200,80,0,2*Math.PI); //圆心坐标是(200,200),半径为80px,起始角度为0度,结束角度为360度 cvs.closePath();//结束一个路径 cvs.stroke();//绘制图形以边框样式绘制&#125;draw2(); 案例3:每次调用fill绘制填充图的时候，会把当次路径的起始点和结束点分别连接，填充闭合部分(如果想让每个路径互不干扰 一定要记得写结束路径–&gt;关闭路径) 12345678910111213function draw3()&#123; cvs.strokeStyle=&apos;pink&apos;;//设置笔触样式(边框样式)颜色为粉色 cvs.beginPath();//开始一个路径 cvs.lineWidth=2;//边框的宽度为2px cvs.arc(100,100,100,0,Math.PI);//圆心坐标是100,100,半径为100,起始角度为0度,结束角度为180度 cvs.closePath();//结束一个路径 cvs.stroke();//绘制图形以边框样式绘制 cvs.fillStyle=&apos;gray&apos;;//设置填充颜色为灰色 cvs.arc(300,300,80,0,Math.PI/2);//圆心坐标是300,300，半径是80px，起始角度为0，结束角度为90度 cvs.closePath(); cvs.fill();&#125;draw3();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之1绘制线条的有关属性和步骤","slug":"canvas之1绘制线条的有关属性和步骤","date":"2017-06-08T11:44:17.000Z","updated":"2017-09-09T12:26:33.022Z","comments":true,"path":"2017/06/08/canvas之1绘制线条的有关属性和步骤/","link":"","permalink":"http://yoursite.com/2017/06/08/canvas之1绘制线条的有关属性和步骤/","excerpt":"","text":"&lt;canvas id=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt;&lt;/canvas&gt;canvas :H5标签 在页面上绘制图形用的（通常称他画布）canvas只是一个容器，我们用js脚本来控制他&lt;canvas id=&quot;draw&quot; width=&quot;600&quot; height=&quot;500&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; 绘制线条的有关属性和步骤 1.相关属性 1.填充的样式 cvs.fillStyle --&gt;fillStyle`填充样式 cvs.strokeStyle --&gt;strokeStyle笔触样式 主要用来画边框的 cvs.lineWidth --&gt; 边框的宽度 2.绘制图形有两种方式 cvs.fill(); --&gt; 填充样式 cvs.stroke(); --&gt; 边框样式 3.颜色值的四种书写方式 1).颜色名 –&gt;”red” 2).十六进制 –&gt;”#fff” 3).三色值 –&gt;rgb(0,0,0) 4).四色值 –&gt;rgba(0,0,0,0.3) 4.坐标: 1.)以画布为基准,距离画布的上边是y坐标值(top值),距离画布的左边是x坐标值(left值); cvs.moveTo(x,y); –&gt; 起始点坐标 cvs.lineTo(x,y); –&gt; 结束点的坐标 如果没有moveTo就把上一个挨着的lineTo作为起始坐标 例如:假如第一个不是moveTo而是lineTo,那么lineTo就是其实坐标 5.开始和关闭一个路径 cvs.beginPath(); –&gt; 开始一个新的路径 cvs.closePath(); –&gt; 关闭当前路径 注意:加上.closePath会自动闭合 会自动连接起始坐标和结束坐标 6.canvas中的圆角 1).设置线条交汇处的样式 cvs.lineJoin 他有三个属性： 1).尖角miter 2).斜角bevel 3).圆角round 2).设置一条线段两端点的样式 lineCap焦点样式 1)平的butt(默认值) 2.)圆角round 3.)方角square 2.步骤及案例 步骤1.获取出canvas标签,例如:var draw=document.getElementById(&#39;draw&#39;); 步骤2.设置绘制环境–2d 平面图,例如: 12var cvs=draw.getContext(&apos;2d&apos;);//cvs 这个就是你的画板 接下来就可以在cvs上进行绘制 步骤3 案例1:线段 123456789101112function draw1()&#123;var draw=document.getElementById(&apos;draw&apos;);var cvs=draw.getContext(&apos;2d&apos;);cvs.beginPath();cvs.moveTo(50,50);cvs.lineTo(150,50);cvs.closePath();cvs.strokeStyle=&apos;#800080&apos;;cvs.lineWidth=5;cvs.stroke();//以边框的形式显示&#125;draw1(); 案例2:等腰直角三角形 12345678910111213function draw2()&#123; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); cvs.beginPath(); cvs.lineTo(80,120); cvs.lineTo(80,240); cvs.lineTo(200,240); cvs.closePath(); cvs.strokeStyle=&apos;ec568c&apos;; cvs.lineWidth=10; cvs.stroke();&#125;draw2(); 案例3:圆角矩形 12345678910111213function draw3()&#123; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); cvs.beginPath(); cvs.lineCap=&apos;round&apos;; cvs.lineTo(50,50); cvs.lineTo(250,50); cvs.closePath();//关闭就没有圆角效果 cvs.lineWidth=100; cvs.strokeStyle=&apos;#896446&apos;; cvs.stroke();&#125;draw3(); 案例4:圆角三角形 1234567891011121314function draw4()&#123; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); cvs.beginPath(); cvs.lineJoin=&apos;round&apos;;//设置圆角 cvs.moveTo(200,100); cvs.lineTo(100,250); cvs.lineTo(300,250); cvs.closePath(); cvs.lineWidth=50; cvs.strokeStyle=&apos;#896446&apos;; cvs.stroke();&#125;draw4();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"字符串中的几个重要方法","slug":"JS字符串中的几个重要方法","date":"2017-06-02T12:03:49.000Z","updated":"2017-08-16T15:25:32.698Z","comments":true,"path":"2017/06/02/JS字符串中的几个重要方法/","link":"","permalink":"http://yoursite.com/2017/06/02/JS字符串中的几个重要方法/","excerpt":"","text":"1.通过索引查找字符串1) charAt(索引) 字符串上的charAt方法里边传索引值，进行搜索指定索引位置的字符，还是字符串格式;原字符串不变2) charCodeAt（索引） 返回结果对应的是ASCII码;原字符串不变例如:12345var str = &apos;addias&apos;;console.log(str.charAt(0),str);//&quot;a&quot; &quot;addias&quot; 原字符串不变console.log(str.charCodeAt(0),str);//97 &quot;addias&quot; 原字符串不变 2.检取字符串 substr(n,m); 从索引n开始截取m个 返回值为截取的字符串 原有字符串不变12var str = &apos;addias&apos;;console.log(str.substr(1, 2),str);//&quot;dd&quot; &quot;addias&quot; 1). str.substr();// 复制字符串 2). str.substr(0);// 复制字符串12345var str = &apos;addias&apos;;console.log(str.substr(),str);//&quot;addias&quot; &quot;addias&quot; 复制字符串console.log(str.substr(0),str);//&quot;addias&quot; &quot;addias&quot; 复制字符串 subString(n,m) 从索引n找到索引m之前，不包含m处;原字符串不变123var str = &apos;addias&apos;;console.log(str.substring(3, 4),str);//&quot;i&quot; &quot;addias&quot; substring(0); 克隆字符串 substring(); 克隆字符串12345var str = &apos;addias&apos;;console.log(str.substring(0),str);//&quot;addias&quot; &quot;addias&quot;console.log(str.substring(),str);//&quot;addias&quot; &quot;addias&quot; slice 字符串也可以使用slice1234var str = &apos;addias&apos;;console.log(str.slice(-1+str.length));//sconsole.log(str.slice(-1)); //s 同数组的使用方法一样console.log(str.slice(-2)); //as 同数组的使用方法一样 4.indexOf();字符串中当前字符出现的第一个索引;lastIndexOf();字符串中当前字符出现的最后一个索引;123var str = &apos;addias&apos;;console.log(str.indexOf(&apos;f&apos;));//-1console.log(str.lastIndexOf(&apos;a&apos;));//4 5.toUpperCase();字符串转化成大写;toLowerCase();字符串转化成小写123456var str = &apos;addias&apos;;console.log(str.toUpperCase(), str);// &quot;ADDIAS&quot; &quot;addias&quot; 字符串转化成大写var str = &apos;ADDIAS&apos;;console.log(str.toLowerCase(), str);//&quot;addias&quot; &quot;ADDIAS&quot; 字符串转化成小写 6.replace 替换字符串中的字符;原字符串不变1234var str1 = &apos;珠,峰,珠,训&apos;;var str2 = &apos;sdasdasdasdasd&apos;;console.log(str1.replace(&apos;珠&apos;, &apos;zhu&apos;), str1);//&quot;zhu,峰,珠,训&quot; &quot;珠,峰,珠,训&quot; 6.split 将字符串拆分成数组;将字符串以字符串中存在的指定分隔符拆分成数组12345678910var str1 = &apos;珠,峰,珠,训&apos;;var str2 = &apos;sdasdasdasdasd&apos;;console.log(str2.split(&apos;a&apos;));//(5) [&quot;sd&quot;, &quot;sd&quot;, &quot;sd&quot;, &quot;sd&quot;, &quot;sd&quot;]console.log(str2.split());//[&quot;sdasdasdasdasd&quot;]console.log(str1.split(&apos;,&apos;));//[&quot;珠&quot;, &quot;峰&quot;, &quot;珠&quot;, &quot;训&quot;]console.log(str1.split(&apos;&apos;));//[&quot;珠&quot;, &quot;,&quot;, &quot;峰&quot;, &quot;,&quot;, &quot;珠&quot;, &quot;,&quot;, &quot;训&quot;]","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"JS中的作用域","slug":"JS中的作用域","date":"2017-04-29T04:27:46.000Z","updated":"2017-08-16T15:24:43.919Z","comments":true,"path":"2017/04/29/JS中的作用域/","link":"","permalink":"http://yoursite.com/2017/04/29/JS中的作用域/","excerpt":"","text":"内存1.堆内存：来存储东西的，一般来存储引用数据类型2.栈内存：代码执行空间，作用域作用域两种：全局作用域：一打开浏览器就会形成私有作用域：函数执行形成的作用域函数执行的时候1.函数一执行，形成一个私有作用域2.有形参数的话给形参数赋值，相当于var 一个变量，function s(a){},s(1)-&gt;var a=1;3.预解释4.代码执行私有变量：1.形参2.在私有作用域中声明的变量，var过和function过得记住：私有变量只能私有作用域自己使用，别人获取不到 闭包：函数执行的时候形参一个私有作用域，来保护里面的私有变量不受外界干扰，这种机制叫做闭包","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"JS中的预解释","slug":"JS中的预解释","date":"2017-04-29T02:29:55.000Z","updated":"2017-08-16T15:33:48.719Z","comments":true,"path":"2017/04/29/JS中的预解释/","link":"","permalink":"http://yoursite.com/2017/04/29/JS中的预解释/","excerpt":"","text":"预解释的基础知识 例子 1234567console.log(d);//--&gt;function d()&#123;&#125;;d=1;//--&gt;d=1s=d;//--&gt;s=1function d()&#123;//--&gt;xxxfff000&#125;d();//--&gt;d is not a function 1.预解释: 是一个过程，作用域形成之后，代码执行之前，把所有带var关键字和function提前声明或定义 2.作用域： 1). 全局作用域：window下，一打开浏览器就会形成 2). 私有作用域：一个函数就是一个私有作用域，函数一执行就会形成私有作用域 3.声明: 告诉浏览器这里有个变量，var关键字的只有声明 4.定义: 赋值过程，在预解释的时候function即声明还定义 5.注意: 预解释的时候遇到变量已经声明过了就不用声明了，但是需要重新定义,例如:1234567891011//变量只声明未定义就是undefinedconsole.log(obj1);//--&gt;undefinedvar obj1=&#123;name:&quot;111&quot;&#125;;console.log(fn);function fn() &#123;&#125;//1.全局作用形成//2.全局作用域下的预解释：var obj1，function fn=xxxfff000//3.代码执行：// 1.console.log(obj1);--&gt;undefined// 2.obj1=xxxfff111// 3. console.log(fn);--&gt;function fn() &#123;&#125; 预解释的几种特殊情况 注意: 全局作用域下的变量就是window的一个属性 1.=右边函数不进行预解释（函数作为值的时候\\绑定事件的时候 不进行预解释）123var ff=function () &#123; console.log(1);&#125;; 2.return 后面的代码不行行但是需要预解释，return出的内容执行但是不进行预解释123456789101112function fn() &#123; var a=0; console.log(f);//function f()&#123;&#125; return function () &#123; console.log(1); return 1 &#125;; function f() &#123;&#125;&#125;var d=fn();console.log(d());fn()(); 3.在条件语句中 1)不管条件是否成立都进行预解释 1234567console.log(num);if (0)&#123; //虽然条件不成立 但是需要预解释 var num=0&#125;ss=0;//-&gt;window.ss=0console.log(&quot;ss&quot; in window); 2)条件中有函数function 在条件中的var和function只声明不定义，声明的时候当遇到变量已经被声明了，就会报错 1234if(&apos;a&apos; in window)&#123;var a=1;function()&#123;&#125;;//--&gt;&apos;a&apos; has already been declared&#125; 条件一旦成立，首先给函数赋值 123456789101112console.log(a);if (&quot;a&quot; in window)&#123; console.log(a); a=1; function a() &#123;&#125; console.log(a);&#125;//预解释：function a --&gt;就相当于给window增加一个“a”属性//&quot;a&quot; in window 就是true//条件成立第一步先给function a赋值=xxxfff000//代码执行：console.log(a);xxxfff000-&gt;function a() &#123;&#125;// a=1,重新给a赋值 4.自执行函数 不进行预解释1234//console.log(sss);(function sss() &#123; console.log(&quot;a&quot;)&#125;)(); 5.函数作为参数的时候不进行预解释123[1,2,3].sort(function(a,b)&#123;return a-b;&#125;); 6.预解释的时候遇到已经声明过得变量不需要声明了，但是需要定义12345678var s1=1;function s1() &#123;//s1=xxxfff000 console.log(&quot;s1&quot;)&#125;function s1() &#123;//s1=xxxfff111 console.log(&quot;s11&quot;)&#125;console.log(s1);","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"自定义属性和引用数据类型的赋值","slug":"JS自定义属性和引用数据类型的赋值","date":"2017-04-29T02:19:20.000Z","updated":"2017-08-16T15:25:32.703Z","comments":true,"path":"2017/04/29/JS自定义属性和引用数据类型的赋值/","link":"","permalink":"http://yoursite.com/2017/04/29/JS自定义属性和引用数据类型的赋值/","excerpt":"","text":"自定义属性:- 一般都是给某些元素增加一个自己起的属性名（不能是内置属性），来存储一些值的比如说我们在选项卡中用自定义属性来存储他的索引值，不用全局变量的好处：只有自己可以修改 元素.自定义属性名=值 只要是引用数据类型都可以加自定义属性 特别注意：函数也可以加 对于引用数据类型: 对象: 浏览器先看是什么数据类型的，是对象的话，浏览器给对象开辟一个堆内存 把所有的键值对（属性名：属性值）放到这个堆内存里，如果属性值遇到变量名，是把变量代表的值存起来 把这个地址赋给对象 函数 浏览器检测他是什么数据类型，是函数的话就给他开辟一个堆内存 将函数当做字符串存起来 将地址赋给函数名","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"数组中的方法","slug":"JS数组中的方法","date":"2017-04-25T09:12:39.000Z","updated":"2017-08-16T15:25:32.710Z","comments":true,"path":"2017/04/25/JS数组中的方法/","link":"","permalink":"http://yoursite.com/2017/04/25/JS数组中的方法/","excerpt":"","text":"数组中的方法 1.给数组添加值 1). push();向数组末尾增加n项 参数:想向数组末尾增加的内容,可以传递多个值,统一向数组末尾增加n向 返回值:新增后数组的长度 原数组:改变123var ary=[12,23,34,45]; ary.push(56); console.log(ary);//--&gt;[12,23,34,45,56] 2). unshift();向数组开头增加n项 参数:想向数组开头增加的内容,可以传递多个值,统一向数组开头增加n向 返回值:新增后数组的长度 原数组:改变 扩展:向数组末尾增加 a). splice(a.length,0,x);向末尾增加,可增加多项 2.删除数组中的项 1). pop();删除数组最后一项内容 参数:没有 返回值:被删除的那一项内容 原数组:改变 2). shift();删除数组中的第一项 参数:没有 返回值:被删除的那一项内容 原数组:改变 扩展:删除数组最后一项内容的方法 a) pop();删除数组最后一项内容 b) ary.length–; c) ary.splice(ary.length-1); 3.数组中的截取和拼接 1).slice 实现数组的截取，在原来的数组中截取某一部分 a). slice(n,m); a1). n&gt;=m 返回空数组 a2). n&lt;0,m&lt;0,n&lt;m 从索引m开始找到索引为n处，不包含n，将找到的部分，以新数组返回，原数组不变。原数组的索引最后一位是0,倒数第二位索引是-1,以此类推;例如: 1234var ary1=[11,22,33,44,55,66,77,88,99];var res=ary1.slice(-4,-3);console.log(res,ary1);//[66] (9) [11, 22, 33, 44, 55, 66, 77, 88, 99] a3). n&gt;0,m=原数组总长度时，slice(n,m)返回空数组;例如 123var ary1=[11,22,33,44,55,66,77,88,99];var res=ary1.slice(3,-3);//[44, 55, 66] (9) [11, 22, 33, 44, 55, 66, 77, 88, 99] a4). n&gt;0,m&gt;0,m&gt;n 参数:从索引n开始找到索引m处(不包含m); 返回值:索引n项到索引m-1项,将找到的部分以新数组返回; 原数组:不变; b). slice(n); 参数:从索引n开始一直找到数组末尾 将找到的部分以新数组返回 原数组:不变 c). slice(0);/slice() 把原来的数组克隆一份一模一样的新数组返回 原数组:不变 2).concat();把两个数组拼接在一起 参数: a). ary1.concat(ary2);将ary1和ary2进行拼接,ary2在后面 b). ary1.concat();把ary1克隆一份一模一样的数组 原数组:不变 4.修改数组中某一项的值 1).利用对象的操作方式修改某一项的值,例如:ary[2]=100; 原数组:改变 2).数组中的方法splice a). splice 既能实现删除,也能实现增加,还能实现修改 splice的删除: 返回值:删除的数据以新数组的方式返回 原数组:改变 a1). splice(n,m);从索引n开始,删除m个元素,把删除的内容以一个新数组的方式返回,原数组改变 a2). splice(n);从索引n开始,删除到数组的末尾 a3). splice(0);从索引0开始,删除到数组的末尾;原数组返回空数组,splice(0)相当于克隆一份原数组,这样的克隆会修改原来的数;例如: 1234var a=[11,22,33,44,55,66,77];var res=a.splice(0);console.log(res,a);//(7) [11, 22, 33, 44, 55, 66, 77] , [] a4). splice();相当于没有对原数组进行任何操作,splice()返回一个空数组.原数组不变;例如: 1234 var a=[11,22,33,44,55,66,77];var res=a.splice();console.log(res,a);//[] , (7) [11, 22, 33, 44, 55, 66, 77] a5). splice(a.length-1);删除最后一项，把所有索引最后一个删除掉;例如: 1234var a=[11,22,33,44,55,66];var res=a.splice(a.length-1);console.log(res,a);//[66] , (5) [11, 22, 33, 44, 55] splice的修改: b1). splice(n,m,x); 从索引n开始，删除m个，用x替换删除的部分,x可以是多项;例如: 1234var b=[1,2,3,4,5,6]; var res=b.splice(1,2,11,12,13); console.log(res,b); //[2, 3] , (7) [1, 11, 12, 13, 4, 5, 6] splice的增加: c1). splice(n,0,x); 从索引n开始，删除0个，用x替换删除的部分–&gt;相当于把x增加到索引n的前面;例如: 1234var a=[11,22,33,44,55,66];var res=a.splice(1,0,77,88);console.log(res,a);//[] , (8) [11, 77, 88, 22, 33, 44, 55, 66] c2). splice(a.length,0,x);向末尾增加,可增加多项 5.通过属性值查找索引:只有在标准浏览器下兼容的(数组中不兼容 字符串中兼容)原数组不变 1) indexOf() 2) lastIndexof() 6.遍历数组中的每一项 1) forEach(function(x,y,i){});没有返回值,例如: 12345678910var b=[11,22,33,44,55,66,11];b.forEach(function (item,index) &#123; //item为数组当前项,index为数组中的索引 console.log(item,index);&#125;);//没有返回值 var new1b=b.forEach(function (a,b) &#123; return a*10; &#125;); console.log(new1b);//undefined 2) map(function(x,y,i){return;}); 123456789var b=[11,22,33,44,55,66,11];b.map(function (item,index) &#123; //item为数组当前项,index为数组中的索引 console.log(item,index);&#125;);var newb=b.map(function (item,index) &#123; return item*10;&#125;);console.log(newb);//[110, 220, 330, 440, 550, 660, 110] 7.将数组转化为字符串: 1) join(“”);按照每一个分隔符，把数组中的每一项拼接成一个字符串 12345678var b=[12,22,33,44,55];var res=b.join(&apos;+&apos;);console.log(res,b);//&quot;12+22+33+44+55&quot; (5) [12, 22, 33, 44, 55]//扩展:eval：JS中把字符串变为JS表达式执行的一种方法 console.log(eval(res));//166 //简写: console.log(eval(b.join(&apos;+&apos;)));//166 2) toString();原数组不变 123var b=[12,22,33,44,55];var res=b.toString();console.log(res);//&quot;12,22,33,44,55&quot; 8.排序 1) reverse();把数组倒过来排列,原数组也倒过来排列;例如: 1234var b=[11,22,33,44,55,66,11];var res=b.reverse();console.log(res,b);//(7) [11, 66, 55, 44, 33, 22, 11] (7) [11, 66, 55, 44, 33, 22, 11] 2) sort();给数组进行排序,原数组也进行排序 a). ary.sort(); 只能处理10以内的数字 b). sort(function(a,b){return a-b;});从小到大排序 c). sort(function(a,b){return b-a;);从大到小排序","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]}]}