{"meta":{"title":"高大秀博客","subtitle":null,"description":"本站内容涉及前端开发的相关内容,如Javascript、CSS、HTML、CSS3、较为简单的Node、jQuery插件等,为作者高大秀本人根据自己多年经验总结写成，如有异议欢迎留言，愿与大家共同进步。作者qq号:1260833716","author":"高大秀","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2017-07-26T11:43:03.000Z","updated":"2017-08-18T07:22:29.065Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我 我的github地址https://github.com/gaodaxiu0406"},{"title":"分类目录","date":"2017-07-26T10:46:32.000Z","updated":"2017-08-18T12:14:00.674Z","comments":true,"path":"archive/index.html","permalink":"http://yoursite.com/archive/index.html","excerpt":"","text":""},{"title":"gitHub","date":"2017-07-29T15:46:57.000Z","updated":"2017-07-29T15:50:15.010Z","comments":true,"path":"gitHub/index.html","permalink":"http://yoursite.com/gitHub/index.html","excerpt":"","text":""}],"posts":[{"title":"box-shadow&vertical-align","slug":"box-shadow","date":"2017-08-20T09:48:16.000Z","updated":"2017-08-21T04:03:09.361Z","comments":true,"path":"2017/08/20/box-shadow/","link":"","permalink":"http://yoursite.com/2017/08/20/box-shadow/","excerpt":"","text":"相关小项目地址:https://github.com/gaodaxiu0406/HEXOcase box-shadow box-shadow: 10px 20px 30px 40px #000 inset 第一个值:x轴方向; 第二个值:y轴方向; 第三个值:模糊度; 第四个值:投影投射半径,一般不写; 第五个值:阴影颜色; 第六个值:如果不写是外阴影,如果写是内阴影 vertical-align 改变基线对齐方式 vertical-align: top; 顶部对齐 vertical-align: bottom; 底部对齐 vertical-align: middle; 中部对齐 值 描述 长度 通过距离升高（正值）或降低（负值）元素。’0cm’等同于’baseline’ 百分值 – % 通过距离（相对于1line-height1值的百分大小）升高（正值）或降低（负值）元素。’0%’等同于’baseline’ baseline 默认。当前元素的基线与父元素的基线对齐。 sub 降低元素的基线到父元素合适的下标位置。 super 升高元素的基线到父元素合适的上标位置。 top 把对齐的子元素的顶端与line box顶端对齐。 text-top 把元素的顶端与父元素内容区域的顶端对齐。 middle 元素的中垂点与 父元素的基线加1/2父元素中字母x的高度 对齐。 bottom 把对齐的子元素的底端与line box底端对齐。 text-bottom 把元素的底端与父元素内容区域的底端对齐。 inherit 采用父元素相关属性的相同的指定值","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"display","slug":"display","date":"2017-08-20T09:47:11.000Z","updated":"2017-08-20T10:50:54.841Z","comments":true,"path":"2017/08/20/display/","link":"","permalink":"http://yoursite.com/2017/08/20/display/","excerpt":"","text":"","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"关于png24格式的图片背景在IE6下显示不透明的解决方法","slug":"关于png24格式的图片背景在IE6下显示不透明的解决方法","date":"2017-07-31T17:09:40.000Z","updated":"2017-07-31T17:35:04.246Z","comments":true,"path":"2017/08/01/关于png24格式的图片背景在IE6下显示不透明的解决方法/","link":"","permalink":"http://yoursite.com/2017/08/01/关于png24格式的图片背景在IE6下显示不透明的解决方法/","excerpt":"","text":"图片透明，锯齿问题是重构人员很头疼的问题:png8格式的透明背景图片，会让浏览器在先显示的过程中图片边缘会有一些锯齿情况，png24可以解决这些锯齿问题，但是ie6不支持png24透明，不过利用ie6的hack问题有两种解决的办法：1234567&lt;div class=&quot;pwdTipsBg&quot;&gt;&lt;/div&gt;&lt;div class=&quot;pwdTips&quot;&gt; &lt;span class=&quot;closeBtn&quot;&gt;&lt;/span&gt; &lt;i class=&quot;pwdTipsIcon&quot;&gt;&lt;/i&gt; 验证码错误，请填写最新获取的验证码！&lt;/div&gt; 1.利用ie6的hack问题，用两种格式的图片来表示；一种其他浏览器用png24格式的图片显示，ie6用png8格式的显示12345678910111213141516171819202122232425262728293031323334353637383940.pwdTipsBg&#123; height:100%; background:#000; opacity:0.5; position: absolute; left:0; top:0; z-index:1001; filter: alpha(opacity=50); width:100%; zoom:1; &#125;.pwdTips&#123; position:absolute; left:40%; top:40%; z-index:1009; width:285px; background:#ececec; height:55px; padding:45px 20px 10px 80px; &#125;.pwdTips i&#123; position:absolute; left:40px; top:40px; background-position:-152px -68px; width:26px; height:26px; &#125;.pwdTips span&#123; position:absolute; top:-10px; right:-15px; width:33px; height:33px; background:url(closebtn.png) no-repeat 0 0; _background:url(scsprites.png) no-repeat -119px -63px; cursor:pointer; display:block; &#125; 2.利用filter滤镜解决图片问题123456789101112.pwdTips span&#123; position:absolute; top:-10px; right:-15px; width:33px; height:33px; background:url(closebtn.png) no-repeat 0 0; _background:none; filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&quot;css/safecenter/closebtn.png&quot;); cursor:pointer; display:block; &#125; 1、书写正常的CSS代码，通过background导入图片，这样所有的浏览器均使用了此PNG图片；background:url(closebtn.png) no-repeat 0 0; 2、通过滤镜对引入图片，滤镜引入图片的时候是相对于HTML文件，而不是相对于CSS文件，语法如下：filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&quot;css/safecenter/closebtn.png&quot;) 代码写到这里，我们放到IE6下测试后发现IE6还是没有透明，因为我们虽然设置了滤镜引入图片，但是background也同样加载了此图片，又因为background的图层比滤镜设置的高，所以才没有显示出来 所以最终的代码设置为：123456789101112pwdTips span&#123; position:absolute; top:-10px; right:-15px; width:33px; height:33px; background:url(closebtn.png) no-repeat 0 0; _background:none; filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src=&quot;css/safecenter/closebtn.png&quot;); cursor:pointer; display:block; &#125; 优点： 1、绿色无插件； 2、效率高，速度快； 3、网速慢的时候，不会出现先灰底再透明的情况，支持远程图片； 4、支持Hover等伪类，但是得使用两张图片，网速慢的情况下，会导致第二张图片暂时无法显示，因为还没有完全载入； 缺点： 1、不支持平铺，虽然filter有sizingMethod=”scale”, 拉伸缩放模式，但是图片会变形，如果单纯的颜色或简单的渐变色还能横向平铺； 2、不支持Img标签； 3、不支持CSS Sprite； 看到很多人的logo有在ie6下面显示显示不透明，有一层淡蓝色的底，其它浏览器下都是好，这个是因为用了png24格式的图片。 那我们在制作图标的时候应该注意什么呢？（格式，透明，毛边） 如何把png24透明logo转换png8格式 1.用photoshop软件打开 你要处理的格式为png24的logo 2.photoshop菜单 文件—存储为web和设备所用格式（或者快捷键 Alt+Shift+Ctrl+S） 3.在png24那选择png8格式，最重要的一点是“杂色”颜色的选项，如果这边没有设置好就会毛刺边出现这边应该怎么设置呢？ 4.“杂色”选项的颜色应该选择和logo背景颜色最接近的 5.保存一下就可以了。 png8和png24的区别 1.PNG-8 与 PNG-24 对IE6的支持程度 PNG-24是支持alpha通道透明的格式，支持半透明，IE6不支持PNG-24,但是他完全支持PNG-8。 如果是不透明的PNG-24,IE6也是完美支持,之所以说IE6不支持PNG-24是因为PNG-24的半透明会在IE6里显示不正常。 2.PNG-8 与 PNG-24 的透明区别 PNG-8 和 gif 有一些相似之处，模式都是索引颜色，只支持像素级的纯透明，不支持 alpha 透明。我们通常说的“IE6 不支持 PNG 透明”，是指不支持 PNG-24 的透明（将透明区域显示为灰色）。但是 IE6 支持 PNG-8 的透明，就像支持 gif 的透明一样。 3.PNG-8 的高压缩比 切图时，有时选择 PNG-8 可以获得更高的压缩比。注意，是 PNG-8，不是 PNG-24。不过有些情况下还是 gif 或 jpg 会小一些，需要根据实际情况调试以选择最佳方案。 PNG-8 与 GIF PNG-8跟GIF一样支持单色透明。GIF有的PNG-8都有，GIF没有的PNG-8还有，比如:同样的文件PNG-8格式的却比GIF要小","categories":[],"tags":[{"name":"关于png24格式的图片背景在IE6下显示不透明的解决方法","slug":"关于png24格式的图片背景在IE6下显示不透明的解决方法","permalink":"http://yoursite.com/tags/关于png24格式的图片背景在IE6下显示不透明的解决方法/"}]},{"title":"HEXO主题设置","slug":"HEXO主题设置","date":"2017-07-31T14:13:32.000Z","updated":"2017-08-16T15:33:18.468Z","comments":true,"path":"2017/07/31/HEXO主题设置/","link":"","permalink":"http://yoursite.com/2017/07/31/HEXO主题设置/","excerpt":"","text":"目前使用的主题是：huno 在博客的根目录下（即上一篇文章基于GitHub创建自己的博客https://gaodaxiu0406.github.io/2017/04/25/%E5%9F%BA%E4%BA%8EGitHub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/中提到的 HEXO 文件夹下） 克隆主题 克隆主题1git clone git://github.com/someus/huno.git themes/huno 提示:huno的github地址:https://github.com/gaodaxiu0406/huno 执行：1vim _config.yml 执行此命令后可以对此文档进行编辑 输入o进入编辑状态 将 theme 对应的值进行修改1theme: huno 修改完成 按esc键退出编辑状态 再输入:wq退出编辑窗口模式 自动部署1npm install hexo-deployer-git --save 发布1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 稍等片刻看一下自己的博客主页，你想要的效果就出现了。也可以在github或百度中搜索更多主题，挑选自己喜欢的主题进行修改，只要你快乐就好 主题配置 现在主题是更改过来了，但还有许多细节需要处理，比如说你需要修改头像等等。 每个人的设置风格不同,但基本的设置在你下载的主题中的README文件中都有介绍,你可以按照文件中的介绍配置属于自己的博客。动气手来，让你的博客亮起来 返回上篇:基于GitHub创建自己的博客https://gaodaxiu0406.github.io/2017/04/25/%E5%9F%BA%E4%BA%8EGitHub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","categories":[],"tags":[{"name":"基于GitHub创建自己的hexo博客","slug":"基于GitHub创建自己的hexo博客","permalink":"http://yoursite.com/tags/基于GitHub创建自己的hexo博客/"}]},{"title":"如何安装部署服务器","slug":"如何安装部署服务器","date":"2017-07-30T17:51:23.000Z","updated":"2017-08-16T15:29:06.691Z","comments":true,"path":"2017/07/31/如何安装部署服务器/","link":"","permalink":"http://yoursite.com/2017/07/31/如何安装部署服务器/","excerpt":"","text":"购买机器https://www.aliyun.com/123116.62.9.168用户名:root密码:Zfpx2017 连接服务器1ssh root@116.62.9.168 更新操作系统1apt-get update 安装 npm1apt-get install npm 安装node1apt-get install npm 安装node版本管理器n n是node的管理器 可以通过他管理node的版本1npm install n -g 安装node7.5版本1n 7.5 出现node-v7.5.0就安装成功了 安装mongodb1apt-get install mongodb 安装git1apt-get install git 克隆爬虫的地址1git clone https://github.com/zhufengnodejs/201704crawl.git 进入目录201704crawl1cd 201704crawl 安装依赖1npm install 启动server.js1node server.js 执行脚本main.js(先进入main.js所在的文件夹) 1.进入main.js所在的文件夹执行main.js 12cd tasksnode main.js 2.ctrl+c结束掉之前的任务,再启动server.js 1node server.js 访问(格式–&gt;ip:端口号) 在浏览器输入地址116.62.9.168:8080访问 http://116.62.9.168:8080/ 此时还是静态网页 别人无法访问 在电脑上安装程序Xftp 5安装nginx Nginx是一个高性能的HTTP和反向代理服务器 1apt-get install nginx 此时就可以上传自己的项目,访问自己的服务器 但是一旦窗口关掉,就无法访问 nginx命令 启动 nginx nginx -c /etc/nginx/nginx.conf 关闭 nginx nginx -s stop 重读配置文件 nginx -s reload kill -HUP nginx 常用命令 service nginx {start|stop|status|restart|reload|configtest|} 配置nginx反向代理和负载均衡1234567891011121314upstream crawl&#123; ip_hash; server 127.0.0.1:3000 weight=10; server 127.0.0.1:4000 weight=1;&#125;server &#123; listen 80; server_name www.gdxiu.cn; location / &#123; proxy_pass http://crawl; &#125;&#125; 安装pm2 强大的进程管理器 进程异常退出时pm2会尝试重启 1npm install pm2 -g 进入201704crawl文件夹,在根目录下执行以下命令 12cd /rootcd 201704crawl 切换到server.js文件所在目录,启动pm2应用 12pm2 start server.js --name &quot;crawl&quot;//即pm2 start server.js --name &apos;自己取名字&apos; 如何停止pm2上的项目1.查看node进程号1ps -ef | grep node 2.停止1pm2 stop crawl 3.杀死进程1kill 8796(进程号) 复活:如何重新建立连接1pm2 start server.js --name &quot;crawl&quot; 启动1pm2 start crawl pm2常用命令 用pm2启动node 命令 用途 pm2 start app.js –name “crawl” 启动应用 pm2 list 查看所有应用 pm2 restart crawl 重启应用 pm2 stop crawl 停止应用 pm2 delete crawl 删除应用 关于scp命令 网址http://www.cnblogs.com/hitwtx/archive/2011/11/16/2251254.html cat 查看文件内容 vi命令12vi crawl1000dd//删除1000行 vi的一个命令 重启服务1nginx -s reload 推荐视频地址1http://www.ablesky.com/kecheng/detail_926049","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"}]},{"title":"2.react轮播图项目开写","slug":"2-react轮播图项目开写","date":"2017-07-30T17:49:58.000Z","updated":"2017-08-18T13:08:08.401Z","comments":true,"path":"2017/07/31/2-react轮播图项目开写/","link":"","permalink":"http://yoursite.com/2017/07/31/2-react轮播图项目开写/","excerpt":"","text":"关于react轮播图的源码,无缝版已上传至github,https://github.com/gaodaxiu0406/React-Slider 用react+webpack写一个的轮播图项目(项目配置请看上篇react轮播图项目配置及原理概要) 先将整个文件写在一个文件中,1.画结构 新建一个components文件夹 components文件夹下新建Slider.js文件和Slider.less文件(Slider.less文件是用来给Slider.js写样式的) 2.在indix.js中引入组件 渲染到页面中 打开src文件夹中的index.html文件 1&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 2-1).在这个id为root的标签中渲染元素 2-2).回到index.js中,写一个轮播图组件，渲染到index.html中 12345678910import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import Slider from &apos;./components/Slider&apos;;let images=[ &#123;src:require(&apos;./images/1.jpg&apos;)&#125;, &#123;src:require(&apos;./images/2.jpg&apos;)&#125;, &#123;src:require(&apos;./images/3.jpg&apos;)&#125;, &#123;src:require(&apos;./images/4.jpg&apos;)&#125;];ReactDOM.render(&lt;Slider images=&#123;images&#125;/&gt;,document.querySelector(&apos;#root&apos;)); 解释1)引入React，引入ReactDOM，引入Slider组件 然后通过ReactDOM.render将Slider组件渲染到index.html的id为root的div标签中 解释2)Slider组件需要图片参数 src文件夹下新建一个images文件夹，存入轮播的图片 将图片路径通过require存入images数组中 通过组件Slider标签将所需的images参数传入组件Slider(让images参数变量等于images数组) 3.开始写Slider.js中的代码 需要默认导出一个组件Slider供外面文件(index.js)调用;还需要接收一个images属性进行轮播 1234567891011121314151617181920import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;require(&apos;./Slider.less&apos;);export default class Slider extends React.Component&#123; render()&#123; let images=this.props.images; return( &lt;div className=&quot;slider-wrapper&quot;&gt; &lt;ul className=&quot;sliders&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;li className=&quot;slider&quot;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125; 1)require(&#39;./Slider.less&#39;);–&gt;这里引入Slider.less用import和require都是一样的效果，都是加载一个模块的意思,模块可能是图片，可能是less/css/js/json文件,都可以–&gt;在webpack中一切皆模块,不管是什么资源，都可以作为模块来加载 2)li的数量取决于images数据,images中有几张图片，就有几个li 在render中let一个变量images来接收index.js传入的images,然后用map方法遍历整个数组 在Slider.less中写好轮播图的样式 123456789101112131415161718192021222324252627*&#123; padding: 0; margin: 0;&#125;ul,li&#123; list-style: none;&#125;.wrapper&#123; width: 400px; height: 400px; position: relative; margin: 30px auto; .sliders&#123; height: 400px; position: absolute; left:0; .slider&#123; float: left; width: 400px; height: 400px; img&#123; width: 100%; height: 100%; &#125; &#125; &#125;&#125; 宽高为400px的轮播图 4.写配置文件 在webpack.config.js中加loaders 1234567module:&#123; loaders:[ &#123;test:/\\.js$/,loader:&apos;babel-loader&apos;,exclude:/node_modules/&#125;, &#123;test:/\\.less$/,loader:&apos;style-loader!css-loader!less-loader&apos;&#125;, &#123;test:/\\.(jpg|png|gif)$/,loader:&apos;url-loader&apos;&#125; ] &#125; babel默认情况下什么都不做，需要一个配置文件.babelrc文件 新建一个.babelrc配置文件123&#123; &quot;presets&quot;: [&quot;es2015&quot;,&quot;stage-0&quot;,&quot;react&quot;]&#125; presets预设,”es2015”将es6编译成es5,”stage-0”将es7编译成es5,”react”将react编译成es5 原理1:{test:/\\.js$/,loader:&#39;babel-loader&#39;,exclude:/node_modules/}–&gt;处理(编译)js文件:如果发现文件是js,用babel-loader加载,加载的时候需要读配置文件.babelrc,如果代码时es6/es7/react都要通过babel转成es5;同时通过exclude将node_modules文件夹下的所有js文件排除掉 原理2:{test:/\\.less$/,loader:&#39;style-loader!css-loader!less-loader&#39;}–&gt;如果发现文件以.less结尾的,第一步通过less-loader将less编译成css,然后通过css-loader进行加载,然后通过style-loader将他通过style标签的形式插入到页面中去，变成一个行内样式 原理3:{test:/\\.(jpg|png|gif)$/,loader:&#39;url-loader&#39;}–&gt;凡是资源文件都可以用url-loader来加载,不论是图片、图标、字体、视频、音频;后面可以通过问号传参,有个参数limit(例如:{test:/\\.(jpg|png|gif)$/,loader:&#39;url-loader?limit=8192&#39;}–&gt;小于8K的资源文件将直接以base64的形式内联在代码中，可以减少一次http请求) 此时执行npm run build,将代码打包到出口文件中,打开build文件夹下的index.html文件就可以直接预览效果了 此时会发现控制台有个报错 123Warning: Each child in an array or iterator should have a unique &quot;key&quot; prop. Check the render method of `Slider`. See https://fb.me/react-warning-keys for more information. in li (created by Slider) in Slider 需要唯一的key属性,在Slider.js文件中的li需要唯一的key属性，给li标签加上key属性即可 1&lt;li className=&quot;slider&quot; key=&#123;index&#125;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; 关掉浏览器,重新执行npm run build，再打开build文件夹下的index.html文件预览,控制台就没有报错了 5.写功能 让图片动起来,需要给Slider.js加个状态,需要有个定时器让他动起来 写在周期函数componentDidMount中 1234567891011constructor()&#123; super(); this.state=&#123;pos:0&#125;;//默认索引 &#125; componentDidMount()&#123; this.$timer=setInterval(()=&gt;&#123; let pos=this.state.pos; pos++;//每隔2s让pos加1，pos值影响ul的左偏移量left的值 所以ul应该有个style属性 left值应该变化 this.setState(&#123;pos:pos&#125;) &#125;,this.props.interval*1000) pos++;–&gt;每隔2s让pos加1，pos值影响ul的左偏移量left的值 所以ul应该有个style属性 left值应该变化 ul应该有个style属性123456789101112131415161718192021render()&#123; let images=this.props.images; let style=&#123; width:400*images.length, left:this.state.pos*-400 &#125;; return( &lt;div className=&quot;slider-wrapper&quot;&gt; &lt;ul style=&#123;style&#125; className=&quot;sliders&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;li className=&quot;slider&quot; key=&#123;index&#125;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; this.props.interval*1000–&gt;每隔2s轮播一次,需要有变量传进来–&gt;在index.js中新增一个interval变量(间隔时间让外面可以控制) 1).这里通过this.props获取index.js中传递进来的的interval变量this.props.interval*1000 2).index.js中新增一个interval变量12345ReactDOM.render( &lt;Slider images=&#123;images&#125; interval=&#123;2&#125; /&gt;,document.querySelector(&apos;#root&apos;)); 写功能步骤总结: 第一步:定义一个默认索引pos,默认值是0 第二步:在组件加载完成之后创建定时器setInterval赋给this.$timer 第三步:每隔2s让图片向左偏移一个宽度的距离(interval是外界传进来的,是图片轮播的间隔时间),在index中要给组件Slider传进来一个2,2*1000意味着2s变一次 this.$timer中先取出老的pos值，第一次轮播pos就是0，然后pos++，pos变成1，然后setState重新设置pos值,让pos值往上 pos会影响ul的left值，一张图片的宽度是400px，向左偏移400，就是*-400 ul的宽度应该是宽度400乘以图片的数量images.length,4张图就是1600px执行npm run dev 注意,执行npm run dev可自动将文件编译更新打包到出口文件index.html中，并且只要更改文件，页面就会自动刷新,但是如果更改配置文件,需要重新启动npm run dev服务 此时执行npm run dev命令,轮播图就动起来了，但是越界了,因为此时还没有做边界处理 7.完善功能 将Slider需要的属性(可外界控制的)，在index.js的Slider组件标签中传入 1234567891011ReactDOM.render( &lt;Slider images=&#123;images&#125;//图片 interval=&#123;2&#125;//多长时间轮播一次 speed=&#123;1&#125;//每次轮播的速度 pause=&#123;true&#125;//当鼠标移动上去之后自动暂停 autoplay=&#123;true&#125;//是否启用自动轮播，false不自动轮播 - 在Slider.js中 dots=&#123;true&#125;//是否有点状导航 arrows=&#123;true&#125;//是否有箭头导航 /&gt;,document.querySelector(&apos;#root&apos;)); 添加transitionDuration–&gt;规定完成过渡效果需要花费的时间 speed默认值是1 这里就是1s 12345let style=&#123; width:400*images.length, left:this.state.pos*-400, transitionDuration:this.props.speed+&apos;s&apos; &#125;; 在Slider.js的周期函数中添加一个判断 123456789componentDidMount()&#123; if(this.props.autoPlay)&#123; this.$timer=setInterval(()=&gt;&#123; let pos=this.state.pos; pos++; this.setState(&#123;pos:pos&#125;) &#125;,this.props.interval*1000) &#125;&#125; this.props.autoPlay 是否自动轮播 如果外界传入true就是自动轮播，传入false就是不自动轮播 8.将轮播切换单独拎出来写成一个方法turn12345turn(n)&#123; let pos=this.state.pos; pos+=n; this.setState(&#123;pos:pos&#125;)&#125; 或者使用es6的箭头函数 12345turn=(n)=&gt;&#123; let pos=this.state.pos; pos+=n; this.setState(&#123;pos:pos&#125;) &#125; let pos=this.state.pos;获取旧索引 turn表示切换,n表示切换的步长,方便以后操作:例如往左走传1进来即可，往右走传-1进来即可 那么此时在周期函数中,直接调用这个turn方法即可,默认往右轮播，传入-11234567componentDidMount()&#123; if(this.props.autoplay)&#123; this.timer=setInterval(()=&gt;&#123; this.turn(1); &#125;,this.props.interval*1000) &#125;&#125; 9.实现鼠标移上去停止轮播 给div加onMouseOver和onMouseOut事件123&lt;ul onMouseOver=&#123;()=&gt;clearInterval(this.timer)&#125; onMouseOut=&#123;this.play&#125; style=&#123;style&#125; className=&quot;sliders&quot;&gt;...&lt;/ul&gt; 10.自动轮播部分也封装成一个函数play12345play=()=&gt;&#123; this.timer=setInterval(()=&gt;&#123; this.turn(1); &#125;,this.props.interval*1000) &#125;; play表示开启定时器进行自动轮播 那么此时在周期函数中直接调用this.play()即可12345componentDidMount()&#123; if(this.props.autoplay)&#123; this.play(); &#125;&#125; 11.边界判断12345678turn=(n)=&gt;&#123; let pos=this.state.pos; pos+=n; if(pos&gt;=this.props.images.length)&#123; pos=0; &#125; this.setState(&#123;pos:pos&#125;) &#125;; 当索引为图片总张数的时候 让索引变为012.写左右箭头 在ul下加一个div 1234&lt;div className=&quot;arrows&quot;&gt; &lt;span className=&quot;arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span className=&quot;arrow-right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt; 在Slider.less中写样式 123456789101112131415161718192021222324252627.arrows&#123; position: absolute; width: 100%; height: 20px; top:50%; margin-top:-10px; .arrow&#123; width: 20px; height: 20px; line-height: 20px; text-align: center; cursor: pointer; font-size: 30px; background-color: #eee; &amp;:hover&#123; background-color: #999; &#125; &#125; .arrow-left&#123; margin-left: 5px; float: left; &#125; .arrow-right&#123; margin-right: 5px; float: right; &#125;&#125; 给左右arrow绑定事件 1234&lt;div className=&quot;arrows&quot;&gt; &lt;span onClick=&#123;()=&gt;this.turn(-1)&#125; className=&quot;arrow arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span onClick=&#123;()=&gt;this.turn(1)&#125; className=&quot;arrow arrow-right&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt; 13.处理左边界 在turn中做个判断 1234567891011turn=(n)=&gt;&#123; let pos=this.state.pos; pos+=n; if(pos&gt;=this.props.images.length)&#123; pos=0; &#125; if(pos&lt;0)&#123; pos=this.props.images.length-1; &#125; this.setState(&#123;pos:pos&#125;)&#125;; 当索引小于0的时候,让索引等于images的长度-1 14.根据传进来的arrows值判断是否有左右箭头切换效果 第一种方法(看着比较乱) 123456&#123; this.props.arrows?&lt;div className=&quot;arrows&quot;&gt; &lt;span onClick=&#123;()=&gt;this.turn(-1)&#125; className=&quot;arrow arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span onClick=&#123;()=&gt;this.turn(1)&#125; className=&quot;arrow arrow-right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt;:null &#125; 第二种,在render中 123456789let arrows=null; if(this.props.arrows)&#123; arrows=( &lt;div className=&quot;arrows&quot;&gt; &lt;span onClick=&#123;()=&gt;this.turn(-1)&#125; className=&quot;arrow arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span onClick=&#123;()=&gt;this.turn(1)&#125; className=&quot;arrow arrow-right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt; ) &#125; 那么ul下面就可以直接用{arrows}代替了(看着很清晰明了) 123456789101112&lt;div className=&quot;slider-wrapper&quot;&gt; &lt;ul onMouseOver=&#123;()=&gt;clearInterval(this.timer)&#125; onMouseOut=&#123;this.play&#125; style=&#123;style&#125; className=&quot;sliders&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;li className=&quot;slider&quot; key=&#123;index&#125;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &#123;arrows&#125;&lt;/div&gt; 15.根据传进来的dots值判断是否有点状导航123456789101112let dots=null; if(this.props.dots)&#123; dots=( &lt;div className=&quot;dots&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;span className=&quot;dot&quot; key=&#123;index&#125;&gt;&lt;/span&gt; )) &#125; &lt;/div&gt; ) &#125; dots直接放到最下面即可123...&#123;arrows&#125;&#123;dots&#125; 15-1.在Slider.less中写dots的样式12345678910111213141516171819.dots&#123; width: 100%; height: 20px; position: absolute; bottom: 10px; text-align: center; .dot&#123; display: inline-block; width: 20px; height: 20px; border-radius: 50%; margin-left: 5px; background-color: #abcdef; cursor: pointer; &amp;:hover&#123; background-color: #999999; &#125; &#125;&#125; 16.点状导航的点击跟随事件 给span加onClick事件123···&lt;span className=&quot;dot&quot; key=&#123;index&#125; onClick=&#123;()=&gt;this.turn(index-this.props.pos)&#125;&gt;&lt;/span&gt;··· 16-1.轮播点状导航自动跟随事件 在Slider.less中加一个active样式 123.active&#123; background-color: #999999; &#125; 给span标签添加active属性 1&lt;span className=&#123;&quot;dot &quot;+(index==this.state.pos?&apos;active&apos;:&apos;&apos;)&#125; key=&#123;index&#125; onClick=&#123;()=&gt;this.turn(index-this.state.pos)&#125;&gt;&lt;/span&gt;","categories":[],"tags":[{"name":"react轮播图","slug":"react轮播图","permalink":"http://yoursite.com/tags/react轮播图/"}]},{"title":"1.react轮播图项目配置及原理概要","slug":"1-react轮播图项目配置及原理概要","date":"2017-07-30T17:47:17.000Z","updated":"2017-08-18T13:00:57.183Z","comments":true,"path":"2017/07/31/1-react轮播图项目配置及原理概要/","link":"","permalink":"http://yoursite.com/2017/07/31/1-react轮播图项目配置及原理概要/","excerpt":"","text":"项目配置及原理概要1.初始化项目1npm init -y 生成package.json文件 2.安装依赖包 开发依赖1npm install webpack webpack-dev-server babel-core babel-loader babel-preset-react babel-preset-es2015 babel-preset-stage-0 style-loader css-loader less-loader less file-loader url-loader html-webpack-plugin -D webpack 打包 webpack-dev-server 用来启动一个HTTP服务器预览我们的项目 babel-core babel-loader 进行转译 把es6和react代码转译成es5 babel-preset-react 用来转译react babel-preset-es2015 用来转译es6 babel-preset-stage-0 用来转译es7 style-loader css-loader 用来处理css less-loader less 编译less file-loader url-loader 用来处理资源文件 html-webpack-plugin 用来自动产出html文件 open-browser-webpack-plugin 自动打开浏览器 3.安装生产依赖1npm install react react-dom -S 4.配置文件的出入口路径 新建一个webpack.config.js文件，在文件中配置入口文件和出口路径12345678let path=require(&apos;path&apos;);module.exports=&#123; entry:&apos;./src/index.js&apos;,//入口文件 output:&#123;//出口配置 path:path.resolve(&apos;build&apos;),//出口文件路径 filename:&apos;bundle.js&apos;//出口文件名称 &#125;&#125;; 5.启动安装的模块文件夹node_modules–&gt;.bin–&gt;webpack.cmd和webpack-dev-server.cmd文件 在package.json文件中的scripts标签进行匹配1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;:&quot;webpack-dev-server&quot; &#125;, 5-1.启动webpack和webpack-dev 在cmd中执行命令 1npm run build 1)在cmd窗口中显示 123 Asset Size Chunks Chunk Namesbundle.js 2.52 kB 0 [emitted] main [0] ./src/index.js 43 bytes &#123;0&#125; [built] 表示生成bundle.js一个文件 2)在当前项目文件夹下会自动生成一个build文件夹，同时在build文件夹下会自动生成bundle.js文件，我们的入口文件(src文件夹下的index.js)会自动打包到出口文件bundle.js中 6.自动产出html文件6-1.现在我们需要在build文件夹中新建一个index.html文件，然后引入bundle.js进行预览;但是现在我们希望这个文件不要手动创建了，希望他可以自动生成，要做到这一点，我们需要引入插件html-webpack-plugin(此插件在最初已经安装过,如果没有安装需安装后才可使用) 1) 在webpack.config.js中引入html-webpack-plugin 1let HtmlWebPackPlugin=require(&apos;html-webpack-plugin&apos;); 2) 同时给插件再添加个配置项plugins,plugins是个数组 12345plugins:[ new HtmlWebPackPlugin(&#123; template:&apos;./src/index.html&apos; &#125;)] 3) template 模板 配置到时候会按照哪个模板来自动产出html文件 并且把它自动放到配置目录下–&gt;一般会在src文件夹下新建一个模板叫index.html 4) 执行npm run build 4-1).原理:此时如果再执行npm run build的话，就会执行上面配置的plugins插件,插件会读取src文件夹下的index.html模板文件，把他自动插入到打包后的bundle.js，并且把bundle.js保存到build目录下(每次执行npm run build命令，都会重新生成bundle.js和index.html两个文件) 4-2).在cmd命令行执行npm run build,命令行显示: 1234 Asset Size Chunks Chunk Names bundle.js 2.52 kB 0 [emitted] mainindex.html 188 bytes [emitted] [0] ./src/index.js 43 bytes &#123;0&#125; [built] 表示生成bundle.js和index.html两个文件,与之前执行npm run build相比多了一个html文件 4-3).打开我们的项目文件夹下的build文件会发现，已经自动生成了一个出口index.html出口文件,打开这个index.html出口文件会发现,index.html中已经自动引入了bundle.js文件 关于react轮播图的源码,无缝版已上传至github,https://github.com/gaodaxiu0406/React-Slider","categories":[],"tags":[{"name":"react轮播图","slug":"react轮播图","permalink":"http://yoursite.com/tags/react轮播图/"}]},{"title":"移动端click300-380ms延迟问题","slug":"移动端click300-380ms延迟问题","date":"2017-07-28T14:28:17.000Z","updated":"2017-08-16T15:29:30.997Z","comments":true,"path":"2017/07/28/移动端click300-380ms延迟问题/","link":"","permalink":"http://yoursite.com/2017/07/28/移动端click300-380ms延迟问题/","excerpt":"","text":"移动设备上的web网页是有300ms延迟的，玩玩会造成按钮点击延迟甚至是点击失效。历史原因 来源一个公司内一个同事的分享:2007年苹果发布首款iphone上iOS系统搭载的safari为了将适用于PC端上大屏幕的网页能比较好的展示在手机端上，使用了双击缩放(double tap to zoom)的方案，比如你在手机上用浏览器打开一个PC上的网页，你可能在看到页面内容虽然可以撑满整个屏幕，但是字体、图片都很小看不清，此时可以快速双击屏幕上的某一部分，你就能看清该部分放大后的内容，再次双击后能回到原始状态。 双击缩放是指用手指在屏幕上快速点击两次，ios 自带的 Safari 浏览器会将网页缩放至原始比例。 原因就出在浏览器需要如何判断快速点击上，当用户在屏幕上单击某一个元素时候，例如跳转链接，此处浏览器会先捕获该次单击，但浏览器不能决定用户是单纯要点击链接还是要双击该部分区域进行缩放操作，所以，捕获第一次单击后，浏览器会先Hold一段时间t，如果在t时间区间里用户未进行下一次点击，则浏览器会做单击跳转链接的处理，如果t时间里用户进行了第二次单击操作，则浏览器会禁止跳转，转而进行对该部分区域页面的缩放操作。那么这个时间区间t有多少呢？在IOS safari下，大概为300毫秒。这就是延迟的由来。造成的后果用户纯粹单击页面，页面需要过一段时间才响应，给用户慢体验感觉，对于web开发者来说是，页面js捕获click事件的回调函数处理，需要300ms后才生效，也就间接导致影响其他业务逻辑的处理。解决方案 1.tap.js解决方案 使用 zepto.js 的 tap 事件，通过 singleTap 和 doubleTap 来区分单击和双击。但是会出现点击穿透，而且对于已经使用 click 的文件，改动成本太大。123456789101112131415161718192021222324252627&lt;script src=&quot;tap.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;container&quot;&gt; &lt;button id=&quot;button-1&quot;&gt;Click event&lt;/button&gt; &lt;button id=&quot;button-2&quot;&gt;Tap event&lt;/button&gt;&lt;/div&gt;&lt;div id=&quot;output&quot;&gt;&lt;/div&gt;&lt;script&gt; var container = document.getElementById(&apos;container&apos;) var button1 = document.getElementById(&apos;button-1&apos;); var button2 = document.getElementById(&apos;button-2&apos;); var output = document.getElementById(&apos;output&apos;); var tap = new Tap(container); button1.addEventListener(&apos;click&apos;, callback, false); button2.addEventListener(&apos;tap&apos;, callback, false); function callback (e) &#123; e.preventDefault(); var p = document.createElement(&apos;p&apos;); p.textContent = &apos;event: &apos; + e.type; output.insertBefore(p, output.firstChild); &#125;&lt;/script&gt; 2.对于高版本chrome和firefox，可以通过禁用伸缩，即在 head 上的 meta 标签添加 user-scalable = no。如下：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot;&gt; 3.chrome32+ 可以将 viewport 的宽度设置成 device-width.4.IE10+，可以使用 pointerEvents。可以让特定的元素或者整个文档中的元素移除点击延迟的问题，同时不会影响 pinch-zooming12345a, button, .myelements&#123;-ms-touch-action: manipulation; /* IE10 */touch-action: manipulation; /* IE11+ */&#125; 5.通过 touchend 事件代替 click 事件。6.fastclick.js解决方法 终极大 boss。 fastclick。上面的几种方法都是针对某些浏览器，或者某些浏览器的某些版本，或者会影响到我们平常使用方式的解决方案。使用起来不方便且考虑的细节很多，实践难度比较大。fastclick 作为一个终极的解决方案，使用方便，文件大小压缩后只有 3.3k。对于交互相对复杂的移动端web页面或应用是一个相对不错的解决方案。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; &#125; body &#123; &#125; .button &#123; background-color: #3d3d3d; border: 0px; height: 80px; width: 80%; font-size: 50px; margin: 10% 0% 0% 10%; color: #fff; &#125; .fu &#123; min-height: 100%; min-width: 100%; background-color: Black; background: rgba(0,0,0,0.4); position: absolute; top: 0; text-align: center; display: none; &#125; .ts &#123; margin: 8% auto; width: 400px; height: 400px; top: 59%; background-color: #fff; text-align: center; &#125; &lt;/style&gt; &lt;script src=&quot;fastclick.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;jquery-1.7.2.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; //javascript: &lt;script type=&quot;application/javascript&quot;&gt; window.addEventListener(&apos;load&apos;, function () &#123; FastClick.attach(document.body); &#125;, false); function xian() &#123; $(&quot;.fu&quot;).show().hide(350); &#125; &lt;/script&gt; //jQuery: &lt;script&gt; window.addEventListener(&apos;load&apos;, function () &#123;$(function() &#123; FastClick.attach(document.body); &#125;); &lt;/script&gt; //CommonJS:attachFastClick = require(&apos;fastclick&apos;); attachFastClick(document.body); AMD: var FastClick = require(&apos;fastclick&apos;); FastClick.attach(document.body, options);&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;div class=&quot;but&quot;&gt; &lt;input class=&quot;button&quot; type=&quot;button&quot; value=&quot;点击我&quot; onclick=&quot;xian()&quot; /&gt;&lt;/div&gt; &lt;div class=&quot;fu&quot; &gt; &lt;div class=&quot;ts&quot;&gt; 我是浮层 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"CSS选择器种类和兼容性总结大全","slug":"css选择器种类和兼容性总结大全","date":"2017-07-21T07:57:22.000Z","updated":"2017-08-16T15:33:05.869Z","comments":true,"path":"2017/07/21/css选择器种类和兼容性总结大全/","link":"","permalink":"http://yoursite.com/2017/07/21/css选择器种类和兼容性总结大全/","excerpt":"","text":"css5选择器 名称 举例 描述 详细 权重 ie6-7 ie8 ie9+ 其他 标签选择器 p{} 直接使用元素标签进行选择 1 yes yes yes 类选择器 .sum{} 类选择器最前方一定要有点 通过元素的类名，来选择元素，一个元素可以有多个类名，都代表这个元素,类名是元素class属性中的属性值，例如&lt;p class=&#39;sum&#39;&gt;&lt;/p&gt; 10 yes yes yes id选择器 #tytle{color:red;} id在html中具有唯一性,这个属性值前面加一个“#” 一个html元素，id属性值只能用一次 100 yes yes yes 通配符选择器 *{key:value} 匹配全部html元素 一般不使用，因为全部匹配耗性能 0&lt;通配符选择器&lt;1 yes yes yes yes (标签)属性选择器 [type]或[type=text] [标签属性名]{}或[标签属性名=属性值]{} 利用标签的属性名和属性值来选择html元素 10 yes yes yes 属性选择器在使用的时候，如果一个元素有两个类名，那么是不生效的 分组选择器 .box,li,.p1{color: red}; 选择器1，选择器2，选择器3{} 同一份css样式，可以一次性的添加给多个不同的html元素 分组选择器将不同的html分为一组，权重计算的时候都是独立计算，不会叠加。 yes yes yes 交集选择器 h2[title]{} 两种选择器同属于一个元素的时候，我们可以使用交集选择器来进行元素的准确选择 所有组合选择器权重之和 yes yes yes 作用：精确查找元素，增加选择器的权重 子级选择器 ul&gt;li{color:red;} 父级选择器&gt;子级选择器{} 存在包含关系的元素选择，通过父级确定选择子级 所有选择器之和 yes yes yes 子级选择器必须是紧邻的父子关系 后代选择器(派生选择器) .div1 ul span{} 祖辈选择器 要查找的后代选择器{},中间用空格连接 后代选择器在写的时候尽量控制在３个左右 yes yes yes 在一个根元素的范围内，查找到它的后代元素，选择器过多浪费性能，不建议使用 相邻兄弟选择器 .list1+li{color: red;} 哥哥选择器+弟弟选择器{} 通过各个元素选择弟弟选择器，两个选择器之间用“+”连接 选择器之和 yes yes yes 伪类选择器 a:hover{color: red}鼠标经过的状态,或a:link{color: blue}默认状态,或a：active{color: green}鼠标点击的状态,或a:visited{color: blanchedalmond}鼠标点击后的状态 10 yes yes yes .input:focus{border-color: blue};input:focus 鼠标聚焦后的状态，input独有的属性 伪元素 div:before{}；或div:after{} 通过css代码向指定元素内添加假的（html中不存在的）元素 before 会出现在div所有内容之前，after 会出现在div所有内容之后 no yes yes 使用伪元素的时候要保证两个前提：1.要有display这个属性2.要有content这个属性，这个属性的属性值可以为空，但是引号不能少content:&quot;&quot; visited security issue yes yes security issue css3选择器 名称 举例 描述 详细 权重 ie6-7 ie8 ie9+ 其他 属性选择器 E[attr~=value]{} 指定属性名,并且具有属性值,此属性值是一个此列表(类名),并且以空格隔开,其中词列表中包含了一个value词,并且等号前的~不能省略. E[attr^=value]{} ^ 表示以谁为开头的,value可以是首字母或者类名 必须是第一个类名 E[attr$=value]{} $ 表示以谁为结尾,value可以是末尾字母或者类名 必须是最后一个类名 E[attr\\=value]{}(由于编辑呈现问题，此处用斜杠代替竖杠,正确写法是E[attr竖杠=value]{}) 如果只有一个类名,没有”-“,也可以选中 value必须后面带”-“，value必须是第一个类名 伪类选择器1. .dome p:nth-child(3){background: red;}选择dome下的第三个p标签为背景色红色 no no yes 2. .dome p:first-child{background: yellow;}选择dome下的第一个p标签为背景色黄色 no almost yes 3. .dome p:last-child{background: black;}选择dome下的最后一个p标签为背景色黑色 伪类选择器是针对列表或者很多同级的标签使用,img下是没有效果的也用不到伪类选择器 no no yes 4. .dome p:nth-child(nlength){}；选择dome下所有的p标签 no no yes 5. .dome p:nth-child(2n){}；选择dome下的所有偶数个的p标签 no no yes 6. .dome p:nth-child(3n)选择dome下的所有3的倍数的p标签 no no yes 7. .dome p:nth-child(n+length) 从第length个开始改变,包括第length个(n是从0开始取值的) 选择大于length后面的元素 no no yes 8. .dome p:nth-child(-n+length) 包括length，length是从0开始的 选择小于length前面的元素及length元素 no no yes 9. p:nth-last-child(3) 选择倒数第三个元素 no no yes 10. p:nth-child(n) 从大盒子的第一个元素开始 nth-child选择同级元素 no no yes 11. p:nth-of-type(n) 从大盒子的第一个p元素开始 nth-of-type 选择指定的元素 no no yes 12. p:nth-last-of-type(n) 倒数第n个 在同级元素中 no no yes 13. p:first-of-type{} 同类型的第一个 选择一个上级元素下的同类子元素 no no yes 14. p:last-of-type{} 同类型的最后一个 no no yes 15. p:only-child{} 在父元素中,里面的子元素是唯一的 no no yes 16. p:only-of-type{} 在父元素中,里面有很多的子元素,但是有一个子元素是唯一的 no no yes 空标签 p:empty{display:none;} empty 隐藏空标签 no no yes 否定选择器 not input:not([type=submit]){} no yes yes 根元素 root :root{} 选择文档的根元素 no no yes 目标元素 :target{} 选择器可用于选取当前活动的目标元素 no no no CSS选择器优先级 当两个规则都作用到了同一个html元素上时，如果定义的属性有冲突，那么应该用谁的值的，CSS有一套优先级的定义 不同级别 1.在属性后面使用important会覆盖页面内任何位置定义的元素样式 2.作为style属性写在元素内的样式 3.id选择器 4.类选择器 5.标签选择器 6.通配符选择器 7.浏览器自定义或继承 总结CSS选择器优先级排序: !important&gt;行内样式&gt;ID选择器&gt;类选择器&gt;标签&gt;通配符&gt;继承&gt;浏览器默认属性 CSS样式应用，有个简单的计算方式(权值实际并不是按照十进制，用数字表示只是说明思想，一万个class可能也不如一个id权值高) 内联样式表的权值为 1000 ID选择器的权值为 100 Class类选择器的权值为 10 HTML标签选择器的权值为 1","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Vuejs基础","slug":"Vuejs基础","date":"2017-06-30T09:10:39.000Z","updated":"2017-08-16T15:28:38.290Z","comments":true,"path":"2017/06/30/Vuejs基础/","link":"","permalink":"http://yoursite.com/2017/06/30/Vuejs基础/","excerpt":"","text":"Vue.js是什么 Vue.js（读音 /vjuː/，类似于 view） 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。 如何安装vue 通过bower安装bower: npm install bower -gmac本: sudo npm install bower -g查看vue的版本 ： bower info vue安装vue：bower install vue@1.0.28 通过npm安装通过npm: npm install vue通过npm全局安装: npm install vue -g","categories":[],"tags":[{"name":"Vuejs","slug":"Vuejs","permalink":"http://yoursite.com/tags/Vuejs/"}]},{"title":"相对路径与绝对路径","slug":"相对路径与绝对路径","date":"2017-06-30T08:59:57.000Z","updated":"2017-08-16T15:29:30.990Z","comments":true,"path":"2017/06/30/相对路径与绝对路径/","link":"","permalink":"http://yoursite.com/2017/06/30/相对路径与绝对路径/","excerpt":"","text":"路径url绝对路径 指带域名的文件的完整路径或磁盘中指定文件的全部路径。 例如：C:\\windows\\system32\\cmd.exe 例如：http://www.zhufengpeixun.com/ 可以理解为地址：珠峰培训的地址是北京昌平区回龙观东大街3号楼02号东段珠峰培训 相对路径 是指在同一个文件夹下通过一个参考点找到其他文件 返回上一级用“../” 平级之间直接写文件名 下一级用“/”1&lt;link rel=&quot;stylesheet&quot; href=&quot;../面试题.md&quot;&gt;","categories":[],"tags":[{"name":"相对路径与绝对路径","slug":"相对路径与绝对路径","permalink":"http://yoursite.com/tags/相对路径与绝对路径/"}]},{"title":"CSS属性的继承及相关面试题","slug":"CSS属性的继承及相关面试题","date":"2017-06-30T08:56:14.000Z","updated":"2017-08-16T15:32:20.878Z","comments":true,"path":"2017/06/30/CSS属性的继承及相关面试题/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS属性的继承及相关面试题/","excerpt":"","text":"CSS属性的继承 子级元素从父级元素身上继承的一些可继承的css属性 1234&lt;style&gt;div&#123;color:red;&#125;&lt;/style&gt;&lt;p&gt;woshiyige[biaoqian&lt;/p&gt; 根据 CSS，子元素从父元素继承属性。看看下面这条规则： body {font-family: Verdana, sans-serif;} 根据上面这条规则，站点的 body 元素将使用 Verdana 字体（假如访问者的系统中存在该字体的话）。 继承的权重较小，可被其他选择器的样式覆盖 面试题： 哪些css样式可以被继承：和文字有关的css样式 和列表有关的css样式总结： 1.可继承属性 1)可以继承的文本相关属性： 1&lt;azimuth&gt;&lt;border-collapse&gt;&lt;border-spacing&gt;&lt;caption-side&gt;&lt;color&gt;&lt;cursor&gt;&lt;direction&gt;&lt;elevation&gt;&lt;empty-cells&gt;&lt;font-family&gt;&lt;font-size&gt;&lt;font-style&gt;&lt;font-variant&gt;&lt;font-weight&gt;&lt;font&gt;&lt;letter-spacing&gt;&lt;line-height&gt;&lt;list-style-image&gt;&lt;list-style-position&gt;&lt;list-style-type&gt;&lt;list-style&gt;&lt;orphans&gt;&lt;pitch-range&gt;&lt;pitch&gt;&lt;quotes&gt;&lt;richness&gt;&lt;speak-header&gt;&lt;speaknumeral&gt;&lt;speak-punctuation&gt;&lt;speak&gt;&lt;speechrate&gt;&lt;stress&gt;&lt;text-align&gt;&lt;text-indent&gt;&lt;texttransform&gt;&lt;visibility&gt;&lt;voice-family&gt;&lt;volume&gt;&lt;whitespace&gt;&lt;widows&gt;&lt;word-spacing&gt; 2)可以继承的列表相关属性： 1&lt;azimuth&gt;&lt;border-collapse&gt;&lt;border-spacing&gt;&lt;caption-side&gt;&lt;color&gt;&lt;cursor&gt;&lt;direction&gt;&lt;elevation&gt;&lt;empty-cells&gt;&lt;font-family&gt;&lt;font-size&gt;&lt;font-style&gt;&lt;font-variant&gt;&lt;font-weight&gt;&lt;font&gt;&lt;letter-spacing&gt;&lt;line-height&gt;&lt;list-style-image&gt;&lt;list-style-position&gt;&lt;list-style-type&gt;&lt;list-style&gt;&lt;orphans&gt;&lt;pitch-range&gt;&lt;pitch&gt;&lt;quotes&gt;&lt;richness&gt;&lt;speak-header&gt;&lt;speaknumeral&gt;&lt;speak-punctuation&gt;&lt;speak&gt;&lt;speechrate&gt;&lt;stress&gt;&lt;text-align&gt;&lt;text-indent&gt;&lt;texttransform&gt;&lt;visibility&gt;&lt;voice-family&gt;&lt;volume&gt;&lt;whitespace&gt;&lt;widows&gt;&lt;word-spacing&gt; 2.不可继承属性 1&lt;display&gt;&lt;margin&gt;&lt;border&gt;&lt;padding&gt;&lt;background&gt;&lt;height&gt;&lt;min-height&gt;&lt;max-height&gt;&lt;width&gt;&lt;min-width&gt;&lt;max-width&gt;&lt;overflow&gt;&lt;position&gt;&lt;left&gt;&lt;right&gt;&lt;top&gt;&lt;bottom&gt;&lt;z-index&gt;&lt;float&gt;&lt;clear&gt;&lt;table-layout&gt;&lt;vertical-align&gt;&lt;page-break-after&gt;&lt;page-bread-before&gt;和&lt;unicode-bidi&gt; 3.所有元素可继承： &lt;visibility&gt;（可见性）和&lt;cursor&gt;(光标) 4.终端块状元素可继承： &lt;text-indent&gt;和&lt;text-align&gt; 5.如果css属性不带有继承性，如何继承父级身上的属性，可以将要继承的属性的属性值写上inherit12ul&#123;float:left;&#125;li&#123;float:inherit;&#125;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS中的form表单与table表格","slug":"CSS中的form表单与table表格","date":"2017-06-30T08:15:23.000Z","updated":"2017-08-16T15:32:15.668Z","comments":true,"path":"2017/06/30/CSS中的form表单与table表格/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS中的form表单与table表格/","excerpt":"","text":"form表单 用来获取用户信息&lt;form&gt;&lt;/form&gt; 12345678910111213141516171819202122&lt;form&gt; &lt;input type=&quot;radio&quot; name=&quot;ok&quot; checked=&quot;checked&quot;&gt;&lt;!--单选按钮--&gt;&lt;label&gt;满意&lt;/label&gt;&lt;!--label 描述表单元素功能--&gt; &lt;!--type 类型--&gt; &lt;!--name 名字--&gt; &lt;!--checked 选中--&gt; &lt;input type=&quot;radio&quot; name=&quot;ok&quot;&gt;&lt;!--单选按钮--&gt;&lt;label&gt;不满意&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;篮球&lt;/label&gt; &lt;input type=&quot;checkbox&quot; checked&gt;&lt;label&gt;美女&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;彭于晏&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;陈冠希&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;杨颖&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;维密&lt;/label&gt; &lt;textarea maxlength=&quot;10&quot; minlength=&quot;1&quot;&gt;&lt;/textarea&gt;&lt;!--文本域--&gt; &lt;!--maxlength 字符输入的最大长度--&gt; &lt;br&gt; &lt;label&gt;姓名&lt;/label&gt;&lt;input type=&quot;text&quot;&gt; &lt;br&gt; &lt;label&gt;手机&lt;/label&gt;&lt;input type=&quot;text&quot;&gt; &lt;br&gt; &lt;label&gt;密码&lt;/label&gt;&lt;input type=&quot;password&quot;&gt;&lt;/form&gt; radio 单选按钮 name=”ok”（name的值相同情况下）同时给到input type=”radio”，表示单选只能选中其中的一个 lable描述表单元素功能 type 类型 name 名字 cheked 选中 单独写checked也可以达到选中的效果 &lt;input type=&quot;checkbox&quot;&gt;checkbox 多选按钮 textarea 文本域 &lt;textarea maxlength=&quot;10&quot; minlength=&quot;1&quot;&gt;&lt;/textarea&gt; maxlength字符输入的最大长度 table表格 &lt;caption&gt;标题&lt;/caption&gt; &lt;thead&gt;表头&lt;/thead&gt; tr&gt;th（标题单元格，th加粗居中） &lt;tfoot&gt; 表尾 tr&gt;th（普通单元格） tr&gt;td（普通单元格，td不加粗不居中） tbody 表身 tr&gt;th（普通单元格） thead和tfoot分别有一个 tbody可以有多个tfoot一般放置在thead的后面，为了防止tbody中的内容过多，tfoot加载过慢的情况，但是虽然书写位置在前面，在页面中显示的时候，这部分依然在整个表格的最后面如果table用来搭建结构，我们只需写tr和td 123456789101112&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"标签语义化","slug":"CSS标签语义化","date":"2017-06-30T08:11:33.000Z","updated":"2017-08-16T15:32:38.255Z","comments":true,"path":"2017/06/30/CSS标签语义化/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS标签语义化/","excerpt":"","text":"标签语义化的重要性/为什么要遵循标签语义化：合理的标签做合理的事情 1、重要的内容，要放在语义重要的标签中，利于SEO优化(搜索引擎榨取),利于SEO优化(也就是搜索引擎的抓取，搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重); 浏览器会按照每个标签的意义去解析这个标签中的内容:h1–&gt;这是一个大标题，意义很重要，搜索引擎会重点抓取这个里面的内容 p–&gt;段落 浏览器在展现这一部分的时候，会独立成一块，让网页结构更加清晰，给用户更好的浏览体验 2、在没有css样式的时候，页面也可以整齐的显示效果 3、更好的支持各种终端，例如无障碍阅读和有声小说等； 4、利于团队协作和后期维护 日常工作中怎样遵循标签语义化： 1、尽量减少使用无意义标签，例如span和div； 2、尽量不使用标签本身的css属性，例如b、font、s等标签，如果需要这些样式，那么使用css样式来进行添加； 3、在需要强调的部分，使用strong、em，但是样式尽量使用css样式来描述； 4、表格搭建时，使用`表格头部 表格身体 表格尾部； 5、列表搭建时，使用无序列表 有序列表 定义列表；` 国家评比一个网站的关键点：访问量（流量/点击量）","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML标签分类","slug":"HTML标签分类","date":"2017-06-30T08:09:06.000Z","updated":"2017-08-16T15:33:24.932Z","comments":true,"path":"2017/06/30/HTML标签分类/","link":"","permalink":"http://yoursite.com/2017/06/30/HTML标签分类/","excerpt":"","text":"html标签分类 html标签又叫做html元素，它分为块级元素和内联元素（也可以叫做行内元素），都是html规范中的概念。 块级元素 块级元素是指本身属性为display:block;的元素。因为它自身的特点，我们通常使用块级元素来进行大布局（大结构）的搭建 块级元素的特点： 独占一行，每一个块级元素都会从新的一行重新开始，从上到下排布 可以直接控制宽度、高度以及盒子模型的相关css属性 在不设置宽度的情况下，块级元素的宽度是它父级元素内容的宽度 在不设置高度的情况下，块级元素的高度是它本身内容的高度 常用的块级元素: div 常用块级容器，也是css layout的主要标签 h1 大标题 h2 副标题 h3 三级标题 h4 四级标题 h5 五级标题 h6 六级标题 12345678910标题：&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;h$&#123;$级标题&#125;*6+tab生成：&lt;h1&gt;1级标题&lt;/h1&gt;&lt;h2&gt;2级标题&lt;/h2&gt;&lt;h3&gt;3级标题&lt;/h3&gt;&lt;h4&gt;4级标题&lt;/h4&gt;&lt;h5&gt;5级标题&lt;/h5&gt;&lt;h6&gt;6级标题&lt;/h6&gt; hr 水平分隔线 menu 菜单列表 ol 有序列表 li列表项 123456789有序列表&lt;ol&gt; &lt;li&gt;盗天仙图&lt;/li&gt; &lt;li&gt;名侦探&lt;/li&gt; &lt;li&gt;鬼吹灯&lt;/li&gt; &lt;li&gt;盗墓笔记&lt;/li&gt; &lt;li&gt;名侦探&lt;/li&gt; &lt;li&gt;鬼吹灯&lt;/li&gt;&lt;/ol&gt; ul 无序列表 li列表项 123456789无序列表&lt;ul&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;有保证&lt;/b&gt;&lt;/span&gt;:先学习考试后入学&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;有实力&lt;/b&gt;&lt;/span&gt;:专注JS培训七年铸就传奇就业,平均工资超12K&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;有深度&lt;/b&gt;&lt;/span&gt;:结合的大学算法和数据结构的基础课&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;重原生&lt;/b&gt;&lt;/span&gt;:狠练原生代码,原生JS+Node才是王道&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;重应用&lt;/b&gt;&lt;/span&gt;:PC+移动端+H5+CSS3+node的前后台全栈项目&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;重未来&lt;/b&gt;&lt;/span&gt;:app开发,微信开发,angular,es6,前沿技术&lt;/li&gt;&lt;/ul&gt; dl 定义列表 dt 定义术语 dd定义描述 table 表格 p 段落1234567891011&lt;div class=&quot;poem&quot;&gt;&lt;h4&gt;早发白帝城&lt;/h4&gt;&lt;h5&gt;作者：李白&lt;/h5&gt;&lt;p&gt;朝辞白帝彩云间，&lt;br&gt; 千里江陵一日还。&lt;br&gt; 两岸猿声啼不尽，&lt;br&gt; 轻舟已过万重山。&lt;br&gt; &lt;img src=&quot;timg.jpg&quot; alt=&quot;李白&quot;&gt;&lt;/p&gt;&lt;/div&gt; 123456789&lt;div&gt; &lt;h4 align=&quot;center&quot;&gt;早发白帝城&lt;/h4&gt; &lt;h5 align=&quot;center&quot;&gt;作者：李白&lt;/h5&gt; &lt;p align=&quot;center&quot;&gt;朝辞白帝彩云间，&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;千里江陵一日还。&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;两岸猿声啼不尽，&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;轻舟已过万重山。&lt;/p&gt; &lt;img src=&quot;timg.jpg&quot; alt=&quot;李白&quot;&gt;&lt;/div&gt; - form 交互表单 - 内联元素 - 内联元素是指本身属性为display:inline;的元素。因为它自身的特点，我们通常使用块级元素来进行文字、小图标（小结构）的搭建。 - 内联元素的特点： - 1. 和其他内联元素从左到右在一行显示 - 2.不能直接控制宽度、高度以及盒子模型的相关css属性，但是直接设置内外边距的左右值是可以的 - 3.内联元素的宽高是由本身内容的大小决定（文字、图片等） - 4.内联元素只能容纳文本或者其他内联元素（此处请注意，不要在内联元素中嵌套块级元素） - 常用的内联元素: - span 常用内联容器，定义文本内区块 - a 锚点 - 文本设置类: - b 加粗 - strong 加粗强调 - i 斜体 - em 斜体强调 - s 中划线（不推荐使用） - strike 中划线 - del 文档中已被删除的文本 - big 大字体文本、small小字体文本） - small 小字体文本 - br 强制换行 - u 下划线 - textarea 多行文本输入框 - input 输入框 - select 下拉列表 - label（input 元素定义标注/标记）、img - sub 下标 - sup 上标","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML基本结构","slug":"HTML基本结构","date":"2017-06-30T07:59:54.000Z","updated":"2017-08-16T15:23:02.440Z","comments":true,"path":"2017/06/30/HTML基本结构/","link":"","permalink":"http://yoursite.com/2017/06/30/HTML基本结构/","excerpt":"","text":"html的基本结构123456789101112&lt;!DOCTYPE html&gt;文档声明：必须放在html文件的第一行；如果没有文档声明会触发浏览器的怪异模式&lt;html&gt;html元素：告知浏览器，我是一个html文件 &lt;head&gt; head元素：文档的头部，一般放在文档头部的内容不会显示在浏览器的可视区内 &lt;meta charset=&quot;utf-8&quot;&gt;规定一个语法 必须放在head的第一部分 &lt;title&gt;标题，显示在浏览器的页卡位置，title中的内容也会被seo抓取&lt;/title&gt; &lt;body&gt;供用户浏览的所有内容，标签、图片、文本、视频···&lt;/body&gt; &lt;/head&gt;&lt;/html&gt; 一个html文件也叫做一个网页，可以称作是一个文档(document) 这个文档从html元素开始，一致向下分支延伸，像一颗大树一样，所以我们将html元素叫做这个文档的根元素 &lt;!DOCTYPE html&gt;html5的文档声明 作用：定义这个文档类型，浏览器先识别这句话，会按照定义的类型去解析这个文档 html5的文档声明，那么浏览器就会按照html5的规则解析整个页面`&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;html4版本的文档声明` 所有高版本都会向下兼容，所以在以后的工作中，我们直接将文档声明写错html5就可以了 文档声明必须写在html文件的第一行 文档声明不区分大小写 如果html文件没有文档声明，会触发浏览器的怪异模式 文档声明不是一个html标签 1.html元素此元素告知浏览器其自身是一个html元素是由开始和结束标签组成的，html文件里面所有的内容都会放在这个这个元素内 2.head元素- 整个文档的头部，head元素自带隐藏功能，display:none;里面的内容不会隐藏，只不过一般放置在head元素中的其他元素和内容也是自带隐藏功能的，例如link、script、meta··· - `&lt;script&gt;&lt;/script&gt;与head标签一样具有隐藏功能，写在其内的内容在网页不显示` 3.&lt;meta charset=&quot;UTF-8&quot;&gt;4.&lt;meta&gt;规定了html文档的元信息 charset=”UTF-8” 文档的编码 UTF-8 国际通用编码 gbk 国标 gb2312 国标 name=”keyword” content=”关键词” name=”keyword” content=”HTML5J5…” SEO优化有关 SEO搜索引擎&lt;meta name=&quot;keyword&quot; content=&quot;关键词&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;勿忘初心,方得始终&quot;&gt; 5.title元素 html文档名称 一个页面只有一个title元素放文字 显示在浏览器的页卡（页头）位置6.link标签 &lt;link href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; rel=&quot;shortcut icon&quot;&gt; 图标让设计师生成 一般整个图片放在整个项目的根目录下 显示在浏览器页卡位置，title内容之前 &lt;link rel=&quot;stylesheet&quot; herf=&quot;url&quot; type=&quot;texe/css&quot;&gt; 引入一个外部的css文件 rel不能缺少 stylesheet样式表 type可以省略 但是建议写全 7.body元素 定义整个文档的主体部分，所有展示给用户的内容都要放在这个元素中 body中有常用的html元素（div、ul），文本内容、音频、视频、图片、表单1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UIF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"CSS的引入方式","slug":"CSS的引入方式","date":"2017-06-30T07:27:20.000Z","updated":"2017-08-16T15:22:11.645Z","comments":true,"path":"2017/06/30/CSS的引入方式/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS的引入方式/","excerpt":"","text":"css如何在html中使用（html引入css的四种方法） 行内式：直接写在标签内，通过标签属性style引入 媒介：style属性&lt;style type=&quot;text/css&quot;&gt;选择器{}&lt;/style&gt;12&lt;div style=&quot;css属性名:属性值；&quot;&gt;&lt;/div&gt;&lt;img style=&quot;css属性名:属性值；&quot;alt=&quot;&quot;&gt; css想要生效，html中必须有这个元素才可以 内嵌式（内联式）:将css代码写在style元素内，通过css选择器选择html元素，将css样式添加个这个元素 媒介：style标签+选择器 style这个元素一般放在head元素内 style元素：盛装css样式12345&lt;style&gt;div&#123;height:100px;&#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 外联式（外链式）：将css代码单独放置在一个css文件中，再通过link标签将这个css文件引入到html文件中 媒介：link标签+选择器1&lt;link rel=&quot;stylesheet&quot; herf=&quot;css文件链接地址&quot; type=&quot;text/css&quot;&gt; css这个文件中不能出现标签 导入式：都是引入一个单独的css文件 媒介：@import”css文件链接地址”; 当有多个css文件的时候，可以使用导入式先导入到一个css文件中，再用外链式link外链进html文件 @import”css文件链接地址”;既不是html标签，也不是css属性，他是一条声明语句 这条语句必须写在style元素内,或者css文件内 这条语句必须在所在文件内的第一行 外链式和导入式的差别： link和@import虽然都是引入外部的css文件，但是他们是由天差地别的区别的 1) link是html标签，@import完全是css提供的方式，要写在css文件或者style标签中。 2) 他们的加载顺序也是有区别的，当一个页面被加载的时候，link引用的css文件会被同时加载，而@import引入的css文件会等页面全部下载完后再加载。 3) 当使用javascript控制DOM去改变css样式的时候，只能使用link标签，因为import是不能被DOM控制的。 在工作中常用的引入方式是外链式 四种引入方式的权重（一个html元素最终加载的css样式是谁决定的） 有行内式的时候，听行内的 在选择器相同的情况下，谁最后加载就听谁的 外链式和内嵌式一般都放在head元素内 CSS层叠样式表 css的作用： 给html文档添加静态或者动态的样式 css和html如何融合到一起 在css文件中如何选择一个html元素，将样式添加给这个元素","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS常用选择器","slug":"CSS常用选择器","date":"2017-06-30T07:14:52.000Z","updated":"2017-08-16T15:32:26.391Z","comments":true,"path":"2017/06/30/CSS常用选择器/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS常用选择器/","excerpt":"","text":"CSS选择器 因为html和css分离，那么就出现一个问题，如何选择一个元素，将样式添加给这个元素–&gt;css选择器 选择器是css属性和html元素的连接桥梁，通过正确的选择器来找到想要操作的元素，添加一定的样式。 选择器{} 1.语法选择器{key:value;key:value;} 可以批量选择选择器名称相同的元素 通过选择器类型不同，可以选择不同的html元素 2.CSS基础选择器分类1) 标签选择器 直接使用元素标签进行选择 例如：&lt;p&gt;&lt;/p&gt; p{color:red;} 权重：11234&lt;style&gt;h1&#123;color:red;&#125;&lt;/style&gt;&lt;h1&gt;标签选择器&lt;/h1&gt; 2) 类选择器 将html元素的class标签属性值当作选择器使用，需要在这个属性值前面加一个“.” 通过元素的类名，来选择元素，一个元素可以有多个类名，都代表这个元素 类名是元素class属性中的属性值，例如 .sum{} 一个html元素可以有多个css属性值（可以有多个类名，每一个类名之间用空格隔开）类名可以重复使用 权重：10 p.s：类选择器最前方一定要有点12345&lt;style&gt;.tytle&#123;color:red;&#125;&lt;/style&gt;&lt;h1 class=&quot;tytle title1&quot;&gt;标签选择器&lt;/h1&gt;&lt;h1 class=&quot;tytle&quot;&gt;标签选择器&lt;/h1&gt; 3) id选择器 一个html元素，id属性值只能用一次，id在html中具有唯一性 类选择器最前方一定要有# 通过元素的id名，来选择元素 权重：100 类名是元素id属性中的属性值，例如12345&lt;style&gt;#tytle&#123;color:red;&#125;&lt;/style&gt;&lt;h1 id=&quot;tytle title1&quot;&gt;id选择器&lt;/h1&gt;&lt;h1 id=&quot;tytle&quot;&gt;错误的，不识别&lt;/h1&gt; ###总结：标签选择器相当于人的姓名，类选择器相当于人的名字，id选择器相当于身份证号码。 4) 通配符选择器 通过*匹配全部html元素，包括根元素 一般不使用，因为全部匹配耗性能 *{} 权重&lt;1，可被覆盖1*&#123;key:value&#125; 5) 并集选择器 你可以对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。用逗号将需要分组的选择器分开。在下面的例子中，我们对所有的标题元素进行了分组。所有的标题元素都是绿色的。 例如：1h1,h2,h3,h4,h5,h6&#123;color:green;&#125; 6) 属性选择器 对带有指定属性的 HTML 元素设置样式，可以为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。 属性选择器： 下面的例子为带有 title 属性的所有元素设置样式：1234[title] &#123; color:red; &#125; 利用标签的属性名和属性值来选择html元素 权重：10 语法： [标签属性名]{} [标签属性名=属性值]{}123456789&lt;style&gt;h1[title]&#123;&#125;交集选择器标签+属性的权重=11[type]&#123;&#125;权重：10[type=text]&#123;&#125;权重：10&lt;/style&gt;&lt;a href=&quot;&quot; title=&quot;&quot;&gt;link&lt;/a&gt; 7)属性和值选择器 下面的例子为 title=”zfpx” 的所有元素设置样式： 1234[title=zfpx] &#123; border:5px solid blue; &#125; 设置表单的样式12345678input[type=&quot;text&quot;]&#123; width:150px; display:block; margin-bottom:10px; background-color:yellow; font-family: Verdana, Arial;&#125; 8)分组选择器作用（应用场景）：同一份css样式，可以一次性的添加给多个不同的html元素权重：分组选择器将不同的html分为一组，权重计算的时候都是独立计算，不会叠加。语法：选择器1，选择器2，选择器3{}12.box,li,.p1&#123;color: red&#125;.box&#123;color:green&#125; 9)交集选择器 两种属性同属一个元素的时候，我们可以使用交集选择器来进行元素的准确选择 &lt;p class=&#39;name1 name2&#39; id=&#39;id1&#39;&gt;&lt;/p&gt; p.name1{} p#id1{} .name1.name2{} 组合选择器之间没有任何的符号和空格 标签选择器和其他选择器组合的时候，标签选择器要放在前面 交集选择器是两个选择器组合在一起，可以是标签和类名，标签和属性选择器，标签和ｉｄ，两个类选择器 作用：精确查找元素，增加选择器的权重 1234567891011121314151617&lt;style&gt;h1&#123;&#125; 标签选择器 权重：1[title]&#123;&#125; 属性选择器 权重：10[title=zfpx]&#123;&#125; 属性选择器 权重：10h2[title]&#123;&#125; 交集选择器 权重：11h2[title=zfpx]&#123;&#125; 交集选择器 权重：11&lt;/style&gt;&lt;h1 title=&quot;zfpx&quot;&gt;&lt;/h1&gt;&lt;h2 title=&quot;zfpx&quot;&gt;&lt;/h2&gt;&lt;style&gt;p.p1&#123;&#125; 交集选择器 权重：11&lt;/style&gt;&lt;p class=&quot;p1&quot;&gt;&lt;/p&gt;&lt;style&gt;.p1.p2&#123;&#125; 交集选择器 权重：20&lt;/style&gt;&lt;p class=&quot;p1 p2&quot;&gt;&lt;/p&gt; 属性选择器在使用的时候，如果一个元素有两个类名，那么是不生效的。例如： 属性选择器我们一般不会使用class，因为class可以直接使用类选择器12345&lt;!--有多少种方法只获取div--&gt; /*如果class值有两个，不能这样使用*/ [class=div1]&#123;&#125;&lt;div class=&quot;div1 p1&quot; id=&quot;div2&quot;&gt;&lt;/div&gt;&lt;p class=&quot;p1&quot;&gt;&lt;/p&gt; 10)子集选择器 与后代选择器相比，子元素选择器只能选择作为某元素子元素的元素。 语法：父级选择器&gt;子级选择器 父级选择器是用来确定范围的， 子级选择器才是我们要添加样式的那个元素 权重：所有选择器之和 子级选择器必须是紧邻的父子关系1234567&lt;style&gt;ul&gt;li&#123;color:red;&#125; 选择ul下的li权重：2&lt;/style&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 11)后代选择器 html结构： 1234&lt;ol&gt; &lt;li&gt;&lt;strong&gt;我是斜体字。这是因为 strong 元素位于 li 元素内。&lt;/strong&gt; &lt;/li&gt;&lt;/ol&gt; 列表中的 strong 元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器： 1234li strong &#123; font-style: italic; font-weight: normal; &#125; 在一个根元素的范围内，查找到它的后代元素 语法：祖辈选择器 要查找的后代选择器{}中间用空格连接 后代选择器在写的时候尽量控制在３个左右 选择器过多浪费性能，不建议使用 123456789101112131415161718192021222324252627&lt;style&gt;.div1 ul span&#123;&#125;&lt;/style&gt;&lt;div class=&quot;div1&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;只选择这个span元素&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt; &lt;span&gt;wenzdskaldjaslk&lt;/span&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;div class=&quot;div2&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;wenzdskaldjaslk&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt; &lt;span&gt;wenzdskaldjaslk&lt;/span&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12)相邻兄弟选择器 相邻兄弟选择器可选择紧接在另一元素后的元素，且二者有相同父元素。 h1 + p {margin-top:50px;} 通过各个元素选择弟弟选择器，两个选择器之间用“+”连接 语法：哥哥选择器+弟弟选择器{} 权重：选择器之和12345678910111213&lt;style&gt; .list1+li&#123;color: red;&#125; 22222变为红色 .list3+li&#123;color: green;&#125; 4444变为绿色 /*li+.list3&#123;&#125;*/&lt;/style&gt;&lt;ul&gt; &lt;li class=&quot;list1&quot;&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li class=&quot;list3&quot;&gt;33333&lt;/li&gt; &lt;li&gt;4444&lt;/li&gt;&lt;/ul&gt; 伪类选择器 给一个元素添加某种状态 例如：鼠标经过时 获取焦点时 鼠标点击时 权重：10 1) a标签 CSS 伪类用于向某些选择器添加特殊的效果 12345678910111213&lt;style&gt; a:link &#123;color: #FF0000&#125; /* 未访问的链接 是默认状态*/ a:visited &#123;color: #00FF00&#125; /* 已访问的链接 鼠标点击后的状态*/ a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 鼠标经过的状态*/ a:active &#123;color: #0000FF&#125; /* 选定的链接 鼠标点击的状态*/&lt;/style&gt;&lt;a href=&quot;javascript:void (0)&quot;&gt;最初形态&lt;/a&gt;&lt;a href=&quot;javascript:void 0&quot;&gt;赛亚人形态&lt;/a&gt;&lt;a href=&quot;javascript:&quot;&gt;超级赛亚人形态&lt;/a&gt; 2)input标签 1234567&lt;style&gt; .input&#123;border: 1px solid gainsboro&#125; .input:hover&#123;border-color: gray&#125; .input:focus&#123;border-color: blue&#125; /*input:focus 鼠标聚焦后的状态，input独有的属性*/&lt;/style&gt;&lt;input type=&quot;text&quot; class=&quot;input&quot;&gt; CSS 伪元素 通过css代码向指定元素内添加假的（html中不存在的）元素 CSS 伪元素用于向某些选择器设置特殊效果 1)before 会出现在div所有内容之前 “:before” 伪元素可以在元素的内容前面插入新内容。 下面的例子在每个 &lt;h1&gt; 元素前面插入一幅图片：1234h1:before &#123; content:&apos;我是一个伪元素&apos;; &#125; 2)after 会出现在div所有内容之后使用伪元素的时候要保证两个前提 要有display这个属性 要有content这个属性，这个属性的属性值可以为空，但是引号不能少content:&quot;&quot;12345678910111213141516171819202122232425262728&lt;style&gt; div&#123; width: 300px; height: 300px; background-color: red; &#125; div:before&#123; display: block; content: &quot;我是before&quot;; font-size: 40px; color: white; &#125; div:after&#123; display: block; content: &quot;我是aftre&quot;; font-size: 40px; color: blue; &#125;&lt;/style&gt;&lt;div&gt; &lt;span&gt;我是span&lt;/span&gt;&lt;/div&gt;网页显示：&lt;div&gt;::before&lt;span&gt;···&lt;span&gt;::after&lt;/div&gt;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Window快捷键整理","slug":"Window快捷键整理","date":"2017-06-30T07:12:01.000Z","updated":"2017-08-16T15:28:38.277Z","comments":true,"path":"2017/06/30/Window快捷键整理/","link":"","permalink":"http://yoursite.com/2017/06/30/Window快捷键整理/","excerpt":"","text":"window+E 打开我的电脑 alt+tab 切换操作界面 window+R 运行 ctrl+C 复制 ctrl+X 剪切 ctrl+S 保存 ctrl+shift+S 另存 ctrl+Z 撤销 ctrl+W 关闭 ctrl+A 全选 ctrl+V 粘贴 ctrl+alt+delete 资源管理器 或 菜单右键选择资源管理器 F2 重命名 web： ctrl+alt+L整理代码","categories":[],"tags":[{"name":"Window快捷键","slug":"Window快捷键","permalink":"http://yoursite.com/tags/Window快捷键/"}]},{"title":"CSS中常用的HTML元素及标签","slug":"CSS中常用的HTML元素及标签","date":"2017-06-30T06:35:23.000Z","updated":"2017-08-16T15:32:09.916Z","comments":true,"path":"2017/06/30/CSS中常用的HTML元素及标签/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS中常用的HTML元素及标签/","excerpt":"","text":"常用的HTML标签总结 div 无意义标签，用来区分网页大模块，例如网页头部、主题内容、尾部&lt;div&gt;无意义元素，用它来区分网页大模块&lt;/div&gt;123456789banner&lt;div&gt;区分模块 &lt;a href=&quot;http://www.baidu.com&quot;&gt; &lt;img src=&quot;pic.jpg&quot; alt=&quot;备注/描述&quot;&gt; &lt;/a&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;&quot; alt=&quot;图片加载出问题了&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt; &lt;/a&gt;&lt;/div&gt; span 无意义标签,用来描述行内某个小模块 p &lt;p&gt;段落&lt;/p&gt; ul li 无序列表 ol li 有序列表 b 加粗 strong 加粗,浏览器解析的时候,有强调作用 body 身体,网页主体部分 （内容在浏览器可视区显示） a 超链接,描点123点击元素可以进行跳转的&lt;a href=&quot;链接路径&quot; target=&quot;_blank&quot;&gt;珠峰培训&lt;/a&gt;&lt;a href=&quot;pic.jpg&quot; target=&quot;_blank&quot;&gt;珠峰培训&lt;/a&gt; img 插入图片12&lt;img src=&quot;图片路径&quot; alt=&quot;备注/描述&quot;&gt;&lt;img src=&quot;pic.jpg&quot; alt=&quot;备注/描述&quot;&gt; i 作用：斜体 em 强调 作用：*斜体 h1-h6 标题 dl-dt-dd定义列表 常用在新闻标题和摘要 dt 定义标题 dd 定义描述 一个dt可以多个dd进行描述 标签 标签（由尖括号和关键字组成的超文本） 关键字（就是普通文本），在编辑html这门语言的时候，相关组织将这些文本归纳到了一定的规则中，是他有了特殊的含义和作用 标签的分类：开始标签、结束标签、空标签 12345678&lt;开始标签&gt;&lt;空标签 /&gt;&lt;div&gt;&lt;/div&gt;&lt;b&gt;&lt;/b&gt;&lt;strong&gt;&lt;/strong&gt;&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;···&lt;/结束标签&gt; 标签属性：用来描述标签功能的，一般写在开始标签中，跟在标签名的后面，用空格隔开，一个标签可以有很多标签属性，每一个属性都用空格隔开 12&lt;开始标签 属性名=&quot;属性值&quot; 属性名1=&quot;属性值&quot;&gt;&lt;结束标签&gt;&lt;img src=&quot;url&quot; alt=&quot;备注&quot; /&gt; html标签 html标签HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。 标签不会出现在页面中，只有标签中的内容才会显示在页面上 ：也就是&lt;html&gt;此处为内容&lt;/html&gt; 标签不区分大小写，但是推荐使用小写 ：(X)HTML 版本中强制使用小写，这样更加严谨 标签分为闭合标签和空标签 ：闭合标签是指由开始标签和结束标签组成的一对标签，这种标签允许嵌套和承载内容，例如：&lt;html&gt;&lt;/html&gt;、&lt;p&gt;&lt;/p&gt;；空标签是没有内容的标签，在开始标签中自动闭合，例如：&lt;img /&gt;、&lt;br /&gt;、&lt;hr /&gt;等 元素 由标签（开始和结束标签中有内容）和内容组成，元素中内容可以为空，一个空标签也叫做一个元素 12&lt;div&gt;content&lt;/div&gt;--&gt;div元素&lt;img src=&quot;url&quot; alt=&quot;备注&quot; /&gt;--&gt;img元素 标签属性经过html的进化，舍弃了有关样式的标签属性，保留功能的标签属性 例如舍弃width bgcolor align，这些样式描述都放在css里面 保留alt title src href··· iframe标签在引入其他文件的时候，必须写宽度和高度","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"“前端三层”","slug":"“前端三层”","date":"2017-06-30T06:26:17.000Z","updated":"2017-08-16T15:28:38.285Z","comments":true,"path":"2017/06/30/“前端三层”/","link":"","permalink":"http://yoursite.com/2017/06/30/“前端三层”/","excerpt":"","text":"前端三层 html结构 是直接被浏览器解析加载 CSS样式 是在html结构之上去装点网站 javascript 交互 动态效果/数据交互 基础知识 网页 网页是构成网站的基本元素，通俗来讲，一个html文件就是一个网页 网站 是由很多个网页组成的，共同为一个目标服务的网页集合 站群（流水线统一化管理） 由很多网站组成的，为同一个公司服务。 例如整个百度下所属的子公司都有自己的网站。例如：百度搜索/糯米/音乐/手机助手/百度金融等组成的就是一个站群。 HTTP（超文本传输协议） HyperText Transfer Protocol 在万维网上提供一种发布和接收HTML页面（网页）的方法。 eg：http://www.baidu.com 404服务器无响应 步骤: 输入网址，建立链接，建立客户端和服务端的连接。 发送请求信息：客户端发送一个请求给服务器 发送相应信息：服务器找到请求后，给予相应的响应信息 关闭连接：客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接 服务器 服务器，是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。 在网络环境下，根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，WEB服务器等。 防篡改：WEB端服务器一旦受到攻击，在0.0n秒做出反应，将内网服务器中的内容，马上覆盖在WEB服务器上。 负载均衡：平均WEB服务器压力，将用户访问进行分流。 vpn：用来翻墙，有指定账号就可以通过这个产品进行内网访问。 浏览器 浏览器是指可以显示网页服务器或者文件系统的HTML文件（标准通用标记语言的一个应用）内容，并让用户与这些文件交互的一种软件。 html，css，js都是运行在这个软件中，浏览器是一个工厂，html/css/js是工人和原料。 IE6–&gt;IE7（很快淘汰）–&gt;IE8(时间较长，稳定性好)–&gt;IE9(半年到一年)–&gt;IE10–&gt;IE11–&gt;IE11–&gt;IE(Edge) 最好用的浏览器–&gt;谷歌 网页的基本组成 HTML:是网页的骨架,支撑起血肉(文字,图片,音视频等) CSS:表皮和衣服、化妆品 javascript：动态和交互 HTML（超文本标记语言） 网页本身就是一种文本文件（除了文字再无其他），只有通过特定的标记描述，那些普通文本才能在浏览器中正常显示。 在页面中如果遇到图片、音视频的时候，如何用文本描述，需要用超文本进行引入才可以正常显示。 HTML文件的特点： 浏览器根据标记来解析和描述内容（从html的第一行开始向下），如果遇到错误，浏览器不会指出也不会报错，会跳过此处继续加载，编辑人员需要根据显示效果去分析哪里出错误了——html不会报错 HTML的兼容问题： 因为浏览器是由不同厂商生产的，所以对html的解析有分歧，产生了页面效果显示不一致的情况，我们将这个问题叫做兼容问题。 超文本（标签） 标签语法： 由成对的尖括号和关键字组成，叫做标签。 关键字（标签名）：是已经规范过的，不是自己随便制造的。 例如：&lt;div&gt; , &lt;/h2&gt; , &lt;img/&gt; 标签属性 属性提供了这个元素的更多信息，语法：由属性名和属性值组成（键值对 key=”value”） 1234&lt;span style=&quot;font-family:宋体;&quot; title=&quot;标题&quot;&gt;span是标签名style是标签属性名&quot;font-family:宋体;标签属性值 一个标签可以由多个标签属性，每一个属性之间用空格隔开 标签的分类: 开始标签 &lt;div&gt; 结束标签 &lt;/div&gt; 自闭合标签(空标签) &lt;br/&gt; HTML元素 可以将元素理解成一个容器，容器中放置的就是 由标签和内容组成的，叫做元素。 &lt;div&gt;此处是内容&lt;/div&gt; 元素分类 由开始标签和结束标签组成的元素，可以进行嵌套（一个元素包着另一个元素），元素中可以添加内容，只有一个空标签，只能进行功能的添加，例如img元素 标签和元素是用来标记和描述内容的，所以这些标签和元素用户是看不到的，用户只能看到这个元素的内容。","categories":[],"tags":[{"name":"前端三层","slug":"前端三层","permalink":"http://yoursite.com/tags/前端三层/"}]},{"title":"markdown的简单使用","slug":"markdown的简单使用","date":"2017-06-30T06:18:07.000Z","updated":"2017-08-16T15:25:32.687Z","comments":true,"path":"2017/06/30/markdown的简单使用/","link":"","permalink":"http://yoursite.com/2017/06/30/markdown的简单使用/","excerpt":"","text":"#–&gt; 一级标题 相当于html中的h1标签 [TOC]–&gt;目录 ##–&gt; 二级标题 相当于html中的h2标签 ###–&gt; 三级标题 相当于html中的h3标签 ####–&gt; 四级标题 相当于html中的h4标签 #####–&gt; 五级标题 相当于html中的h5标签 ######–&gt; 六级标题 相当于html中的h6标签 在每个段落或标题结束后 增加一个回车（一行空白） 普通段落相当于html中的p标签 列表： -+空格（-列表-） -+空格+tab（二级列表） -+空格+tab+tab（三级列表） 如何缩进 –&gt; 点击tab键 编辑新的内容（英文状态下，按住shift+“—”） &gt; (大于号加空格)–&gt; 摘要或标注编辑表格:左边有冒号代表左对齐,右边有冒号代表右对齐,两边都有冒号代表居中 快捷键：ctrl+alt+T |标题|标题|标题| |:—-|—-:|:—-:| |左对齐|右对齐|居中| 例如: 标题 标题 标题 左对齐左对齐左对齐 右对齐右对齐右对齐 居中居中居中居中 内容 内容 内容 编辑代码块&lt;div&gt;div&lt;/div&gt;123&lt;div&gt;div&lt;/div&gt;&lt;div&gt;div&lt;/div&gt;&lt;div&gt;div&lt;/div&gt; 编辑行内代码:独立的行间代码 html中的p标签：&lt;p&gt; 插入图片 可以直接复制粘贴 快捷键：ctrl+G 插入链接： ctrl+L 保存笔记的方法: 点击【账号】选择【导出】 –&gt; 可以导出md格式，pdf格式，html格式 md格式：再次打开时，可以使用文本文档打开，将内容复制一份粘到markdown软件中 pdf格式：直接观看，但不能修改 html格式：可以浏览器中直接观看，可以在代码编辑器中修改 快捷键： 文档管理 –&gt; Ctrl+O 帮助 –&gt; Ctrl+/ 最大化编辑器 –&gt; Ctrl+Enter 预览文档 –&gt; Ctrl+Alt+Enter 同步文档 –&gt; Ctrl+S 创建文档 –&gt; Ctrl+Alt+N 系统菜单 –&gt; Ctrl+M 斜体 –&gt; Ctrl+I 粗体 –&gt; Ctrl+B","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]},{"title":"Nodejs的全局对象和全局变量","slug":"Nodejs的全局对象和全局变量","date":"2017-06-27T06:32:40.000Z","updated":"2017-08-16T15:28:38.300Z","comments":true,"path":"2017/06/27/Nodejs的全局对象和全局变量/","link":"","permalink":"http://yoursite.com/2017/06/27/Nodejs的全局对象和全局变量/","excerpt":"","text":"全局对象 所有模块都可以调用 global：表示Node所在的全局环境，类似于浏览器中的window对象。 你可以通过console.log(global);来输出一下global; 1-1. global全局对象里常用的变量 1). __dirname 存储的是在nodejs中执行javascript所在的绝对目录 12 console.log(__dirname);//C:\\Users\\Gao\\Documents\\webstore学习文件\\node 2). __filename 文件名 12console.log(__filename);//C:\\Users\\Gao\\Documents\\webstore学习文件\\node\\global.js process 程序所执行的一些相关的内容信息的封装对象 指向Node内置的process模块，允许开发者与当前进程互动。 例如你在DOS或终端窗口直接输入node，就会进入NODE的命令行方式（REPL环境）。如果要退出的话，可以输入 process.exit(); 2-1. 和输出相关的 process.stdout/process.stderr 1) process.stdout –&gt; standard output –&gt; 标准的信息输出 2) process.stderr –&gt; standard error –&gt; 标准的错误输出 console.info和console.error这些相关的输出功能就是调用的process.stdout和process.stderr来完成的12process.stdout.write(&quot;this is stdout&quot;);process.stderr.write(&quot;this is stderr&quot;);//红色的 2-2. process如何去监听一些事件 1) process.stdin.on() 监听用户输入的键盘信息 2)process.on()监听操作系统对node发出的一些信号 2-3. 如何读取输入用户的键盘输入 1).process.stdin 在使用process.stdin之前 要先对他进行一下编码设置```process.stdin.setEncoding(“utf-8”);//这里的编码设置和平常编写网页时候的文本编码不一样//在这里如果想读取纯文本信息 只要把他的编码设置成utf-8就可以了 不需要去考虑类似jbk或者jb2312来区分是不是中文//on方法来监听用户相关的输入事件// process.stdin.on(“data”,function (data) {// console.log(data);// });process.stdin.on(“readable”,function () { var data=process.stdin.read(); //回调函数没有参数 需要通过process.stdin.read来读取用户的键盘输入信息 console.log(data);}); //exit事件process.on(“exit”,function () { console.log(“programe will exit”);});//在程序正常退出的之前 会触发exit事件 //SIGINT –&gt; signal interrupted 信号 被中断//当一个信号被中断的时候就会触发SIGINT事件(cmd 中 ctrl+c会中断信号) process.on(“SIGINT”,function () {//会改变程序默认的退出行为 console.log(“programe has a sigint”); process.exit();//让程序正常退出}); console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。通常是写console.log();全局函数 定时器函数：共有4个，分别是setTimeout(), clearTimeout(), setInterval(), clearInterval()。 require：用于加载模块 全局变量： _filename：指向当前运行的脚本文件名。 _dirname：指向当前运行的脚本所在的目录 准全局变量 模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。 module变量指代当前模块。module.exports变量表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。 module.id 模块的识别符，通常是模块的文件名。 module.filename 模块的文件名。 module.loaded 返回一个布尔值，表示模块是否已经完成加载。 module.parent 返回使用该模块的模块。 module.children 返回一个数组，表示该模块要用到的其他模块。 这里需要特别指出的是，exports变量实际上是一个指向module.exports对象的链接，等同在每个模块头部，有一行这样的命令。var exports = module.exports; 这造成的结果是，在对外输出模块接口时，可以向exports对象添加方法，但是不能直接将exports变量指向一个函数：exports = function (x){ console.log(x);}; 上面这样的写法是无效的，因为它切断了exports与module.exports之间的链接。 如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。","categories":[],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://yoursite.com/tags/Nodejs/"}]},{"title":"caller和callee","slug":"JS中的caller和callee","date":"2017-06-26T10:02:17.000Z","updated":"2017-08-16T15:33:35.844Z","comments":true,"path":"2017/06/26/JS中的caller和callee/","link":"","permalink":"http://yoursite.com/2017/06/26/JS中的caller和callee/","excerpt":"","text":"caller 检验函数被谁调用过 检验函数被谁调用过 返回值是调用这个函数的函数本身,没有的话返回nullarguments.callee 函数本身12345678910function Fn() &#123; console.log(arguments.callee.caller);//--&gt;function fn() &#123;Fn()&#125; //--&gt;arguments.callee 函数本身 //caller:检验函数被谁调用过 返回值是调用这个函数的函数本身,没有的话返回null console.log(Fn.prototype.constructor === arguments.callee);//--&gt;true&#125;function fn() &#123; Fn()&#125;fn(); 12345678910function sum(n) &#123; console.log(arguments.callee===arguments.callee.caller); //-&gt;第一次输出false，因为第一次是函数自己执行，即自调用 自调用的时候console.log(arguments.callee.caller) 输出null 而此时arguments.callee 函数本身仍然是sun函数本身 所以输出false; // --&gt;当自调用执行完成后 arguments.callee===arguments.callee.caller===sum这个函数本身 ---&gt; 返回true if(n&lt;=0)&#123; return 0 &#125; return n+sum(--n);&#125;console.log(sum(10));//55","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"JS中的同步异步编程思想","slug":"JS中的同步异步编程思想","date":"2017-06-23T14:22:04.000Z","updated":"2017-08-16T15:33:43.772Z","comments":true,"path":"2017/06/23/JS中的同步异步编程思想/","link":"","permalink":"http://yoursite.com/2017/06/23/JS中的同步异步编程思想/","excerpt":"","text":"JS是单线程的-&gt;JS就是个傻子,脑子一根筋,做着当前的这件事情,没有完成之前,绝对不会做下一件是事情 JS中的两种编程思想:同步、异步 1、同步编程-&gt;上一件事情没有完成,继续处理上一件事情,只有上一件事情完成了,才会做下一件事情(JS中大部分都是同步编程的) 123456for (var i = 0; i &lt; 100000; i++) &#123; if (i == 99999) &#123; console.log(&quot;循环结束了~~&quot;);//-&gt;(1) &#125;&#125;console.log(&quot;ok&quot;);//-&gt;(2) 1) for循环就是同步编程的,只有循环结束后,才会继续执行下面的代码 1234while (1) &#123;&#125;console.log(&quot;ok&quot;);//-&gt;永远都不会执行的,因为上面的循环是死循环,循环永远都不会结束 2、异步-&gt;规划要做一件事情,但是不是当前立马去执行这件事情,需要等一定的时间,这样的话,我们不会等着它执行,而是继续执行下面的操作,”只有当下面的事情都处理完成了,才会返回头处理之前的事情;如果下面的事情并没有处理完成,不管之前的事情有没有到时间,都踏踏实实的给我等着” 在JS中异步编程只有四种情况: 1)定时器都是异步编程的 2)所有的事件绑定都是异步编程的 3)Ajax读取数据的时候,我们一般都设置为异步编程 4)回调函数也是异步编程的123456var n = 0;window.setTimeout(function () &#123; n++; console.log(n);//-&gt;1 (2)&#125;, 1000);console.log(n);//-&gt;0 (1) 3.定时器 1) 每一个浏览器对于定时器的等待时间都有一个最小的值,谷歌:5~6ms IE:10~13ms,如果设置的等待时间小于这个值,不起作用,还是需要等到最小时间才执行的;尤其是写0也不是立即执行; 1234567var n = 0;window.setTimeout(function () &#123; n++; console.log(n);//-&gt;1 (2)&#125;, 0);console.log(n);//-&gt;0 (1)//--&gt;先输出0 再输出1 2) 我们定时器设置的等待时间不一定就是最后执行的时间,如果定时器之后还有其他的事情正在处理中,不管定时器的时间有没有到,都是不会执行定时器的 12345678910111213141516171819202122 var n = 0; window.setTimeout(function () &#123; n++; console.log(n);//-&gt;不执行的 &#125;, 0); console.log(n);//-&gt;0 (1) while (1) &#123;//-&gt;死循环 n++; &#125;console.log(n);//-&gt;不执行 var n = 0; window.setTimeout(function () &#123; n += 2; console.log(n); //-&gt;7 (4) &#125;, 20); window.setTimeout(function () &#123; n += 5; console.log(n); //-&gt;5 (3) &#125;, 5); console.log(n);//-&gt;0 (1) for (var i = 0; i &lt; 10000000; i++) &#123;&#125; console.log(n);//-&gt;0 (2) 3)事件绑定 123456var oLis=document.getElementsByTagName(&quot;li&quot;); for(var i=0;i&lt;oLis.length;i++)&#123; oLis[i].onclick=function()&#123; tabChange(i); &#125; &#125;","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"IE版本条件注释语句(全)","slug":"IE版本条件注释语句-全","date":"2017-06-20T08:47:12.000Z","updated":"2017-08-16T15:23:13.694Z","comments":true,"path":"2017/06/20/IE版本条件注释语句-全/","link":"","permalink":"http://yoursite.com/2017/06/20/IE版本条件注释语句-全/","excerpt":"","text":"123&lt;!--[if lt IE 9]&gt;&lt;script charset=&quot;utf-8&quot; type=&quot;text/javascript&quot; src=&quot;js/html5.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 1、只有IE才能识别 123&lt;!--[if IE]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 因为只有IE5以上的版本才开始支持IE条件注释，所有“只有IE”才能识别的意思是“只有IE5版本以上”才能识别。 2、只有特定版本才能识别 123&lt;!--[if IE 8]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 识别特定的IE版本，高了或者低了都不可以。上例只有IE8才能识别。 3、只有不是特定版本的才能识别 123&lt;!--[if !IE 7]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 上例中特定IE7版本不能识别，其他版本都能识别，当然要在IE5以上。 4、只有高于特定版本才能识别 123&lt;!--[if gt IE 7]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 上例中只有高于IE7的版本才能识别。IE7无法识别。 5、等于或者高于特定版本才能识别 123&lt;!--[if gte IE 7]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 上例中IE7和更高的版本都能识别。 6、只有低于特定版本的才能识别 123&lt;!--[if lt IE 7]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 上例中只有低于IE7的版本才能识别，IE7无法识别。 7、等于或者低于特定版本的才能识别 123&lt;!--[if lte IE 7]&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;my.css&quot; /&gt;&lt;![endif]--&gt; 上例中IE7和更低的版本可以识别。 关键词解释 上面那些代码好像很难记的样子，其实只要稍微解释一下关键字就很容易记住了。 lt ：就是Less than的简写，也就是小于的意思。 lte ：就是Less than or equal to的简写，也就是小于或等于的意思。 gt ：就是Greater than的简写，也就是大于的意思。 gte：就是Greater than or equal to的简写，也就是大于或等于的意思。 !：就是不等于的意思，跟javascript里的不等于判断符相同。 特别提示： １、有人会试图使用&lt;!–[if !IE]&gt;来定义非IE浏览器下的状况，但注意：条件注释只有在IE浏览器下才能执行，这个代码在非IE浏览下被当做注释视而不见。 ２、我们通常用IE条件注释根据浏览器不同载入不同css，从而解决样式兼容性问题的。其实它可以做的更多。它可以保护任何代码块——HTML代码块、JavaScript代码块、服务器端代码……看看下面的代码。12345&lt;!--[if IE]&gt;&lt;script type=&quot;text/javascript&quot;&gt; alert(&quot;你使用的是IE浏览器！&quot;);&lt;/script&gt;&lt;![endif]--&gt; 12345678910111213141516171819202122232425262728293031323334353637&lt;!–[if !IE]&gt;&lt;!–&gt;&lt;!–&lt;![endif]–&gt;&lt;!–除IE外都可识别（IE10版本以上也可以识别）–&gt;&lt;!–[if IE]&gt;&lt;![endif]–&gt;&lt;!–IE9以及以下版本可识别–&gt;&lt;!–[if IE 5]&gt;&lt;![endif]–&gt;&lt;!–仅IE5可识别–&gt;&lt;!–[if IE 5.0]&gt;&lt;![endif]–&gt;&lt;!–仅IE5.0可识别–&gt;&lt;!–[if IE 5.5]&gt;&lt;![endif]–&gt;&lt;!–仅IE5.5可识别–&gt;&lt;!–[if IE 6]&gt;&lt;![endif]–&gt;&lt;!–仅IE6可识别–&gt;&lt;!–[if IE 7]&gt;&lt;![endif]–&gt;&lt;!–仅IE7可识别–&gt;&lt;!–[if IE 8]&gt;&lt;![endif]–&gt;&lt;!–仅IE8可识别–&gt;&lt;!–[if IE 9]&gt;&lt;![endif]–&gt;&lt;!–仅IE9可识别–&gt;&lt;!–[if lt IE 5]&gt;&lt;![endif]–&gt;&lt;!–IE5以下版本可识别–&gt;&lt;!–[if lt IE 5.0]&gt;&lt;![endif]–&gt;&lt;!–IE5.0以下版本可识别–&gt;&lt;!–[if lt IE 5.5]&gt;&lt;![endif]–&gt;&lt;!–IE5.5以下版本可识别–&gt;&lt;!–[if lt IE 6]&gt;&lt;![endif]–&gt;&lt;!–IE6以下版本可识别–&gt;&lt;!–[if lt IE 7]&gt;&lt;![endif]–&gt;&lt;!–IE7以下版本可识别–&gt;&lt;!–[if lt IE 8]&gt;&lt;![endif]–&gt;&lt;!–IE8以下版本可识别–&gt;&lt;!–[if lt IE 9]&gt;&lt;![endif]–&gt;&lt;!–IE9以下版本可识别–&gt;&lt;!–[if lte IE 5]&gt;&lt;![endif]–&gt;&lt;!–IE5以及IE5以下版本可识别–&gt;&lt;!–[if lte IE 5.0]&gt;&lt;![endif]–&gt;&lt;!–IE5.0以及IE5.0以下版本可识别–&gt;&lt;!–[if lte IE 5.5]&gt;&lt;![endif]–&gt;&lt;!–IE5.5以及IE5.5以下版本可识别–&gt;&lt;!–[if lte IE 6]&gt;&lt;![endif]–&gt;&lt;!–IE6以及IE6以下版本可识别–&gt;&lt;!–[if lte IE 7]&gt;&lt;![endif]–&gt;&lt;!–IE7以及IE7以下版本可识别–&gt;&lt;!–[if lte IE 8]&gt;&lt;![endif]–&gt;&lt;!–IE8以及IE8以下版本可识别–&gt;&lt;!–[if lte IE 9]&gt;&lt;![endif]–&gt;&lt;!–IE9以及IE9以下版本可识别–&gt;&lt;!–[if gt IE 5]&gt;&lt;![endif]–&gt;&lt;!–IE5以上版本可识别–&gt;&lt;!–[if gt IE 5.0]&gt;&lt;![endif]–&gt;&lt;!–IE5.0以上版本可识别–&gt;&lt;!–[if gt IE 5.5]&gt;&lt;![endif]–&gt;&lt;!–IE5.5以上版本可识别–&gt;&lt;!–[if gt IE 6]&gt;&lt;![endif]–&gt;&lt;!–IE6以上版本可识别–&gt;&lt;!–[if gt IE 7]&gt;&lt;![endif]–&gt;&lt;!–IE7以上版本可识别–&gt;&lt;!–[if gt IE 8]&gt;&lt;![endif]–&gt;&lt;!–IE8以上版本可识别–&gt;&lt;!–[if gt IE 9]&gt;&lt;![endif]–&gt;&lt;!–IE9以上版本可识别–&gt;&lt;!–[if gte IE 5]&gt;&lt;![endif]–&gt;&lt;!–IE5以及IE5以上版本可识别–&gt;&lt;!–[if gte IE 5.0]&gt;&lt;![endif]–&gt;&lt;!–IE5.0以及IE5.0以上版本可识别–&gt;&lt;!–[if gte IE 5.5]&gt;&lt;![endif]–&gt;&lt;!–IE5.5以及IE5.5以上版本可识别–&gt;&lt;!–[if gte IE 6]&gt;&lt;![endif]–&gt;&lt;!–IE6以及IE6以上版本可识别–&gt;&lt;!–[if gte IE 7]&gt;&lt;![endif]–&gt;&lt;!–IE7以及IE7以上版本可识别–&gt;&lt;!–[if gte IE 8]&gt;&lt;![endif]–&gt;&lt;!–IE8以及IE8以上版本可识别–&gt;&lt;!–[if gte IE 9]&gt;&lt;![endif]–&gt;&lt;!–IE9以及IE9以上版本可识别–&gt;","categories":[],"tags":[{"name":"IE版本条件注释语句(全)","slug":"IE版本条件注释语句-全","permalink":"http://yoursite.com/tags/IE版本条件注释语句-全/"}]},{"title":"网站如何发布","slug":"网站如何发布","date":"2017-06-20T06:58:34.000Z","updated":"2017-08-16T15:30:32.310Z","comments":true,"path":"2017/06/20/网站如何发布/","link":"","permalink":"http://yoursite.com/2017/06/20/网站如何发布/","excerpt":"","text":"客户端（浏览器） DNS服务器 域名解析服务器 www.baidu.com-&gt;61.135.169.121 网站如何发布?1.租一台服务器（阿里云服务器：主机/虚拟服务器） 给这个主机/服务器连接网络（连个网线），联网之后就会有个外网ip地址 （就是别人通过外网的ip可以找到我们的服务器，一般公司都会禁止外网IP访问） 例如，通过本地webstore打开本地的文件地址是 http://localhost:63342/webstore%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6/JS%E6%AD%A3%E5%BC%8F%E8%AF%BE/%E5%91%A8%E5%95%B8%E5%A4%A9%E8%AF%BE%E4%BB%B6/JavaScript201602-master/20160512_CSS3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/PPT/%E9%99%84%E4%BB%B6/2%E3%80%81%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7/1%E3%80%81%E4%BD%BF%E7%94%A8border-color%E5%88%B6%E4%BD%9C%E4%B8%89%E8%A7%92%E7%AC%A6%E5%8F%B7.html?_ijt=214ukq11e5l4bismdevhkenfhm localhost:本地文件地址 百度的服务器的外网IP：61.135.169.121 2.买一个域名（域名备案） 域名有哪些？ .cn / .com / .net / .org / .wang /.gov…… 3.将自己的项目放到服务器上 上传到服务器指定的磁盘上–&gt;FTP上传（上传工具FileZilla）4.发布项目（网站）一个服务区可以发布多个项目，每个项目各自占一个端口，每一个端口都有对应的端口号（每一个端口号都是唯一的，不能重复的），用端口号来进行区分项目–&gt;0~65535之间的任意一个数 1）发布网站的工具 IIS Apache nginx node 5.域名解析（DNS解析） 把购买的域名和服务器的IP地址关联到一起 以后只要提到域名 就关联的是这个服务器 DNS服务器：他是一台服务器 是属于全世界的万维网联盟，只要是地球上的域名解析都在他这里进行 www.baidu.com 61.135.169.121 www.jd.com 111.206.231.1 HTTP事物 请求Request阶段： 1.客户端通过域名访问，到DNS服务器上找到对应的外网IP地址 2.通过外网IP找到对应的项目服务器 3.通过端口号找到服务器上对应的项目，因为在发布项目的时候，就已经将项目文件和端口号对应了 响应response阶段： 4.服务器将客户端请求的资源文件的 源代码 返回给客户端 5.客户端（浏览器）进行解析文件 渲染页面 这两步组成了前后交互的模型/过程 “HTTP事物”–&gt;只有请求Request阶段 响应response阶段 都完成 才叫做HTTP事物 URI URI：统一资源标识符 URI=URL+URN URL：统一资源定位符 URN：统一资源名称 一个完整的URL –&gt; https://www.baidu.com:443/xxx/xxx.html?name=hh&amp;age=10#video https 传输协议 传输协议：HTTP / HTTPS / FTP 他是内容传输的媒介（快递公司） 客户端通过传输协议把一些信息传给服务器 同样 服务端也可以把一些信息返回给客户端 HTTP：超文本传输协议 除了传输文本之外 还可以传输其他的东西 比如图片 音频 视频（二进制流/base64） HTTPS:更安全的HTTP，因为他的传输通道加密了（SSL加密）（一般跟金钱 用户重要信息的网站都会采用HTTPS传输） FTP：一般都是将我们的项目文件传到服务器上，采用一些工具 例如上传工具FileZilla www.baidu.com 域名 一级域名 www.qq.com 一级域名 需要购买 ，二级域名、三级域名自己分配即可 二级域名 sport.qq.com 三级域名 kbs.sports.qq.com 443 端口号 取值范围 0-65535之间的一个数 HTTP的端口号:80 HTTPS的端口号:443 FTP的端口号:21 webstore 默认的端口号：63342 xxx/xxx.html 文件的目录–请求文件的路径和名称 表示的是在当前项目下xxx文件夹下的xxx.html /index.html 表示的是当前项目根目录下的index.html文件 ../index.html 表示的是当前项目上一级目录下的index.html文件 在不指定文件目录的时候 默认进入的是index.html（因为一般在发布项目的时候，会指定一个默认的入口文件 一般是index.html或者deflut.html） ?name=hh&amp;age=10 ?+参数 1）客户端可以通过 ?+参数 的方式给服务器传递一些信息 2）服务器不进行处理，例如之前做H5的时候 根据page=n，展示不同的区域 3）处理缓存的问题 传某个参数，但是这个参数服务器不需要 我们用它来做缓存处理 保证每次的URL都不一样 防止缓存 （例如ajax获取数据的拼接） #video 哈希值HASH 1） 客户端也可以通过这种方式给服务器传数据 （一般不用了） 2） 锚点定位 3） 通过哈希值HASH 实现页面路由的切换 6.客户端 浏览器 代码解析和页面的渲染 开发标准由W3C W3C：一个非盈利机构，他就是用来制定编程规范和标准的地方 按照浏览器的开发标准和规范开发出来的浏览器 都有一个东西叫引擎 也就是内核 我们前端工程师也要按照标准和规范去写代码 把符合标准的代码放到标准的浏览器中 通过引擎来渲染 IE内核（Trident引擎）：IE5-11，IE Edge，360，猎豹，百度 Gecko：火狐 webkit（V8引擎） 最快的 ： 谷歌 ，Safari，QQ Presto引擎：欧朋Opera","categories":[],"tags":[{"name":"网站如何发布","slug":"网站如何发布","permalink":"http://yoursite.com/tags/网站如何发布/"}]},{"title":"DOS基本命令大全","slug":"DOS基本命令大全","date":"2017-06-20T06:41:46.000Z","updated":"2017-08-16T15:22:38.239Z","comments":true,"path":"2017/06/20/DOS基本命令大全/","link":"","permalink":"http://yoursite.com/2017/06/20/DOS基本命令大全/","excerpt":"","text":"基本命令 1、列出文件 ls 参数 目录名 例: 看看驱动目录下有什么:ls /System/Library/Extensions 参数 -w 显示中文，-l 详细信息， -a 包括隐藏文件 2、转换目录 cd 例：想到驱动目录下溜达一圈 cd /System/Library/Extensions 3、建立新目录 mkdir 目录名 例：在驱动目录下建一个备份目录 backup mkdir /System/Library/Extensions/backup 在桌面上建一个备份目录 backup mkdir /User/用户名/Desktop/backup 4、拷贝文件 cp 参数 源文件 目标文件 例：想把桌面的Natit.kext 拷贝到驱动目录中 cp -R /User/用户名/Desktop/Natit.kext /System/Library/Extensions 参数R表示对目录进行递归操作，kext在图形界面下看起来是个文件，实际上是个文件夹。 把驱动目录下的所有文件备份到桌面backup cp -R /System/Library/Extensions/* /User/用户名/Desktop/backup 5、删除文件 rm 参数 文件 例：想删除驱动的缓存 rm -rf /System/Library/Extensions.kextcache rm -rf /System/Library/Extensions.mkext 参数－rf 表示递归和强制，千万要小心使用，如果执行了 rm -rf / 你的系统就全没了 6、移动文件 mv 文件 例：想把AppleHDA.Kext 移到桌面 mv /System/Library/Extensions/AppleHDA.kext /User/用户名/Desktop 想把AppleHDA.Kext 移到备份目录中 mv /System/Library/Extensions/AppleHDA.kext /System/Library/Extensions/backup 7、文本编辑 nano 文件名 例：编辑natit Info.plist nano /System/Library/Extensions/Natit.kext/Info.plist 目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la 文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename 选择操作 命令名 功能描述 使用举例 head 显示文件的最初几行 head -20 filename tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 diff 比较并显示两个文件的差异 diff file1 file2 sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142 时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.NET.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftpftp.sp.net.edu.cn rcp 在本地主机与远程主机 之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的 几条命令及编号 history r 重复执行最近执行过的 某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir df /tmp 显示文件系统的总空间和可用空间 w 显示当前系统活动的总信息","categories":[],"tags":[{"name":"DOS 基本命令","slug":"DOS-基本命令","permalink":"http://yoursite.com/tags/DOS-基本命令/"}]},{"title":"canvas动态案例","slug":"canvas动态案例","date":"2017-06-09T10:17:02.000Z","updated":"2017-08-16T15:20:59.492Z","comments":true,"path":"2017/06/09/canvas动态案例/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas动态案例/","excerpt":"","text":"12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;draw&quot; width=&quot;220&quot; height=&quot;320&quot; style=&quot;background-color: skyblue&quot;&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); var img=new Image; img.src=&apos;walkingdead.png&apos;;//添加图片地址 img.onload=function()&#123;//图片上有10张小图横着排列 var width=this.width/10; var height=this.height; var i=0; window.setInterval(function()&#123; cvs.clearRect(0,0,draw.width,draw.height);//清除上一个图片 cvs.drawImage(img,i*width,0,width,height,0,0,width,height); if(i==9)&#123; i=0 &#125;else&#123;i++;&#125; &#125;,200); &#125;&lt;/script&gt;","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"canvas之8图形组合","slug":"canvas之8图形组合","date":"2017-06-09T09:41:16.000Z","updated":"2017-08-16T15:20:59.467Z","comments":true,"path":"2017/06/09/canvas之8图形组合/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之8图形组合/","excerpt":"","text":"图形组合 cvs.globalCompositeOperation=type; type的值: 1.source-over 默认值 覆盖 在原来的图形上绘制新图 新图在上 2.source-out 显示新图的非交集部分 3.source-in 显示新图和图形的交集，颜色是新图的颜色 4.source-atop 显示旧图和交集部分 交集是新图颜色 5.destination-over 在原来图形的下面绘制新图 旧图在上 6.destination-out 显示旧图的非交集部分 7.destination-in 显示交集 颜色是旧图颜色 8.destination-atop 显示新图和交集部分 交集是旧图颜色 9.lighter:全部显示 交集部分是叠加颜色 10.xor:显示新旧图的非交集部分 11.copy 只显示新图 案例1:在原来的图形上绘制新图 新图在上 12345678910var draw=document.getElementById(&apos;draw&apos;);var cvs=draw.getContext(&apos;2d&apos;);function draw1()&#123; cvs.fillStyle=&apos;gold&apos;; cvs.fillRect(10,10,100,100); cvs.globalCompositeOperation=&apos;source-over&apos;; cvs.fillStyle=&apos;pink&apos;; cvs.fillRect(50,50,100,100);&#125;draw1();","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"canvas之7变形","slug":"canvas之7变形","date":"2017-06-09T09:19:54.000Z","updated":"2017-08-16T15:20:59.461Z","comments":true,"path":"2017/06/09/canvas之7变形/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之7变形/","excerpt":"","text":"平移translate(x,y);x:坐标原点向x轴平移的距离y:坐标原点向y轴平移的距离 案例 1234567891011121314function draw1()&#123; cvs.fillStyle=&apos;skyblue&apos;; //设置填充颜色天空蓝 cvs.fillRect(0,0,200,100); //矩形左上角坐标0,0 宽200px 高100px cvs.translate(50,50); //设置平移 坐标原点向x轴(向右)平移50px 坐标原点向y轴(向下)偏移50px //--&gt;这个平移只会对后面的矩形造成影响 不会影响前面的 cvs.fillStyle=&apos;pink&apos;; //设置填充颜色粉色 cvs.fillRect(0,0,180,80); //矩形左上角坐标0,0 宽180px 高80px&#125;draw1(); 缩放 vas.scale(x0,y0);x0:x轴按照x0的比例缩放y0:y轴按照x0的比例缩放 案例 12345678function draw2()&#123; cvs.scale(1,2);//设置缩放 x轴不变 y轴是之前的2倍 cvs.fillStyle=&apos;plum&apos;;//设置填充样式为颜色填充 cvs.fillRect(0,0,200,100); //矩形左上角坐标0,0 宽200px 高100px //--&gt;那么转化后的矩形宽200px 高200px&#125;draw2(); 3.旋转 vas.rotate(angle); angle:坐标轴转的角度 他是一个弧度(和画圆的计算是一样的) 案例 123456function draw3()&#123; cvs.rotate(Math.PI/4);//设置旋转 旋转角度为45度 cvs.fillStyle=&apos;lightblue&apos;; cvs.fillRect(100,100,200,100);&#125;draw3(); 注意：平移、缩放、旋转都是对原始坐标（画布）操作的 例如:1234567function draw3()&#123; cvs.translate(200,0);//此时的原点已经变到200,0的位置 cvs.rotate(Math.PI/4);//设置旋转 旋转角度为45度 cvs.fillStyle=&apos;lightblue&apos;; cvs.fillRect(100,100,200,100);&#125;draw3();","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"canvas之6绘制图片","slug":"canvas之6绘制图片","date":"2017-06-09T08:51:59.000Z","updated":"2017-08-16T15:20:59.474Z","comments":true,"path":"2017/06/09/canvas之6绘制图片/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之6绘制图片/","excerpt":"","text":"绘图 cvs.drawImage(Image,x,y,w,h); Image 就是可以放在DOM中的真实图片，可以动态创建，也可以获取页面上的 x,y 图片放入画布,在画布左上角的坐标 w,h 绘制图片的宽高 案例:将图片放在画布上 123456789function draw1()&#123; var img=new Image;//动态创建一个img img.src=&apos;default.gif&apos;;//添加图片链接 img.onload=function()&#123;//如果图片地址真实存在 执行这个函数 cvs.drawImage(this,0,100,100,90); //将图片放在画布上 图片左上角的坐标0,100 图片宽100px 高90px &#125;&#125;draw1(); cvs.drawImage(img_elem,sx,sy,sw,sh,dx,dy,dw,dh); sx,sy 图片左上角的坐标 sw,sh 矩形区域的宽高 用来截取图片 dx,dy 截取出来放在画布canvas上的坐标 dw,dh 画在canvas上的宽高 总结: sw,sy,sx,sy 是用来截取图片的过程 dx,dy,dw,dh 把截取出来的图片放在canvas上的过程 案例:截取图片 123456789 function draw2()&#123; var img=new Image;//动态创建一个img img.src=&apos;1.jpg&apos;;//添加图片链接 img.onload=function()&#123;//如果图片地址真实存在 执行这个函数 cvs.drawImage(this,480,150,440,410,0,0,200,200); //this就是img 将图片放在画布上 需要截取的图片在原图片左上角的坐标480,150 截取图片的大小为440px*410px 截取出来的图片放入画布的坐标0,0 截取出来的图片画在画布canvas的宽200px 高200px &#125; &#125;// draw2(); 设置平铺 cvs.creatPattern(image,type) Image 就是可以放在DOM中的真实图片，可以动态创建，也可以获取页面上的 type: no-repeat 不平铺 repeat 全方向平铺 repeat-x x轴方向平铺 repeat-y y轴方向平铺 案例 123456789101112function draw3()&#123; var img=new Image; img.src=&apos;default.gif&apos;; img.onload=function()&#123; var rep=cvs.createPattern(this,&apos;repeat&apos;);//设置图片平铺 cvs.fillStyle=rep;//设置填充样式为图片平铺 cvs.fillRect(0,0,draw.width,draw.height); //draw.width画布的宽 draw.height画布的高 //设置填充矩形 矩形左上角坐标0,0 矩形的宽为画布的宽 矩形的高为画布的高 &#125;&#125;//draw3();","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"canvas之4渐变","slug":"canvas之4渐变","date":"2017-06-09T06:56:44.000Z","updated":"2017-08-16T15:20:18.793Z","comments":true,"path":"2017/06/09/canvas之4渐变/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之4渐变/","excerpt":"","text":"1.线性渐变 var CLG=cvs.createLinearGradient(x0,y0,x1,y1); x0:渐变开始的x坐标 y0:渐变开始的y坐标 x1:渐变结束的x坐标 y1:渐变结束的y坐标 CLG.addColorStop(n,m); n:设置颜色的偏移量 m:颜色 例如: 12345678910111213function draw1()&#123; var CLG=cvs.createLinearGradient(0,0,200,200); //创建一个线性渐变 渐变开始的坐标0,0 渐变结束的坐标200,200 (即从左上角到右下角渐变) CLG.addColorStop(0,&apos;red&apos;);//设置渐变的偏移量0% 颜色红色 CLG.addColorStop(0.25,&apos;yellow&apos;);//设置渐变的偏移量25% 颜色黄色 CLG.addColorStop(0.5,&apos;skyblue&apos;);//设置渐变的偏移量50% 颜色天空蓝 CLG.addColorStop(0.75,&apos;orange&apos;);//设置渐变的偏移量75% 颜色橘黄 CLG.addColorStop(1,&apos;pink&apos;);//设置渐变的偏移量100% 颜色粉色 cvs.fillStyle=CLG;//设置填充样式是线性渐变 cvs.fillRect(0,0,200,200);//设置填充矩形 左上角坐标0,0 宽200px 高200px cvs.fill();//设置样式为填充样式&#125;draw1(); 2.径向渐变(发散性渐变) cvs.createRadialGradient(x0,y0,x1,y1,r1); x0:发散渐变开始中心的x坐标 y0：发散渐变开始中心的y坐标 r0:发散渐变开始的半径 x1:发散渐变结束中心的x坐标 y1：发散渐变结束中心的y坐标 r1:发散渐变结束的半径 例如:1234567891011121314function draw2()&#123; var CRG=cvs.createRadialGradient(200,200,200,200,200,10); //创建一个径向/发散性渐变 渐变开始的坐标200,200 渐变开始的半径200px 渐变结束的坐标200,200 渐变结束的半径10px CRG.addColorStop(0,&apos;purple&apos;); CRG.addColorStop(0.2,&apos;yellow&apos;); CRG.addColorStop(0.4,&apos;pink&apos;); CRG.addColorStop(0.6,&apos;lightblue&apos;); CRG.addColorStop(0.8,&apos;skyblue&apos;); CRG.addColorStop(1,&apos;white&apos;); cvs.fillStyle=CRG;//设置填充样式是径向渐变 cvs.fillRect(100,100,200,200); //设置填充矩形 左上角坐标100,100 宽200px 高200px&#125;draw2();","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"canvas之3绘制矩形","slug":"canvas之3绘制矩形","date":"2017-06-09T05:07:19.000Z","updated":"2017-08-16T15:20:14.808Z","comments":true,"path":"2017/06/09/canvas之3绘制矩形/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之3绘制矩形/","excerpt":"","text":"cvs.fillRect(x,y,w,h); –&gt; 填充矩形 x,y 是这个矩形左上角的坐标 w,h 是这个矩形的宽高 cvs.strokeRect(x,y,w,h); –&gt; 带边框的矩形 x,y 是这个矩形左上角的坐标 w,h 是这个矩形的宽高 注意:如果设置边框 边框一半在里面一半在外面 cvs.clearRect(x,y,w,h); –&gt; 清除填充图的某一部分，清除的还是一个矩形 x,y 是这个矩形左上角的坐标 w,h 是这个矩形的宽高案例 案例1 12345678910function draw1()&#123; //填充矩形 cvs.fillStyle=&apos;#fccdda&apos;;//画之前填充颜色 cvs.fillRect(10,20,100,50);//设置填充矩形,矩形的左上角坐标为10,20 宽100px 高50px //边框矩形 cvs.strokeStyle=&apos;red&apos;;//设置边框的矩形边框颜色 cvs.lineWidth=20;//设置边框宽度20px cvs.strokeRect(150,20,100,50);//设置边框矩形， 矩形的左上角坐标为150,20 宽100px 高50px&#125;draw1(); 案例2 12345678910111213function draw2()&#123;//清除填充图的某一部分，清除的还是一个矩形cvs.clearRect(x,y,w,h) cvs.fillStyle=&apos;orange&apos;; //画之前填充颜色 cvs.fillRect(20,100,300,100); //设置填充矩形,矩形左上角坐标为20,100 宽300px 高100px cvs.clearRect(140,140,60,60); //清除填充图的矩形 清除的这个矩形左上角坐标140,140 宽60px 高60px cvs.clearRect(20,100,40,40); //清除填充图的矩形 清除的这个矩形左上角坐标20,100 宽40px 高40px cvs.clearRect(280,100,40,40); //清除填充图的矩形 清除的这个矩形左上角坐标280,100 宽40px 高40px&#125;draw2();","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"canvas之5绘制文本","slug":"canvas之5绘制文本","date":"2017-06-09T04:55:35.000Z","updated":"2017-08-16T15:20:59.485Z","comments":true,"path":"2017/06/09/canvas之5绘制文本/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之5绘制文本/","excerpt":"","text":"1.阴影 cvs.shadowOffsetX//阴影的横向偏移量，默认值是0 cvs.shadowOffsetY//阴影的纵向偏移量，默认值是0 cvs.shadowColor//阴影的颜色 cvs.shadowBlur//阴影的模糊范围（值越大越模糊） 案例 123456789function draw1()&#123; cvs.shadowColor=&apos;#000fff&apos;;//设置阴影颜色 cvs.shadowOffsetX=30;//设置阴影的横向偏移量30px cvs.shadowOffsetY=20;//设置阴影的纵向偏移量20px cvs.shadowBlur=20;//设置阴影的模糊范围20px cvs.fillStyle=&apos;#449fdb&apos;;//设置填充的样式为颜色填充 cvs.fillRect(50,50,100,100);//设置填充矩形 左上角坐标50,50 宽100px 高100px&#125;draw1(); 2.绘制文本 设置字体样式 cvs.font=’字体大小font-size 字体样式font-family’ 水平对齐方式 cvs.textAlign(start,end,right,center); 垂直对齐方式 cvs.textBaseline=’’ 属性值:top,middle,hangle,bottom,alphabetic,ideographic 计算文本长度 var text=’dfbzbh’ console.log(cvs.measureText(text));//width:40.453125 填充文字 cvs.fillText(text,x,y,maxWidth); 1) text:文本内容 2) x:文字起始点的横坐标 3) y:文字起始点的纵坐标 绘制文字轮廓 cvs.strokeText(text,x,y,maxWidth); 1) text:文本内容 2) x:文字起始点的横坐标 3) y:文字起始点的纵坐标 案例1 12345678910function draw1()&#123; cvs.shadowColor=&apos;#000fff&apos;;//设置阴影颜色 cvs.shadowOffsetX=30;//设置阴影的横向偏移量30px cvs.shadowOffsetY=20;//设置阴影的纵向偏移量20px cvs.shadowBlur=20;//设置阴影的模糊范围20px cvs.fillStyle=&apos;#449fdb&apos;;//设置填充的样式为颜色填充 cvs.fillRect(50,50,100,100); //设置填充矩形 左上角坐标50,50 宽100px 高100px &#125; draw1(); 案例2 1234567891011121314151617function draw2()&#123; var text=&apos;hellow word&apos;;//设置文本内容 cvs.fillStyle=&apos;yellow&apos;;//设置填充样式颜色 cvs.font=&apos;40px verdana&apos;;//设置字体样式 cvs.textAlign=&apos;start&apos;;//设置字体的水平对齐方式 cvs.textBaseline=&apos;top&apos;;//设置字体的垂直对齐方式 cvs.fillText(text,10,10); //设置填充文字 文本内容text 文本起始点坐标10,10 var length=cvs.measureText(text); //获取文本宽度(长度)length console.dir(length); //TextMetrics--&gt;width:241.171875 //==&gt;length.width字体的宽度 cvs.fillText(&quot;字体长度为&quot;+length.width,10,60); //设置填充文字(通过字符串拼接方式) 文本起始点坐标10,60&#125;draw2(); 案例3:文本线性渐变 123456789101112131415161718192021222324function draw3()&#123; var CLG=cvs.createLinearGradient(0,0,300,100); //创建一个线性渐变 渐变开始的坐标0,0 渐变结束的坐标300,100 CLG.addColorStop(0,&apos;skyblue&apos;);//设置渐变的偏移量0% 天空蓝 CLG.addColorStop(0.25,&apos;plum&apos;);//设置渐变的偏移量25% 紫色 CLG.addColorStop(0.5,&apos;lightblue&apos;);//设置渐变的偏移量50% 蓝 CLG.addColorStop(0.75,&apos;skyblue&apos;);//设置渐变的偏移量75% 天空蓝 CLG.addColorStop(1,&apos;plum&apos;);//设置渐变的偏移量100% 紫色 var text=&apos;hellow word&apos;;//设置文本内容 cvs.fillStyle=CLG;//设置填充样式是线性渐变 cvs.shadowOffsetX=5;//设置阴影的横向偏移量5px cvs.shadowOffsetY=4;//设置阴影的纵向偏移量4px cvs.shadowColor=&apos;#ffb6c1&apos;;//设置阴影的颜色 cvs.shadowBlur=5;//设置阴影的模糊度 cvs.font=&apos;40px cursive&apos;;//设置字体样式 cvs.textAlign=&apos;top&apos;;//设置字体的水平对齐方式 cvs.fillText(text,50,150); //设置填充文字text 文本起始点坐标50,150 var width=cvs.measureText(text).width;//获取文本宽度(长度)length cvs.fillText(&quot;字体长度为：&quot;+width,10,200); //设置填充文字(通过字符串拼接方式) 文本起始点坐标10,200 &#125; draw3(); 案例4:文本径向渐变 123456789101112131415161718function draw4()&#123; var CRG=cvs.createLinearGradient(0,0,600,0,0,20); //创建一个径向渐变 渐变开始的坐标0,0 开始渐变的半径600px 渐变结束的坐标0,0 渐变结束的半径20px CRG.addColorStop(0,&apos;pink&apos;); CRG.addColorStop(0.25,&apos;skyblue&apos;); CRG.addColorStop(0.5,&apos;yellow&apos;); CRG.addColorStop(0.75,&apos;plum&apos;); CRG.addColorStop(1,&apos;skyblue&apos;); var text=&apos;I WANT EAT&apos;; cvs.fillStyle=CRG;//设置填充样式是径向渐变 cvs.font=&apos;80px simsun&apos;;//设置字体样式 cvs.textAlign=&apos;start&apos;;//设置文本横向对齐方式 cvs.textBaseline=&apos;top&apos;;//设置文本纵向对齐方式 cvs.shadowColor=&apos;lightblue&apos;;//设置阴影颜色 cvs.shadowBlur=10;//设置阴影的模糊范围10px cvs.fillText(text,10,10);//设置填充文字text 文本起始点坐标10,10&#125;draw4();","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"服务器及相关知识","slug":"服务器及相关知识","date":"2017-06-09T03:38:02.000Z","updated":"2017-08-16T15:29:06.698Z","comments":true,"path":"2017/06/09/服务器及相关知识/","link":"","permalink":"http://yoursite.com/2017/06/09/服务器及相关知识/","excerpt":"","text":"服务器 是具有储存功能的计算机设备（笔记本电脑本身就是一个服务器）服务器根据功能分类： web服务器：供用户访问的 安全系数相对较低 数据库服务器：放在内网的服务器，用来安装数据库 应用服务器：放在内网的服务器，用来安装应用（产品） 操作系统有关 可视操作：可以直观看到所有文件，可以直接操作这些文件（window） 不可视操作：不能直观看到所有文件，需要ssh，ftp这样的工具进行连接（或者是敲命令进行） 大型机与嵌入式系统使用很多样化的操作系统。 在服务器方面Linux、UNIX和WindowsServer占据了市场的大部分份额。在超级计算机方面，Linux取代Unix成为了第一大操作系统，截止2012年6月，世界超级计算机500强排名中基于Linux的超级计算机占据了462个席位，比率高达92%。随着智能手机的发展，Android和iOS已经成为目前最流行的两大手机操作系统。 内外网： 内网：数据库 ，产品应用——可供用户观看的页面 外网：web服务器，web服务器（多个相同的web服务器，负载均衡）——可供用户访问的 vpn(翻墙软件)负载均衡：内外网的连接工具","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"}]},{"title":"canvas之2画圆","slug":"canvas之2画圆","date":"2017-06-08T11:56:51.000Z","updated":"2017-08-16T15:19:55.149Z","comments":true,"path":"2017/06/08/canvas之2画圆/","link":"","permalink":"http://yoursite.com/2017/06/08/canvas之2画圆/","excerpt":"","text":"cvs.arc(x,y,radius,startAngle,endAngle,anticlokwise); x,y 圆心坐标 radius半径r startAngle 起始角 以弧度计算(钟表的3点钟方向是0度,也就是x轴的正方向是0度,默认是顺时针) endAngle 结束角 anticlokwise 是否逆时针 默认值false false表示顺时针 案例 案例1:边框半圆 123456789function draw1()&#123;//边框圆 cvs.strokeStyle=&apos;#ffa50&apos;;//设置笔触样式(边框样式)颜色 cvs.beginPath();//开始一个路径 cvs.arc(500,500,100,0,Math.PI);//圆心坐标是500,500，半径是100px，起始角为0度，结束角为180度 cvs.closePath();//结束路径 cvs.lineWidth=10;//边框宽度为10px cvs.stroke();//绘制图形以边框样式绘制&#125;draw1(); 案例2:同心圆 12345678910111213141516171819202122function draw2()&#123; cvs.fillStyle=&apos;orange&apos;; cvs.beginPath(); //开始一个新的路径 cvs.arc(200,200,60,Math.PI/2,2*Math.PI); //圆心坐标是(200,200),半径为60px,起始角为90度,结束角为360度 cvs.closePath(); //结束一个路径 cvs.fill(); //绘制图形以填充样式绘制 cvs.strokeStyle=&apos;yellow&apos;; //设置 笔触样式(边框样式) 为黄色 cvs.lineWidth=40; //边框的宽度为40px cvs.beginPath(); //开始一个新的路径 cvs.arc(200,200,80,0,2*Math.PI); //圆心坐标是(200,200),半径为80px,起始角度为0度,结束角度为360度 cvs.closePath();//结束一个路径 cvs.stroke();//绘制图形以边框样式绘制&#125;draw2(); 案例3:每次调用fill绘制填充图的时候，会把当次路径的起始点和结束点分别连接，填充闭合部分(如果想让每个路径互不干扰 一定要记得写结束路径–&gt;关闭路径) 12345678910111213function draw3()&#123; cvs.strokeStyle=&apos;pink&apos;;//设置笔触样式(边框样式)颜色为粉色 cvs.beginPath();//开始一个路径 cvs.lineWidth=2;//边框的宽度为2px cvs.arc(100,100,100,0,Math.PI);//圆心坐标是100,100,半径为100,起始角度为0度,结束角度为180度 cvs.closePath();//结束一个路径 cvs.stroke();//绘制图形以边框样式绘制 cvs.fillStyle=&apos;gray&apos;;//设置填充颜色为灰色 cvs.arc(300,300,80,0,Math.PI/2);//圆心坐标是300,300，半径是80px，起始角度为0，结束角度为90度 cvs.closePath(); cvs.fill();&#125;draw3();","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"canvas之1绘制线条的有关属性和步骤","slug":"canvas之1绘制线条的有关属性和步骤","date":"2017-06-08T11:44:17.000Z","updated":"2017-08-16T15:20:08.107Z","comments":true,"path":"2017/06/08/canvas之1绘制线条的有关属性和步骤/","link":"","permalink":"http://yoursite.com/2017/06/08/canvas之1绘制线条的有关属性和步骤/","excerpt":"","text":"&lt;canvas id=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt;&lt;/canvas&gt;canvas :H5标签 在页面上绘制图形用的（通常称他画布）canvas只是一个容器，我们用js脚本来控制他&lt;canvas id=&quot;draw&quot; width=&quot;600&quot; height=&quot;500&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; 绘制线条的有关属性和步骤 1.相关属性 1.填充的样式 cvs.fillStyle --&gt;fillStyle`填充样式 cvs.strokeStyle --&gt;strokeStyle笔触样式 主要用来画边框的 cvs.lineWidth --&gt; 边框的宽度 2.绘制图形有两种方式 cvs.fill(); --&gt; 填充样式 cvs.stroke(); --&gt; 边框样式 3.颜色值的四种书写方式 1).颜色名 –&gt;”red” 2).十六进制 –&gt;”#fff” 3).三色值 –&gt;rgb(0,0,0) 4).四色值 –&gt;rgba(0,0,0,0.3) 4.坐标: 1.)以画布为基准,距离画布的上边是y坐标值(top值),距离画布的左边是x坐标值(left值); cvs.moveTo(x,y); –&gt; 起始点坐标 cvs.lineTo(x,y); –&gt; 结束点的坐标 如果没有moveTo就把上一个挨着的lineTo作为起始坐标 例如:假如第一个不是moveTo而是lineTo,那么lineTo就是其实坐标 5.开始和关闭一个路径 cvs.beginPath(); –&gt; 开始一个新的路径 cvs.closePath(); –&gt; 关闭当前路径 注意:加上.closePath会自动闭合 会自动连接起始坐标和结束坐标 6.canvas中的圆角 1).设置线条交汇处的样式 cvs.lineJoin 他有三个属性： 1).尖角miter 2).斜角bevel 3).圆角round 2).设置一条线段两端点的样式 lineCap焦点样式 1)平的butt(默认值) 2.)圆角round 3.)方角square 2.步骤及案例 步骤1.获取出canvas标签,例如:var draw=document.getElementById(&#39;draw&#39;); 步骤2.设置绘制环境–2d 平面图,例如: 12var cvs=draw.getContext(&apos;2d&apos;);//cvs 这个就是你的画板 接下来就可以在cvs上进行绘制 步骤3 案例1:线段 123456789101112function draw1()&#123;var draw=document.getElementById(&apos;draw&apos;);var cvs=draw.getContext(&apos;2d&apos;);cvs.beginPath();cvs.moveTo(50,50);cvs.lineTo(150,50);cvs.closePath();cvs.strokeStyle=&apos;#800080&apos;;cvs.lineWidth=5;cvs.stroke();//以边框的形式显示&#125;draw1(); 案例2:等腰直角三角形 12345678910111213function draw2()&#123; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); cvs.beginPath(); cvs.lineTo(80,120); cvs.lineTo(80,240); cvs.lineTo(200,240); cvs.closePath(); cvs.strokeStyle=&apos;ec568c&apos;; cvs.lineWidth=10; cvs.stroke();&#125;draw2(); 案例3:圆角矩形 12345678910111213function draw3()&#123; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); cvs.beginPath(); cvs.lineCap=&apos;round&apos;; cvs.lineTo(50,50); cvs.lineTo(250,50); cvs.closePath();//关闭就没有圆角效果 cvs.lineWidth=100; cvs.strokeStyle=&apos;#896446&apos;; cvs.stroke();&#125;draw3(); 案例4:圆角三角形 1234567891011121314function draw4()&#123; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); cvs.beginPath(); cvs.lineJoin=&apos;round&apos;;//设置圆角 cvs.moveTo(200,100); cvs.lineTo(100,250); cvs.lineTo(300,250); cvs.closePath(); cvs.lineWidth=50; cvs.strokeStyle=&apos;#896446&apos;; cvs.stroke();&#125;draw4();","categories":[],"tags":[{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"字符串中的几个重要方法","slug":"JS字符串中的几个重要方法","date":"2017-06-02T12:03:49.000Z","updated":"2017-08-16T15:25:32.698Z","comments":true,"path":"2017/06/02/JS字符串中的几个重要方法/","link":"","permalink":"http://yoursite.com/2017/06/02/JS字符串中的几个重要方法/","excerpt":"","text":"1.通过索引查找字符串1) charAt(索引) 字符串上的charAt方法里边传索引值，进行搜索指定索引位置的字符，还是字符串格式;原字符串不变2) charCodeAt（索引） 返回结果对应的是ASCII码;原字符串不变例如:12345var str = &apos;addias&apos;;console.log(str.charAt(0),str);//&quot;a&quot; &quot;addias&quot; 原字符串不变console.log(str.charCodeAt(0),str);//97 &quot;addias&quot; 原字符串不变 2.检取字符串 substr(n,m); 从索引n开始截取m个 返回值为截取的字符串 原有字符串不变12var str = &apos;addias&apos;;console.log(str.substr(1, 2),str);//&quot;dd&quot; &quot;addias&quot; 1). str.substr();// 复制字符串 2). str.substr(0);// 复制字符串12345var str = &apos;addias&apos;;console.log(str.substr(),str);//&quot;addias&quot; &quot;addias&quot; 复制字符串console.log(str.substr(0),str);//&quot;addias&quot; &quot;addias&quot; 复制字符串 subString(n,m) 从索引n找到索引m之前，不包含m处;原字符串不变123var str = &apos;addias&apos;;console.log(str.substring(3, 4),str);//&quot;i&quot; &quot;addias&quot; substring(0); 克隆字符串 substring(); 克隆字符串12345var str = &apos;addias&apos;;console.log(str.substring(0),str);//&quot;addias&quot; &quot;addias&quot;console.log(str.substring(),str);//&quot;addias&quot; &quot;addias&quot; slice 字符串也可以使用slice1234var str = &apos;addias&apos;;console.log(str.slice(-1+str.length));//sconsole.log(str.slice(-1)); //s 同数组的使用方法一样console.log(str.slice(-2)); //as 同数组的使用方法一样 4.indexOf();字符串中当前字符出现的第一个索引;lastIndexOf();字符串中当前字符出现的最后一个索引;123var str = &apos;addias&apos;;console.log(str.indexOf(&apos;f&apos;));//-1console.log(str.lastIndexOf(&apos;a&apos;));//4 5.toUpperCase();字符串转化成大写;toLowerCase();字符串转化成小写123456var str = &apos;addias&apos;;console.log(str.toUpperCase(), str);// &quot;ADDIAS&quot; &quot;addias&quot; 字符串转化成大写var str = &apos;ADDIAS&apos;;console.log(str.toLowerCase(), str);//&quot;addias&quot; &quot;ADDIAS&quot; 字符串转化成小写 6.replace 替换字符串中的字符;原字符串不变1234var str1 = &apos;珠,峰,珠,训&apos;;var str2 = &apos;sdasdasdasdasd&apos;;console.log(str1.replace(&apos;珠&apos;, &apos;zhu&apos;), str1);//&quot;zhu,峰,珠,训&quot; &quot;珠,峰,珠,训&quot; 6.split 将字符串拆分成数组;将字符串以字符串中存在的指定分隔符拆分成数组12345678910var str1 = &apos;珠,峰,珠,训&apos;;var str2 = &apos;sdasdasdasdasd&apos;;console.log(str2.split(&apos;a&apos;));//(5) [&quot;sd&quot;, &quot;sd&quot;, &quot;sd&quot;, &quot;sd&quot;, &quot;sd&quot;]console.log(str2.split());//[&quot;sdasdasdasdasd&quot;]console.log(str1.split(&apos;,&apos;));//[&quot;珠&quot;, &quot;峰&quot;, &quot;珠&quot;, &quot;训&quot;]console.log(str1.split(&apos;&apos;));//[&quot;珠&quot;, &quot;,&quot;, &quot;峰&quot;, &quot;,&quot;, &quot;珠&quot;, &quot;,&quot;, &quot;训&quot;]","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"JS中的作用域","slug":"JS中的作用域","date":"2017-04-29T04:27:46.000Z","updated":"2017-08-16T15:24:43.919Z","comments":true,"path":"2017/04/29/JS中的作用域/","link":"","permalink":"http://yoursite.com/2017/04/29/JS中的作用域/","excerpt":"","text":"内存1.堆内存：来存储东西的，一般来存储引用数据类型2.栈内存：代码执行空间，作用域作用域两种：全局作用域：一打开浏览器就会形成私有作用域：函数执行形成的作用域函数执行的时候1.函数一执行，形成一个私有作用域2.有形参数的话给形参数赋值，相当于var 一个变量，function s(a){},s(1)-&gt;var a=1;3.预解释4.代码执行私有变量：1.形参2.在私有作用域中声明的变量，var过和function过得记住：私有变量只能私有作用域自己使用，别人获取不到 闭包：函数执行的时候形参一个私有作用域，来保护里面的私有变量不受外界干扰，这种机制叫做闭包","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"JS中的预解释","slug":"JS中的预解释","date":"2017-04-29T02:29:55.000Z","updated":"2017-08-16T15:33:48.719Z","comments":true,"path":"2017/04/29/JS中的预解释/","link":"","permalink":"http://yoursite.com/2017/04/29/JS中的预解释/","excerpt":"","text":"预解释的基础知识 例子 1234567console.log(d);//--&gt;function d()&#123;&#125;;d=1;//--&gt;d=1s=d;//--&gt;s=1function d()&#123;//--&gt;xxxfff000&#125;d();//--&gt;d is not a function 1.预解释: 是一个过程，作用域形成之后，代码执行之前，把所有带var关键字和function提前声明或定义 2.作用域： 1). 全局作用域：window下，一打开浏览器就会形成 2). 私有作用域：一个函数就是一个私有作用域，函数一执行就会形成私有作用域 3.声明: 告诉浏览器这里有个变量，var关键字的只有声明 4.定义: 赋值过程，在预解释的时候function即声明还定义 5.注意: 预解释的时候遇到变量已经声明过了就不用声明了，但是需要重新定义,例如:1234567891011//变量只声明未定义就是undefinedconsole.log(obj1);//--&gt;undefinedvar obj1=&#123;name:&quot;111&quot;&#125;;console.log(fn);function fn() &#123;&#125;//1.全局作用形成//2.全局作用域下的预解释：var obj1，function fn=xxxfff000//3.代码执行：// 1.console.log(obj1);--&gt;undefined// 2.obj1=xxxfff111// 3. console.log(fn);--&gt;function fn() &#123;&#125; 预解释的几种特殊情况 注意: 全局作用域下的变量就是window的一个属性 1.=右边函数不进行预解释（函数作为值的时候\\绑定事件的时候 不进行预解释）123var ff=function () &#123; console.log(1);&#125;; 2.return 后面的代码不行行但是需要预解释，return出的内容执行但是不进行预解释123456789101112function fn() &#123; var a=0; console.log(f);//function f()&#123;&#125; return function () &#123; console.log(1); return 1 &#125;; function f() &#123;&#125;&#125;var d=fn();console.log(d());fn()(); 3.在条件语句中 1)不管条件是否成立都进行预解释 1234567console.log(num);if (0)&#123; //虽然条件不成立 但是需要预解释 var num=0&#125;ss=0;//-&gt;window.ss=0console.log(&quot;ss&quot; in window); 2)条件中有函数function 在条件中的var和function只声明不定义，声明的时候当遇到变量已经被声明了，就会报错 1234if(&apos;a&apos; in window)&#123;var a=1;function()&#123;&#125;;//--&gt;&apos;a&apos; has already been declared&#125; 条件一旦成立，首先给函数赋值 123456789101112console.log(a);if (&quot;a&quot; in window)&#123; console.log(a); a=1; function a() &#123;&#125; console.log(a);&#125;//预解释：function a --&gt;就相当于给window增加一个“a”属性//&quot;a&quot; in window 就是true//条件成立第一步先给function a赋值=xxxfff000//代码执行：console.log(a);xxxfff000-&gt;function a() &#123;&#125;// a=1,重新给a赋值 4.自执行函数 不进行预解释1234//console.log(sss);(function sss() &#123; console.log(&quot;a&quot;)&#125;)(); 5.函数作为参数的时候不进行预解释123[1,2,3].sort(function(a,b)&#123;return a-b;&#125;); 6.预解释的时候遇到已经声明过得变量不需要声明了，但是需要定义12345678var s1=1;function s1() &#123;//s1=xxxfff000 console.log(&quot;s1&quot;)&#125;function s1() &#123;//s1=xxxfff111 console.log(&quot;s11&quot;)&#125;console.log(s1);","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"自定义属性和引用数据类型的赋值","slug":"JS自定义属性和引用数据类型的赋值","date":"2017-04-29T02:19:20.000Z","updated":"2017-08-16T15:25:32.703Z","comments":true,"path":"2017/04/29/JS自定义属性和引用数据类型的赋值/","link":"","permalink":"http://yoursite.com/2017/04/29/JS自定义属性和引用数据类型的赋值/","excerpt":"","text":"自定义属性:- 一般都是给某些元素增加一个自己起的属性名（不能是内置属性），来存储一些值的比如说我们在选项卡中用自定义属性来存储他的索引值，不用全局变量的好处：只有自己可以修改 元素.自定义属性名=值 只要是引用数据类型都可以加自定义属性 特别注意：函数也可以加 对于引用数据类型: 对象: 浏览器先看是什么数据类型的，是对象的话，浏览器给对象开辟一个堆内存 把所有的键值对（属性名：属性值）放到这个堆内存里，如果属性值遇到变量名，是把变量代表的值存起来 把这个地址赋给对象 函数 浏览器检测他是什么数据类型，是函数的话就给他开辟一个堆内存 将函数当做字符串存起来 将地址赋给函数名","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"基于GitHub创建自己hexo的博客","slug":"基于GitHub创建自己的博客","date":"2017-04-25T10:52:52.000Z","updated":"2017-07-31T17:05:06.262Z","comments":true,"path":"2017/04/25/基于GitHub创建自己的博客/","link":"","permalink":"http://yoursite.com/2017/04/25/基于GitHub创建自己的博客/","excerpt":"","text":"搭建环境准备 Node.js 的安装和准备 Git的安装和准备 gitHub账户的配置 Node.js 的安装和准备 1.下载node.js安装文件：https://nodejs.org/en/ 2.cmd，打开命令行界面,查看安装版本 12nede -vnpm -v 配置Git环境 下载Git安装文件：https://git-scm.com/downloads 打开命令行输入,检查安装是否成功 1git --version github账户的注册和配置 Github注册：https://github.com/ 创建代码库： 在Repository name下填写yourname.github.io，Description (optional)下填写一些简单的描述（不写也没有关系 123注意：比如我的github名称是gaodaxiu0406 ,这里你就填 gaodaxiu0406.github.io 代码库设置:Setting 接下来开启gh-pages功能，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages 点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面 安装Hexo 首先在E盘(选择你的HEXO存放的文件夹,最好不要安装到C盘)目录下创建Hexo文件夹，并在命令行的窗口进入到该目录 12E: 进入E盘cd Hexo 进入Hexo文件夹 安装HEXO 1npm install hexo-cli -g 可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。 然后输入 保存hexo1npm install hexo --save 检查安装是否成功1hexo -v hexo的相关配置初始化Hexo12hexo initnpm install 首次体验Hexo12hexo g #生成hexo s #启动服务 在浏览器中打开http://localhost:4000/ 即可预览你的HEXO页面 怎样将Hexo与github page 联系起来大概分为以下几步: 配置git个人信息 配置Deployment 配置Git个人信息 1.设置Git的user name和email：(如果是第一次的话) 12git config --global user.name &quot;gaodaxiu0406&quot;git config --global user.email &quot;gaodaxiu0406@qq.com&quot; 2.检查是否已经有SSH Key(密钥)。 12cd ~/.sshls 3.生成密钥(如果没有密钥的话) 1ssh-keygen -t rsa -C &quot;mengqian1117@163.com&quot; 123连续3个回车。如果不需要密码的话。最后得到了两个文件：id_rsa和id_rsa.pub。默认的存储路径是：C:\\Users\\Administrator\\.ssh 4.添加密钥到ssh-agent 1eval &quot;$(ssh-agent -s)&quot; 添加生成的 SSH key 到 ssh-agent。 1ssh-add ~/.ssh/id_rsa 5.登陆Github, 添加 ssh 把id_rsa.pub文件里的内容复制到SSH keys 6.测试： 1ssh -T git@github.com 你将会看到：如果看到Hi后面是你的用户名，就说明成功了。 1如果提示Are you sure you want to continue connecting (yes/no)?，输入yes 配置Deployment 配置_config.yml中有关deploy的部分： 1234deploy:type: gitrepository: git@github.com:gaodaxiu0406/gaodaxiu0406.github.io.gitbranch: master 写博客、发布文章 1.定位到我们的hexo根目录，执行命令： 1hexo new &apos;my-first-blog&apos; hexo会帮我们在HEXO文件夹–&gt;source文件夹–&gt;_posts文件夹下生成相关.md文件,用马克飞象打开写文章就可以 文章编辑好之后，运行生成、部署命令： 12hexo g // 生成hexo d // 部署 或者(合并写法) 1hexo d -g #在部署前先生成 踩坑提醒1deloyer not found:git 这样的错误是需要装插件 1npm install hexo-deployer-git --save 下篇:HEXO主题设置https://gaodaxiu0406.github.io/2017/07/31/HEXO%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/","categories":[],"tags":[{"name":"基于GitHub创建自己的hexo博客","slug":"基于GitHub创建自己的hexo博客","permalink":"http://yoursite.com/tags/基于GitHub创建自己的hexo博客/"}]},{"title":"数组中的方法","slug":"JS数组中的方法","date":"2017-04-25T09:12:39.000Z","updated":"2017-08-16T15:25:32.710Z","comments":true,"path":"2017/04/25/JS数组中的方法/","link":"","permalink":"http://yoursite.com/2017/04/25/JS数组中的方法/","excerpt":"","text":"数组中的方法 1.给数组添加值 1). push();向数组末尾增加n项 参数:想向数组末尾增加的内容,可以传递多个值,统一向数组末尾增加n向 返回值:新增后数组的长度 原数组:改变123var ary=[12,23,34,45]; ary.push(56); console.log(ary);//--&gt;[12,23,34,45,56] 2). unshift();向数组开头增加n项 参数:想向数组开头增加的内容,可以传递多个值,统一向数组开头增加n向 返回值:新增后数组的长度 原数组:改变 扩展:向数组末尾增加 a). splice(a.length,0,x);向末尾增加,可增加多项 2.删除数组中的项 1). pop();删除数组最后一项内容 参数:没有 返回值:被删除的那一项内容 原数组:改变 2). shift();删除数组中的第一项 参数:没有 返回值:被删除的那一项内容 原数组:改变 扩展:删除数组最后一项内容的方法 a) pop();删除数组最后一项内容 b) ary.length–; c) ary.splice(ary.length-1); 3.数组中的截取和拼接 1).slice 实现数组的截取，在原来的数组中截取某一部分 a). slice(n,m); a1). n&gt;=m 返回空数组 a2). n&lt;0,m&lt;0,n&lt;m 从索引m开始找到索引为n处，不包含n，将找到的部分，以新数组返回，原数组不变。原数组的索引最后一位是0,倒数第二位索引是-1,以此类推;例如: 1234var ary1=[11,22,33,44,55,66,77,88,99];var res=ary1.slice(-4,-3);console.log(res,ary1);//[66] (9) [11, 22, 33, 44, 55, 66, 77, 88, 99] a3). n&gt;0,m=原数组总长度时，slice(n,m)返回空数组;例如 123var ary1=[11,22,33,44,55,66,77,88,99];var res=ary1.slice(3,-3);//[44, 55, 66] (9) [11, 22, 33, 44, 55, 66, 77, 88, 99] a4). n&gt;0,m&gt;0,m&gt;n 参数:从索引n开始找到索引m处(不包含m); 返回值:索引n项到索引m-1项,将找到的部分以新数组返回; 原数组:不变; b). slice(n); 参数:从索引n开始一直找到数组末尾 将找到的部分以新数组返回 原数组:不变 c). slice(0);/slice() 把原来的数组克隆一份一模一样的新数组返回 原数组:不变 2).concat();把两个数组拼接在一起 参数: a). ary1.concat(ary2);将ary1和ary2进行拼接,ary2在后面 b). ary1.concat();把ary1克隆一份一模一样的数组 原数组:不变 4.修改数组中某一项的值 1).利用对象的操作方式修改某一项的值,例如:ary[2]=100; 原数组:改变 2).数组中的方法splice a). splice 既能实现删除,也能实现增加,还能实现修改 splice的删除: 返回值:删除的数据以新数组的方式返回 原数组:改变 a1). splice(n,m);从索引n开始,删除m个元素,把删除的内容以一个新数组的方式返回,原数组改变 a2). splice(n);从索引n开始,删除到数组的末尾 a3). splice(0);从索引0开始,删除到数组的末尾;原数组返回空数组,splice(0)相当于克隆一份原数组,这样的克隆会修改原来的数;例如: 1234var a=[11,22,33,44,55,66,77];var res=a.splice(0);console.log(res,a);//(7) [11, 22, 33, 44, 55, 66, 77] , [] a4). splice();相当于没有对原数组进行任何操作,splice()返回一个空数组.原数组不变;例如: 1234 var a=[11,22,33,44,55,66,77];var res=a.splice();console.log(res,a);//[] , (7) [11, 22, 33, 44, 55, 66, 77] a5). splice(a.length-1);删除最后一项，把所有索引最后一个删除掉;例如: 1234var a=[11,22,33,44,55,66];var res=a.splice(a.length-1);console.log(res,a);//[66] , (5) [11, 22, 33, 44, 55] splice的修改: b1). splice(n,m,x); 从索引n开始，删除m个，用x替换删除的部分,x可以是多项;例如: 1234var b=[1,2,3,4,5,6]; var res=b.splice(1,2,11,12,13); console.log(res,b); //[2, 3] , (7) [1, 11, 12, 13, 4, 5, 6] splice的增加: c1). splice(n,0,x); 从索引n开始，删除0个，用x替换删除的部分–&gt;相当于把x增加到索引n的前面;例如: 1234var a=[11,22,33,44,55,66];var res=a.splice(1,0,77,88);console.log(res,a);//[] , (8) [11, 77, 88, 22, 33, 44, 55, 66] c2). splice(a.length,0,x);向末尾增加,可增加多项 5.通过属性值查找索引:只有在标准浏览器下兼容的(数组中不兼容 字符串中兼容)原数组不变 1) indexOf() 2) lastIndexof() 6.遍历数组中的每一项 1) forEach(function(x,y,i){});没有返回值,例如: 12345678910var b=[11,22,33,44,55,66,11];b.forEach(function (item,index) &#123; //item为数组当前项,index为数组中的索引 console.log(item,index);&#125;);//没有返回值 var new1b=b.forEach(function (a,b) &#123; return a*10; &#125;); console.log(new1b);//undefined 2) map(function(x,y,i){return;}); 123456789var b=[11,22,33,44,55,66,11];b.map(function (item,index) &#123; //item为数组当前项,index为数组中的索引 console.log(item,index);&#125;);var newb=b.map(function (item,index) &#123; return item*10;&#125;);console.log(newb);//[110, 220, 330, 440, 550, 660, 110] 7.将数组转化为字符串: 1) join(“”);按照每一个分隔符，把数组中的每一项拼接成一个字符串 12345678var b=[12,22,33,44,55];var res=b.join(&apos;+&apos;);console.log(res,b);//&quot;12+22+33+44+55&quot; (5) [12, 22, 33, 44, 55]//扩展:eval：JS中把字符串变为JS表达式执行的一种方法 console.log(eval(res));//166 //简写: console.log(eval(b.join(&apos;+&apos;)));//166 2) toString();原数组不变 123var b=[12,22,33,44,55];var res=b.toString();console.log(res);//&quot;12,22,33,44,55&quot; 8.排序 1) reverse();把数组倒过来排列,原数组也倒过来排列;例如: 1234var b=[11,22,33,44,55,66,11];var res=b.reverse();console.log(res,b);//(7) [11, 66, 55, 44, 33, 22, 11] (7) [11, 66, 55, 44, 33, 22, 11] 2) sort();给数组进行排序,原数组也进行排序 a). ary.sort(); 只能处理10以内的数字 b). sort(function(a,b){return a-b;});从小到大排序 c). sort(function(a,b){return b-a;);从大到小排序","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-04-25T07:14:47.168Z","updated":"2017-04-25T07:19:46.593Z","comments":true,"path":"2017/04/25/hello-world/","link":"","permalink":"http://yoursite.com/2017/04/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}