{"meta":{"title":"高大秀博客","subtitle":null,"description":"本站内容涉及前端开发的相关内容,如Javascript、CSS、HTML、CSS3、较为简单的Node、jQuery插件等,为作者高大秀本人根据自己多年经验总结写成，如有异议欢迎留言，愿与大家共同进步。作者qq号:1260833716","author":"高大秀","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2017-07-26T11:43:03.000Z","updated":"2018-01-24T07:08:21.851Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于文档 Vue官方中文文档：https://cn.vuejs.org/ React官方中文文档：https://discountry.github.io/react/ Webpack文档：https://doc.webpack-china.org/ EsLint中文官网：http://eslint.cn/ React Native中文官网：https://reactnative.cn/ Node.js中文文档：http://nodejs.cn/api/ Git中文：https://git-scm.com/book/zh/v2/ Apizza(api接口文档)注册：http://apizza.cc/account/register 关于我 我的github地址：https://github.com/gaodaxiu0406"},{"title":"gitHub","date":"2017-07-29T15:46:57.000Z","updated":"2017-07-29T15:50:15.010Z","comments":true,"path":"gitHub/index.html","permalink":"http://yoursite.com/gitHub/index.html","excerpt":"","text":""},{"title":"分类目录","date":"2017-07-26T10:46:32.000Z","updated":"2017-08-18T12:14:00.674Z","comments":true,"path":"archive/index.html","permalink":"http://yoursite.com/archive/index.html","excerpt":"","text":""}],"posts":[{"title":"getter&setter","slug":"getter-setter","date":"2017-09-05T10:11:19.000Z","updated":"2017-09-05T10:20:34.009Z","comments":true,"path":"2017/09/05/getter-setter/","link":"","permalink":"http://yoursite.com/2017/09/05/getter-setter/","excerpt":"","text":"一般在书上看到都解释都是 把成员变量直接暴露在外不符合OOP的封装性原则，不安全，应该使用getter和setter方法来取值和赋值。但是没有解释为什么不符合OOP的封装性原则，为什么不安全，一个成员变量不就是取值和赋值这么两个操作吗，还能干什么，暴露出来又怎么样？ 的确可以暴露，如果 所有内外代码都是你自己写； 这个模块再也不改了； 不会继承它，或者继承但不改变语义。 David John Wheeler有一句名言：“All problems in computer science can be solved by another level of indirection(翻译:“计算机科学中的所有问题都可以通过另一种间接方式来解决).”getter、setter就是个很好的中间层。 直接摘录stackoverflow上一个不错的总结： oop - Why use getters and setters? 1.这两个方法可以方便增加额外功能（比如验证）。 2.内部存储和外部表现不同。 3.可以保持外部接口不变的情况下，修改内部存储方式和逻辑。 4.任意管理变量的生命周期和内存存储方式。提供一个debug接口。 5.能够和模拟对象、序列化乃至WPF库等融合。 6.允许继承者改变语义。 7.可以将getter、setter用于lambda表达式。（大概即作为一个函数，参与函数传递和运算） 8.getter和setter可以有不同的访问级别。 lambda表达式 Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。 lambda [&#39;læmdə] 希腊字母的第11个λ expression [ɪkˈspreʃn] 表达 abstraction [əb&#39;strækʃ(ə)n] 抽象概念以下为转载: Compiling the list up here at the top of what seemed winners to me, from the viewpoint of a Java web dev:(从Java web开发人员的角度来看，在我看来是赢家的列表上面列出了这个列表:) 1.When you realize you need to do more than just set and get the value, you don’t have to change every file in the codebase.当您意识到您需要做的不仅仅是设置和获取值时，您不必更改代码库中的每个文件。 2.You can perform validation here.您可以在这里执行验证。 3.You can change the value being set.您可以更改设置的值。 4.You can hide the internal representation. getAddress() could actually be getting several fields for you.您可以隐藏内部表示。getAddress()实际上可以为您获取多个字段。 5.You’ve insulated your public interface from changes under the sheets.您已经将您的公共接口与表单下的更改隔离了。 6.Some libraries expect this. Reflection, serialization, mock objects.一些图书馆预计。反射,序列化,模拟对象。 7.Inheriting this class, you can override default functionality.继承这个类，您可以覆盖默认的功能。 8.You can have different access levels for getter and setter.对于getter和setter，您可以有不同的访问级别。 9.Lazy loading.延迟加载；懒装载；懒加载 10.People can easily tell you didn’t use Python.人们可以很容易地告诉您，您没有使用Python。 参考链接: https://stackoverflow.com/questions/1568091/why-use-getters-and-setters https://www.zhihu.com/question/21401198/answer/18113707","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}]},{"title":"CSS盒子模型(border画三角形)及常见兼容问题解决方案","slug":"CSS盒子模型(border画三角形)及常见兼容问题解决方案","date":"2017-08-21T06:28:00.000Z","updated":"2017-09-10T13:49:11.916Z","comments":true,"path":"2017/08/21/CSS盒子模型(border画三角形)及常见兼容问题解决方案/","link":"","permalink":"http://yoursite.com/2017/08/21/CSS盒子模型(border画三角形)及常见兼容问题解决方案/","excerpt":"","text":"每一个元素在html中都是一个盒子,用来装其他盒子或者是内容 可以将html页面看做是一个仓库,仓库中从上到下摆了很多箱子,易碎品(盒子和盒子之间要有间距 内容和盒子之间要有填充 盒子本身要有厚度) 宽高属性 1.height: 100%; 指的是继承父级元素内容的高度 2.width: 100%; 指的是继承父级元素内容的宽度 特性 1.父子关系的时候,在设置margin值的时候,一般只设置上和左,不会设置下和右 2.盒子自身的宽度是由左侧边框的宽度+左侧内边距+内容的宽度+右侧内边距+右侧边框的宽度: 1ALLwidth=(border-left-width)+(padding-left)+width+(padding-right)+(border-right-width) padding和margin123456padding:1px 2px 3px 4px;//上 右 下 左 //top right bottom leftpadding:1px 2px 3px;//上 左右 下 //top left/right bottompadding:1px 2px;//上下 左右 //top/bottom left/right border12345678910111213141516border-top-width: 1px; //上边框的宽度border-top-style: solid; //上边框的样式border-top-color: red; //上边框的颜色border-color:red green yellow pink;//上 右 下 左//上边框红色 右边框绿色 下边框黄色 左边框粉色border-color:red green yellow;//上 左右 下//上边框红色 左右边框绿色 下边框黄色border-color:red green;//上下 左右//上下边框红色 左右边框绿色//合并缩写设置:border-top:1px solid pink;//上边框1px 实线 粉色border-bottom:1px solid pink;border-right:1px solid pink;border-left:1px solid pink;border:1px solid pink; 利用border画三角形123456789&lt;style&gt; div&#123; border:100px solid/* red*/; /*border-color: yellow red blue pink;*/ border-color: black transparent transparent; /*transparent透明的*/ width: 0; &#125;&lt;/style&gt; “利用border画三角形” 常见问题解决方案1.margin支持负值 margin-left和margin-top为负值的时候 跑出浏览器的部分会被吃掉,不会撑开整个页面. 2.margin-top的传递问题 如果父级没有padding-top或border-top值得时候,子元素设置margin-top值,会将这个值传递给父元素 12345678910111213141516171819202122232425262728&lt;style&gt; html,body,div&#123; padding: 0; margin: 0; background: blue; &#125; .box3&#123; width: 300px; height: 300px; background-color: green; &#125; .parent&#123; width: 200px; height: 200px; background-color: red; &#125; .son&#123; width: 100px; height: 100px; background-color: yellow; /*margin-top: 20px;*/ &#125;&lt;/style&gt;&lt;div class=&quot;box3&quot;&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 此时:在IE5~11,以及谷歌浏览器中的显示都是一致的,如下图(图片以IE浏览器截图为主) 当给子元素.son设置margin-top:20px;值后 IE5~7中并没有出现margin值的传递问题(IE7同IE5,这里就没有截图了) IE8~11以及谷歌中均出现margin-top值传递问题 解决方法:方法一) 给父级元素一个属性,overflow:hidden;- 弊端: - overflow:hidden;有溢出隐藏的含义,若给父级元素添加这个属性,子级元素超出父级盒子部分将不能显示,例如子级元素的阴影 方法二) 将子级元素的margin-top值去掉,改成父级元素的padding-top值(建议使用这个方法)- 但是此方法也有弊端: - IE5中父级盒子的高度并没有改变 ![Alt margin-top传递问题](/img/margin-top传递问题5.png) - IE7~11及谷歌浏览器中,父级盒子的高度都增加了20px; ![Alt margin-top传递问题](/img/margin-top传递问题6.png) 方法三) 给父级元素上添加一个透明的border处理 弊端: 在IE5~7中确实解决了问题 但是在IE8~11及谷歌浏览器中仍然存在margin-top的传递问题 3.margin-left/margin-right 在ie6中会双倍 当元素浮动的时候,有左右的外边距,有时候ie6会出现双倍边距的问题 解决方案:解决双边距这个方法叫css hack方案一). 给这个元素添加overflow:hidden;方案二). 写ie6的兼容方式,例如:123456div&#123;float:left;margin-left:10px !important;_margin-left:5px;&lt;!-- 当浏览器是ie6的时候 读取_margin-left:5px;这句话 --&gt;&#125; 注意:!important出现在css里面的时候,这个属性会覆盖掉所有之前设置的样式权重最大,比id选择器还大 overflow盒子内容多余部分的处理方式 overflow:hidden; 直接将多余隐藏 overflow:auto; 如果有多余部分出现滚动条,如果没有就不出现 overflow:scroll; 不论是否有多余部分,都会出现滚动条","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"box-shadow&text-shadow","slug":"box-shadow","date":"2017-08-20T09:48:16.000Z","updated":"2017-09-03T10:11:39.016Z","comments":true,"path":"2017/08/20/box-shadow/","link":"","permalink":"http://yoursite.com/2017/08/20/box-shadow/","excerpt":"","text":"box-shadow 属性向框添加一个或多个阴影 相关小项目地址:https://github.com/gaodaxiu0406/HEXOcase(CSS/小项目练习) 语法CSS语法1box-shadow: h-shadow v-shadow blur spread color inset; 注释 box-shadow 向框添加一个或多个阴影。该属性是由逗号分隔的阴影列表，每个阴影由 2-4 个长度值、可选的颜色值以及可选的 inset 关键词来规定。省略长度的值是 0。 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊距离。 spread 可选。阴影的尺寸。 color 可选。阴影的颜色。请参阅 CSS 颜色值。 inset 可选。将外部阴影 (outset) 改为内部阴影。 1box-shadow: 10px 20px 30px 40px #000 inset; JavaScript语法1object.style.boxShadow=&quot;10px 10px 5px #888888&quot; text-shadow语法CSS语法1text-shadow: h-shadow v-shadow blur color; 注释 text-shadow 属性向文本添加一个或多个阴影。该属性是逗号分隔的阴影列表，每个阴影有两个或三个长度值和一个可选的颜色值进行规定。省略的长度是 0。 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊的距离。 color 可选。阴影的颜色。参阅 CSS 颜色值。 1text-shadow: 10px 20px 30px #000;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"display","slug":"display","date":"2017-08-20T09:47:11.000Z","updated":"2017-09-05T10:34:28.412Z","comments":true,"path":"2017/08/20/display/","link":"","permalink":"http://yoursite.com/2017/08/20/display/","excerpt":"","text":"根据这个属性可以将元素分成不同的类型,也会显示出不同的状态,例如属性值为block的时候,这个元素会独占一行,如果属性值为inline的时候,所有这个属性值得元素都会在一行显示,属性值为none,元素会在页面上消失. 所有元素都有天生自带的display属性和属性值,叫做内置属性 display:block; 块级元素(块状元素) 特点: 独占一行,在所在父元素内依次向下排列,从左上角开始 宽度在不设置的情况下,宽度继承父级元素内容的宽,高度由本身内容决定 可以直接设置盒子模型的所有属性(width,height,padding,border,margin) 可以嵌套其他元素(p,dt,h1-h6不能嵌套块级) dt/p 不能嵌套其他块级元素,可以嵌套行内元素等 永远会在父级盒子的左上角开始排布,从上到下排. 人为设置的样式要比自带的样式权重高块级元素这些特点,我们将其称作BFC(Block Fomatting Context–&gt;块级盒子在上下文中的渲染模式) display:inline; 行内元素 特点: 在一行显示 不能设置宽度 高度 padding margin的上下值设置不生效,左右值生效 默认宽度高度是本身内容的宽高 几个行内元素默认的垂直方向的对齐方式是基线对齐 在编辑代码时,如果行内元素之间有回车或者空格,那么在页面显示的时候,就会默认有间隙() 将父级的font-size设置为0,可以解决这个问题. 行内元素不能嵌套块级元素 display:inline-block; 行内块级元素 特点: 在一行显示 可以直接设置宽度高度padding、margin值 默认宽度高度是本身内容的宽高 几个行内元素默认的垂直方向对齐方式是基线对齐 在编辑代码时,如果行内元素之间有回车或者空格,那么在页面显示的时候,就会默认有间隙 将父级的font-size设置为0,可以解决这个问题. 行内元素不能嵌套块级元素 vertical-align改变行内元素和行内块级元素的基线对其方式 top 所有平级元素,去找最高(高度最高)元素的顶部进行对齐 bottom 所有平级元素,去找最高(高度最高)元素的底部进行对齐 middle 所有平级元素,去找最高(高度最高)元素的中部进行对齐 length(数值) px 或 % 改变对齐方式的时候,所有元素都要添加vertical-align这个属性 display:none; 将这个元素在页面上隐藏起来 如何再让设置display:none;的元素显示出来? 将none用其他的属性替换 例如:重新设置display属性为==&gt;display:block;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HEXO主题设置","slug":"HEXO主题设置","date":"2017-07-31T14:13:32.000Z","updated":"2017-08-21T10:26:49.598Z","comments":true,"path":"2017/07/31/HEXO主题设置/","link":"","permalink":"http://yoursite.com/2017/07/31/HEXO主题设置/","excerpt":"","text":"目前使用的主题是：huno 在博客的根目录下（即上一篇文章基于GitHub创建自己的博客https://gaodaxiu0406.github.io/2017/04/25/%E5%9F%BA%E4%BA%8EGitHub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/中提到的 HEXO 文件夹下） 克隆主题 克隆主题1git clone git://github.com/someus/huno.git themes/huno 提示:huno的github地址:https://github.com/gaodaxiu0406/huno 执行：1vim _config.yml 执行此命令后可以对此文档进行编辑 输入o进入编辑状态 将 theme 对应的值进行修改1theme: huno 修改完成 按esc键退出编辑状态 再输入:wq退出编辑窗口模式 自动部署1npm install hexo-deployer-git --save 发布1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 稍等片刻看一下自己的博客主页，你想要的效果就出现了。也可以在github或百度中搜索更多主题，挑选自己喜欢的主题进行修改，只要你快乐就好 主题配置 现在主题是更改过来了，但还有许多细节需要处理，比如说你需要修改头像等等。 每个人的设置风格不同,但基本的设置在你下载的主题中的README文件中都有介绍,你可以按照文件中的介绍配置属于自己的博客。动气手来，让你的博客亮起来 返回上篇:基于GitHub创建自己的博客https://gaodaxiu0406.github.io/2017/04/25/%E5%9F%BA%E4%BA%8EGitHub%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/","categories":[],"tags":[{"name":"基于GitHub创建自己的HEXO博客","slug":"基于GitHub创建自己的HEXO博客","permalink":"http://yoursite.com/tags/基于GitHub创建自己的HEXO博客/"}]},{"title":"2.react轮播图项目开写","slug":"2-react轮播图项目开写","date":"2017-07-30T17:49:58.000Z","updated":"2017-09-09T12:26:32.998Z","comments":true,"path":"2017/07/31/2-react轮播图项目开写/","link":"","permalink":"http://yoursite.com/2017/07/31/2-react轮播图项目开写/","excerpt":"","text":"关于react轮播图的源码,无缝版已上传至github,https://github.com/gaodaxiu0406/React-Slider 用react+webpack写一个的轮播图项目(项目配置请看上篇react轮播图项目配置及原理概要) 先将整个文件写在一个文件中,1.画结构 新建一个components文件夹 components文件夹下新建Slider.js文件和Slider.less文件(Slider.less文件是用来给Slider.js写样式的) 2.在indix.js中引入组件 渲染到页面中 打开src文件夹中的index.html文件 1&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 2-1).在这个id为root的标签中渲染元素 2-2).回到index.js中,写一个轮播图组件，渲染到index.html中 12345678910import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import Slider from &apos;./components/Slider&apos;;let images=[ &#123;src:require(&apos;./images/1.jpg&apos;)&#125;, &#123;src:require(&apos;./images/2.jpg&apos;)&#125;, &#123;src:require(&apos;./images/3.jpg&apos;)&#125;, &#123;src:require(&apos;./images/4.jpg&apos;)&#125;];ReactDOM.render(&lt;Slider images=&#123;images&#125;/&gt;,document.querySelector(&apos;#root&apos;)); 解释1)引入React，引入ReactDOM，引入Slider组件 然后通过ReactDOM.render将Slider组件渲染到index.html的id为root的div标签中 解释2)Slider组件需要图片参数 src文件夹下新建一个images文件夹，存入轮播的图片 将图片路径通过require存入images数组中 通过组件Slider标签将所需的images参数传入组件Slider(让images参数变量等于images数组) 3.开始写Slider.js中的代码 需要默认导出一个组件Slider供外面文件(index.js)调用;还需要接收一个images属性进行轮播 1234567891011121314151617181920import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;require(&apos;./Slider.less&apos;);export default class Slider extends React.Component&#123; render()&#123; let images=this.props.images; return( &lt;div className=&quot;slider-wrapper&quot;&gt; &lt;ul className=&quot;sliders&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;li className=&quot;slider&quot;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125; 1)require(&#39;./Slider.less&#39;);–&gt;这里引入Slider.less用import和require都是一样的效果，都是加载一个模块的意思,模块可能是图片，可能是less/css/js/json文件,都可以–&gt;在webpack中一切皆模块,不管是什么资源，都可以作为模块来加载 2)li的数量取决于images数据,images中有几张图片，就有几个li 在render中let一个变量images来接收index.js传入的images,然后用map方法遍历整个数组 在Slider.less中写好轮播图的样式 123456789101112131415161718192021222324252627*&#123; padding: 0; margin: 0;&#125;ul,li&#123; list-style: none;&#125;.wrapper&#123; width: 400px; height: 400px; position: relative; margin: 30px auto; .sliders&#123; height: 400px; position: absolute; left:0; .slider&#123; float: left; width: 400px; height: 400px; img&#123; width: 100%; height: 100%; &#125; &#125; &#125;&#125; 宽高为400px的轮播图 4.写配置文件 在webpack.config.js中加loaders 1234567module:&#123; loaders:[ &#123;test:/\\.js$/,loader:&apos;babel-loader&apos;,exclude:/node_modules/&#125;, &#123;test:/\\.less$/,loader:&apos;style-loader!css-loader!less-loader&apos;&#125;, &#123;test:/\\.(jpg|png|gif)$/,loader:&apos;url-loader&apos;&#125; ] &#125; babel默认情况下什么都不做，需要一个配置文件.babelrc文件 新建一个.babelrc配置文件123&#123; &quot;presets&quot;: [&quot;es2015&quot;,&quot;stage-0&quot;,&quot;react&quot;]&#125; presets预设,”es2015”将es6编译成es5,”stage-0”将es7编译成es5,”react”将react编译成es5 原理1:{test:/\\.js$/,loader:&#39;babel-loader&#39;,exclude:/node_modules/}–&gt;处理(编译)js文件:如果发现文件是js,用babel-loader加载,加载的时候需要读配置文件.babelrc,如果代码时es6/es7/react都要通过babel转成es5;同时通过exclude将node_modules文件夹下的所有js文件排除掉 原理2:{test:/\\.less$/,loader:&#39;style-loader!css-loader!less-loader&#39;}–&gt;如果发现文件以.less结尾的,第一步通过less-loader将less编译成css,然后通过css-loader进行加载,然后通过style-loader将他通过style标签的形式插入到页面中去，变成一个行内样式 原理3:{test:/\\.(jpg|png|gif)$/,loader:&#39;url-loader&#39;}–&gt;凡是资源文件都可以用url-loader来加载,不论是图片、图标、字体、视频、音频;后面可以通过问号传参,有个参数limit(例如:{test:/\\.(jpg|png|gif)$/,loader:&#39;url-loader?limit=8192&#39;}–&gt;小于8K的资源文件将直接以base64的形式内联在代码中，可以减少一次http请求) 此时执行npm run build,将代码打包到出口文件中,打开build文件夹下的index.html文件就可以直接预览效果了 此时会发现控制台有个报错 123Warning: Each child in an array or iterator should have a unique &quot;key&quot; prop. Check the render method of `Slider`. See https://fb.me/react-warning-keys for more information. in li (created by Slider) in Slider 需要唯一的key属性,在Slider.js文件中的li需要唯一的key属性，给li标签加上key属性即可 1&lt;li className=&quot;slider&quot; key=&#123;index&#125;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; 关掉浏览器,重新执行npm run build，再打开build文件夹下的index.html文件预览,控制台就没有报错了 5.写功能 让图片动起来,需要给Slider.js加个状态,需要有个定时器让他动起来 写在周期函数componentDidMount中 1234567891011constructor()&#123; super(); this.state=&#123;pos:0&#125;;//默认索引 &#125; componentDidMount()&#123; this.$timer=setInterval(()=&gt;&#123; let pos=this.state.pos; pos++;//每隔2s让pos加1，pos值影响ul的左偏移量left的值 所以ul应该有个style属性 left值应该变化 this.setState(&#123;pos:pos&#125;) &#125;,this.props.interval*1000) pos++;–&gt;每隔2s让pos加1，pos值影响ul的左偏移量left的值 所以ul应该有个style属性 left值应该变化 ul应该有个style属性123456789101112131415161718192021render()&#123; let images=this.props.images; let style=&#123; width:400*images.length, left:this.state.pos*-400 &#125;; return( &lt;div className=&quot;slider-wrapper&quot;&gt; &lt;ul style=&#123;style&#125; className=&quot;sliders&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;li className=&quot;slider&quot; key=&#123;index&#125;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; this.props.interval*1000–&gt;每隔2s轮播一次,需要有变量传进来–&gt;在index.js中新增一个interval变量(间隔时间让外面可以控制) 1).这里通过this.props获取index.js中传递进来的的interval变量this.props.interval*1000 2).index.js中新增一个interval变量12345ReactDOM.render( &lt;Slider images=&#123;images&#125; interval=&#123;2&#125; /&gt;,document.querySelector(&apos;#root&apos;)); 写功能步骤总结: 第一步:定义一个默认索引pos,默认值是0 第二步:在组件加载完成之后创建定时器setInterval赋给this.$timer 第三步:每隔2s让图片向左偏移一个宽度的距离(interval是外界传进来的,是图片轮播的间隔时间),在index中要给组件Slider传进来一个2,2*1000意味着2s变一次 this.$timer中先取出老的pos值，第一次轮播pos就是0，然后pos++，pos变成1，然后setState重新设置pos值,让pos值往上 pos会影响ul的left值，一张图片的宽度是400px，向左偏移400，就是*-400 ul的宽度应该是宽度400乘以图片的数量images.length,4张图就是1600px执行npm run dev 注意,执行npm run dev可自动将文件编译更新打包到出口文件index.html中，并且只要更改文件，页面就会自动刷新,但是如果更改配置文件,需要重新启动npm run dev服务 此时执行npm run dev命令,轮播图就动起来了，但是越界了,因为此时还没有做边界处理 7.完善功能 将Slider需要的属性(可外界控制的)，在index.js的Slider组件标签中传入 1234567891011ReactDOM.render( &lt;Slider images=&#123;images&#125;//图片 interval=&#123;2&#125;//多长时间轮播一次 speed=&#123;1&#125;//每次轮播的速度 pause=&#123;true&#125;//当鼠标移动上去之后自动暂停 autoplay=&#123;true&#125;//是否启用自动轮播，false不自动轮播 - 在Slider.js中 dots=&#123;true&#125;//是否有点状导航 arrows=&#123;true&#125;//是否有箭头导航 /&gt;,document.querySelector(&apos;#root&apos;)); 添加transitionDuration–&gt;规定完成过渡效果需要花费的时间 speed默认值是1 这里就是1s 12345let style=&#123; width:400*images.length, left:this.state.pos*-400, transitionDuration:this.props.speed+&apos;s&apos; &#125;; 在Slider.js的周期函数中添加一个判断 123456789componentDidMount()&#123; if(this.props.autoPlay)&#123; this.$timer=setInterval(()=&gt;&#123; let pos=this.state.pos; pos++; this.setState(&#123;pos:pos&#125;) &#125;,this.props.interval*1000) &#125;&#125; this.props.autoPlay 是否自动轮播 如果外界传入true就是自动轮播，传入false就是不自动轮播 8.将轮播切换单独拎出来写成一个方法turn12345turn(n)&#123; let pos=this.state.pos; pos+=n; this.setState(&#123;pos:pos&#125;)&#125; 或者使用es6的箭头函数 12345turn=(n)=&gt;&#123; let pos=this.state.pos; pos+=n; this.setState(&#123;pos:pos&#125;) &#125; let pos=this.state.pos;获取旧索引 turn表示切换,n表示切换的步长,方便以后操作:例如往左走传1进来即可，往右走传-1进来即可 那么此时在周期函数中,直接调用这个turn方法即可,默认往右轮播，传入-11234567componentDidMount()&#123; if(this.props.autoplay)&#123; this.timer=setInterval(()=&gt;&#123; this.turn(1); &#125;,this.props.interval*1000) &#125;&#125; 9.实现鼠标移上去停止轮播 给div加onMouseOver和onMouseOut事件123&lt;ul onMouseOver=&#123;()=&gt;clearInterval(this.timer)&#125; onMouseOut=&#123;this.play&#125; style=&#123;style&#125; className=&quot;sliders&quot;&gt;...&lt;/ul&gt; 10.自动轮播部分也封装成一个函数play12345play=()=&gt;&#123; this.timer=setInterval(()=&gt;&#123; this.turn(1); &#125;,this.props.interval*1000) &#125;; play表示开启定时器进行自动轮播 那么此时在周期函数中直接调用this.play()即可12345componentDidMount()&#123; if(this.props.autoplay)&#123; this.play(); &#125;&#125; 11.边界判断12345678turn=(n)=&gt;&#123; let pos=this.state.pos; pos+=n; if(pos&gt;=this.props.images.length)&#123; pos=0; &#125; this.setState(&#123;pos:pos&#125;) &#125;; 当索引为图片总张数的时候 让索引变为012.写左右箭头 在ul下加一个div 1234&lt;div className=&quot;arrows&quot;&gt; &lt;span className=&quot;arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span className=&quot;arrow-right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt; 在Slider.less中写样式 123456789101112131415161718192021222324252627.arrows&#123; position: absolute; width: 100%; height: 20px; top:50%; margin-top:-10px; .arrow&#123; width: 20px; height: 20px; line-height: 20px; text-align: center; cursor: pointer; font-size: 30px; background-color: #eee; &amp;:hover&#123; background-color: #999; &#125; &#125; .arrow-left&#123; margin-left: 5px; float: left; &#125; .arrow-right&#123; margin-right: 5px; float: right; &#125;&#125; 给左右arrow绑定事件 1234&lt;div className=&quot;arrows&quot;&gt; &lt;span onClick=&#123;()=&gt;this.turn(-1)&#125; className=&quot;arrow arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span onClick=&#123;()=&gt;this.turn(1)&#125; className=&quot;arrow arrow-right&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt; 13.处理左边界 在turn中做个判断 1234567891011turn=(n)=&gt;&#123; let pos=this.state.pos; pos+=n; if(pos&gt;=this.props.images.length)&#123; pos=0; &#125; if(pos&lt;0)&#123; pos=this.props.images.length-1; &#125; this.setState(&#123;pos:pos&#125;)&#125;; 当索引小于0的时候,让索引等于images的长度-1 14.根据传进来的arrows值判断是否有左右箭头切换效果 第一种方法(看着比较乱) 123456&#123; this.props.arrows?&lt;div className=&quot;arrows&quot;&gt; &lt;span onClick=&#123;()=&gt;this.turn(-1)&#125; className=&quot;arrow arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span onClick=&#123;()=&gt;this.turn(1)&#125; className=&quot;arrow arrow-right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt;:null &#125; 第二种,在render中 123456789let arrows=null; if(this.props.arrows)&#123; arrows=( &lt;div className=&quot;arrows&quot;&gt; &lt;span onClick=&#123;()=&gt;this.turn(-1)&#125; className=&quot;arrow arrow-left&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span onClick=&#123;()=&gt;this.turn(1)&#125; className=&quot;arrow arrow-right&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt; ) &#125; 那么ul下面就可以直接用{arrows}代替了(看着很清晰明了) 123456789101112&lt;div className=&quot;slider-wrapper&quot;&gt; &lt;ul onMouseOver=&#123;()=&gt;clearInterval(this.timer)&#125; onMouseOut=&#123;this.play&#125; style=&#123;style&#125; className=&quot;sliders&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;li className=&quot;slider&quot; key=&#123;index&#125;&gt; &lt;img src=&#123;image.src&#125;/&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &#123;arrows&#125;&lt;/div&gt; 15.根据传进来的dots值判断是否有点状导航123456789101112let dots=null; if(this.props.dots)&#123; dots=( &lt;div className=&quot;dots&quot;&gt; &#123; images.map((image,index)=&gt;( &lt;span className=&quot;dot&quot; key=&#123;index&#125;&gt;&lt;/span&gt; )) &#125; &lt;/div&gt; ) &#125; dots直接放到最下面即可123...&#123;arrows&#125;&#123;dots&#125; 15-1.在Slider.less中写dots的样式12345678910111213141516171819.dots&#123; width: 100%; height: 20px; position: absolute; bottom: 10px; text-align: center; .dot&#123; display: inline-block; width: 20px; height: 20px; border-radius: 50%; margin-left: 5px; background-color: #abcdef; cursor: pointer; &amp;:hover&#123; background-color: #999999; &#125; &#125;&#125; 16.点状导航的点击跟随事件 给span加onClick事件123···&lt;span className=&quot;dot&quot; key=&#123;index&#125; onClick=&#123;()=&gt;this.turn(index-this.props.pos)&#125;&gt;&lt;/span&gt;··· 16-1.轮播点状导航自动跟随事件 在Slider.less中加一个active样式 123.active&#123; background-color: #999999; &#125; 给span标签添加active属性 1&lt;span className=&#123;&quot;dot &quot;+(index==this.state.pos?&apos;active&apos;:&apos;&apos;)&#125; key=&#123;index&#125; onClick=&#123;()=&gt;this.turn(index-this.state.pos)&#125;&gt;&lt;/span&gt;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"1.react轮播图项目配置及原理概要","slug":"1-react轮播图项目配置及原理概要","date":"2017-07-30T17:47:17.000Z","updated":"2017-09-09T12:26:33.016Z","comments":true,"path":"2017/07/31/1-react轮播图项目配置及原理概要/","link":"","permalink":"http://yoursite.com/2017/07/31/1-react轮播图项目配置及原理概要/","excerpt":"","text":"项目配置及原理概要1.初始化项目1npm init -y 生成package.json文件 2.安装依赖包 开发依赖1npm install webpack webpack-dev-server babel-core babel-loader babel-preset-react babel-preset-es2015 babel-preset-stage-0 style-loader css-loader less-loader less file-loader url-loader html-webpack-plugin -D webpack 打包 webpack-dev-server 用来启动一个HTTP服务器预览我们的项目 babel-core babel-loader 进行转译 把es6和react代码转译成es5 babel-preset-react 用来转译react babel-preset-es2015 用来转译es6 babel-preset-stage-0 用来转译es7 style-loader css-loader 用来处理css less-loader less 编译less file-loader url-loader 用来处理资源文件 html-webpack-plugin 用来自动产出html文件 open-browser-webpack-plugin 自动打开浏览器 3.安装生产依赖1npm install react react-dom -S 4.配置文件的出入口路径 新建一个webpack.config.js文件，在文件中配置入口文件和出口路径12345678let path=require(&apos;path&apos;);module.exports=&#123; entry:&apos;./src/index.js&apos;,//入口文件 output:&#123;//出口配置 path:path.resolve(&apos;build&apos;),//出口文件路径 filename:&apos;bundle.js&apos;//出口文件名称 &#125;&#125;; 5.启动安装的模块文件夹node_modules–&gt;.bin–&gt;webpack.cmd和webpack-dev-server.cmd文件 在package.json文件中的scripts标签进行匹配1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;dev&quot;:&quot;webpack-dev-server&quot; &#125;, 5-1.启动webpack和webpack-dev 在cmd中执行命令 1npm run build 1)在cmd窗口中显示 123 Asset Size Chunks Chunk Namesbundle.js 2.52 kB 0 [emitted] main [0] ./src/index.js 43 bytes &#123;0&#125; [built] 表示生成bundle.js一个文件 2)在当前项目文件夹下会自动生成一个build文件夹，同时在build文件夹下会自动生成bundle.js文件，我们的入口文件(src文件夹下的index.js)会自动打包到出口文件bundle.js中 6.自动产出html文件6-1.现在我们需要在build文件夹中新建一个index.html文件，然后引入bundle.js进行预览;但是现在我们希望这个文件不要手动创建了，希望他可以自动生成，要做到这一点，我们需要引入插件html-webpack-plugin(此插件在最初已经安装过,如果没有安装需安装后才可使用) 1) 在webpack.config.js中引入html-webpack-plugin 1let HtmlWebPackPlugin=require(&apos;html-webpack-plugin&apos;); 2) 同时给插件再添加个配置项plugins,plugins是个数组 12345plugins:[ new HtmlWebPackPlugin(&#123; template:&apos;./src/index.html&apos; &#125;)] 3) template 模板 配置到时候会按照哪个模板来自动产出html文件 并且把它自动放到配置目录下–&gt;一般会在src文件夹下新建一个模板叫index.html 4) 执行npm run build 4-1).原理:此时如果再执行npm run build的话，就会执行上面配置的plugins插件,插件会读取src文件夹下的index.html模板文件，把他自动插入到打包后的bundle.js，并且把bundle.js保存到build目录下(每次执行npm run build命令，都会重新生成bundle.js和index.html两个文件) 4-2).在cmd命令行执行npm run build,命令行显示: 1234 Asset Size Chunks Chunk Names bundle.js 2.52 kB 0 [emitted] mainindex.html 188 bytes [emitted] [0] ./src/index.js 43 bytes &#123;0&#125; [built] 表示生成bundle.js和index.html两个文件,与之前执行npm run build相比多了一个html文件 4-3).打开我们的项目文件夹下的build文件会发现，已经自动生成了一个出口index.html出口文件,打开这个index.html出口文件会发现,index.html中已经自动引入了bundle.js文件 关于react轮播图的源码,无缝版已上传至github,https://github.com/gaodaxiu0406/React-Slider","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"CSS选择器种类和兼容性总结大全","slug":"css选择器种类和兼容性总结大全","date":"2017-07-21T07:57:22.000Z","updated":"2017-08-16T15:33:05.869Z","comments":true,"path":"2017/07/21/css选择器种类和兼容性总结大全/","link":"","permalink":"http://yoursite.com/2017/07/21/css选择器种类和兼容性总结大全/","excerpt":"","text":"css5选择器 名称 举例 描述 详细 权重 ie6-7 ie8 ie9+ 其他 标签选择器 p{} 直接使用元素标签进行选择 1 yes yes yes 类选择器 .sum{} 类选择器最前方一定要有点 通过元素的类名，来选择元素，一个元素可以有多个类名，都代表这个元素,类名是元素class属性中的属性值，例如&lt;p class=&#39;sum&#39;&gt;&lt;/p&gt; 10 yes yes yes id选择器 #tytle{color:red;} id在html中具有唯一性,这个属性值前面加一个“#” 一个html元素，id属性值只能用一次 100 yes yes yes 通配符选择器 *{key:value} 匹配全部html元素 一般不使用，因为全部匹配耗性能 0&lt;通配符选择器&lt;1 yes yes yes yes (标签)属性选择器 [type]或[type=text] [标签属性名]{}或[标签属性名=属性值]{} 利用标签的属性名和属性值来选择html元素 10 yes yes yes 属性选择器在使用的时候，如果一个元素有两个类名，那么是不生效的 分组选择器 .box,li,.p1{color: red}; 选择器1，选择器2，选择器3{} 同一份css样式，可以一次性的添加给多个不同的html元素 分组选择器将不同的html分为一组，权重计算的时候都是独立计算，不会叠加。 yes yes yes 交集选择器 h2[title]{} 两种选择器同属于一个元素的时候，我们可以使用交集选择器来进行元素的准确选择 所有组合选择器权重之和 yes yes yes 作用：精确查找元素，增加选择器的权重 子级选择器 ul&gt;li{color:red;} 父级选择器&gt;子级选择器{} 存在包含关系的元素选择，通过父级确定选择子级 所有选择器之和 yes yes yes 子级选择器必须是紧邻的父子关系 后代选择器(派生选择器) .div1 ul span{} 祖辈选择器 要查找的后代选择器{},中间用空格连接 后代选择器在写的时候尽量控制在３个左右 yes yes yes 在一个根元素的范围内，查找到它的后代元素，选择器过多浪费性能，不建议使用 相邻兄弟选择器 .list1+li{color: red;} 哥哥选择器+弟弟选择器{} 通过各个元素选择弟弟选择器，两个选择器之间用“+”连接 选择器之和 yes yes yes 伪类选择器 a:hover{color: red}鼠标经过的状态,或a:link{color: blue}默认状态,或a：active{color: green}鼠标点击的状态,或a:visited{color: blanchedalmond}鼠标点击后的状态 10 yes yes yes .input:focus{border-color: blue};input:focus 鼠标聚焦后的状态，input独有的属性 伪元素 div:before{}；或div:after{} 通过css代码向指定元素内添加假的（html中不存在的）元素 before 会出现在div所有内容之前，after 会出现在div所有内容之后 no yes yes 使用伪元素的时候要保证两个前提：1.要有display这个属性2.要有content这个属性，这个属性的属性值可以为空，但是引号不能少content:&quot;&quot; visited security issue yes yes security issue css3选择器 名称 举例 描述 详细 权重 ie6-7 ie8 ie9+ 其他 属性选择器 E[attr~=value]{} 指定属性名,并且具有属性值,此属性值是一个此列表(类名),并且以空格隔开,其中词列表中包含了一个value词,并且等号前的~不能省略. E[attr^=value]{} ^ 表示以谁为开头的,value可以是首字母或者类名 必须是第一个类名 E[attr$=value]{} $ 表示以谁为结尾,value可以是末尾字母或者类名 必须是最后一个类名 E[attr\\=value]{}(由于编辑呈现问题，此处用斜杠代替竖杠,正确写法是E[attr竖杠=value]{}) 如果只有一个类名,没有”-“,也可以选中 value必须后面带”-“，value必须是第一个类名 伪类选择器1. .dome p:nth-child(3){background: red;}选择dome下的第三个p标签为背景色红色 no no yes 2. .dome p:first-child{background: yellow;}选择dome下的第一个p标签为背景色黄色 no almost yes 3. .dome p:last-child{background: black;}选择dome下的最后一个p标签为背景色黑色 伪类选择器是针对列表或者很多同级的标签使用,img下是没有效果的也用不到伪类选择器 no no yes 4. .dome p:nth-child(nlength){}；选择dome下所有的p标签 no no yes 5. .dome p:nth-child(2n){}；选择dome下的所有偶数个的p标签 no no yes 6. .dome p:nth-child(3n)选择dome下的所有3的倍数的p标签 no no yes 7. .dome p:nth-child(n+length) 从第length个开始改变,包括第length个(n是从0开始取值的) 选择大于length后面的元素 no no yes 8. .dome p:nth-child(-n+length) 包括length，length是从0开始的 选择小于length前面的元素及length元素 no no yes 9. p:nth-last-child(3) 选择倒数第三个元素 no no yes 10. p:nth-child(n) 从大盒子的第一个元素开始 nth-child选择同级元素 no no yes 11. p:nth-of-type(n) 从大盒子的第一个p元素开始 nth-of-type 选择指定的元素 no no yes 12. p:nth-last-of-type(n) 倒数第n个 在同级元素中 no no yes 13. p:first-of-type{} 同类型的第一个 选择一个上级元素下的同类子元素 no no yes 14. p:last-of-type{} 同类型的最后一个 no no yes 15. p:only-child{} 在父元素中,里面的子元素是唯一的 no no yes 16. p:only-of-type{} 在父元素中,里面有很多的子元素,但是有一个子元素是唯一的 no no yes 空标签 p:empty{display:none;} empty 隐藏空标签 no no yes 否定选择器 not input:not([type=submit]){} no yes yes 根元素 root :root{} 选择文档的根元素 no no yes 目标元素 :target{} 选择器可用于选取当前活动的目标元素 no no no CSS选择器优先级 当两个规则都作用到了同一个html元素上时，如果定义的属性有冲突，那么应该用谁的值的，CSS有一套优先级的定义 不同级别 1.在属性后面使用important会覆盖页面内任何位置定义的元素样式 2.作为style属性写在元素内的样式 3.id选择器 4.类选择器 5.标签选择器 6.通配符选择器 7.浏览器自定义或继承 总结CSS选择器优先级排序: !important&gt;行内样式&gt;ID选择器&gt;类选择器&gt;标签&gt;通配符&gt;继承&gt;浏览器默认属性 CSS样式应用，有个简单的计算方式(权值实际并不是按照十进制，用数字表示只是说明思想，一万个class可能也不如一个id权值高) 内联样式表的权值为 1000 ID选择器的权值为 100 Class类选择器的权值为 10 HTML标签选择器的权值为 1","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS属性的继承及相关面试题","slug":"CSS属性的继承及相关面试题","date":"2017-06-30T08:56:14.000Z","updated":"2017-08-16T15:32:20.878Z","comments":true,"path":"2017/06/30/CSS属性的继承及相关面试题/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS属性的继承及相关面试题/","excerpt":"","text":"CSS属性的继承 子级元素从父级元素身上继承的一些可继承的css属性 1234&lt;style&gt;div&#123;color:red;&#125;&lt;/style&gt;&lt;p&gt;woshiyige[biaoqian&lt;/p&gt; 根据 CSS，子元素从父元素继承属性。看看下面这条规则： body {font-family: Verdana, sans-serif;} 根据上面这条规则，站点的 body 元素将使用 Verdana 字体（假如访问者的系统中存在该字体的话）。 继承的权重较小，可被其他选择器的样式覆盖 面试题： 哪些css样式可以被继承：和文字有关的css样式 和列表有关的css样式总结： 1.可继承属性 1)可以继承的文本相关属性： 1&lt;azimuth&gt;&lt;border-collapse&gt;&lt;border-spacing&gt;&lt;caption-side&gt;&lt;color&gt;&lt;cursor&gt;&lt;direction&gt;&lt;elevation&gt;&lt;empty-cells&gt;&lt;font-family&gt;&lt;font-size&gt;&lt;font-style&gt;&lt;font-variant&gt;&lt;font-weight&gt;&lt;font&gt;&lt;letter-spacing&gt;&lt;line-height&gt;&lt;list-style-image&gt;&lt;list-style-position&gt;&lt;list-style-type&gt;&lt;list-style&gt;&lt;orphans&gt;&lt;pitch-range&gt;&lt;pitch&gt;&lt;quotes&gt;&lt;richness&gt;&lt;speak-header&gt;&lt;speaknumeral&gt;&lt;speak-punctuation&gt;&lt;speak&gt;&lt;speechrate&gt;&lt;stress&gt;&lt;text-align&gt;&lt;text-indent&gt;&lt;texttransform&gt;&lt;visibility&gt;&lt;voice-family&gt;&lt;volume&gt;&lt;whitespace&gt;&lt;widows&gt;&lt;word-spacing&gt; 2)可以继承的列表相关属性： 1&lt;azimuth&gt;&lt;border-collapse&gt;&lt;border-spacing&gt;&lt;caption-side&gt;&lt;color&gt;&lt;cursor&gt;&lt;direction&gt;&lt;elevation&gt;&lt;empty-cells&gt;&lt;font-family&gt;&lt;font-size&gt;&lt;font-style&gt;&lt;font-variant&gt;&lt;font-weight&gt;&lt;font&gt;&lt;letter-spacing&gt;&lt;line-height&gt;&lt;list-style-image&gt;&lt;list-style-position&gt;&lt;list-style-type&gt;&lt;list-style&gt;&lt;orphans&gt;&lt;pitch-range&gt;&lt;pitch&gt;&lt;quotes&gt;&lt;richness&gt;&lt;speak-header&gt;&lt;speaknumeral&gt;&lt;speak-punctuation&gt;&lt;speak&gt;&lt;speechrate&gt;&lt;stress&gt;&lt;text-align&gt;&lt;text-indent&gt;&lt;texttransform&gt;&lt;visibility&gt;&lt;voice-family&gt;&lt;volume&gt;&lt;whitespace&gt;&lt;widows&gt;&lt;word-spacing&gt; 2.不可继承属性 1&lt;display&gt;&lt;margin&gt;&lt;border&gt;&lt;padding&gt;&lt;background&gt;&lt;height&gt;&lt;min-height&gt;&lt;max-height&gt;&lt;width&gt;&lt;min-width&gt;&lt;max-width&gt;&lt;overflow&gt;&lt;position&gt;&lt;left&gt;&lt;right&gt;&lt;top&gt;&lt;bottom&gt;&lt;z-index&gt;&lt;float&gt;&lt;clear&gt;&lt;table-layout&gt;&lt;vertical-align&gt;&lt;page-break-after&gt;&lt;page-bread-before&gt;和&lt;unicode-bidi&gt; 3.所有元素可继承： &lt;visibility&gt;（可见性）和&lt;cursor&gt;(光标) 4.终端块状元素可继承： &lt;text-indent&gt;和&lt;text-align&gt; 5.如果css属性不带有继承性，如何继承父级身上的属性，可以将要继承的属性的属性值写上inherit12ul&#123;float:left;&#125;li&#123;float:inherit;&#125;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS中的form表单与table表格","slug":"CSS中的form表单与table表格","date":"2017-06-30T08:15:23.000Z","updated":"2017-08-16T15:32:15.668Z","comments":true,"path":"2017/06/30/CSS中的form表单与table表格/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS中的form表单与table表格/","excerpt":"","text":"form表单 用来获取用户信息&lt;form&gt;&lt;/form&gt; 12345678910111213141516171819202122&lt;form&gt; &lt;input type=&quot;radio&quot; name=&quot;ok&quot; checked=&quot;checked&quot;&gt;&lt;!--单选按钮--&gt;&lt;label&gt;满意&lt;/label&gt;&lt;!--label 描述表单元素功能--&gt; &lt;!--type 类型--&gt; &lt;!--name 名字--&gt; &lt;!--checked 选中--&gt; &lt;input type=&quot;radio&quot; name=&quot;ok&quot;&gt;&lt;!--单选按钮--&gt;&lt;label&gt;不满意&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;篮球&lt;/label&gt; &lt;input type=&quot;checkbox&quot; checked&gt;&lt;label&gt;美女&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;彭于晏&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;陈冠希&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;杨颖&lt;/label&gt; &lt;input type=&quot;checkbox&quot;&gt;&lt;label&gt;维密&lt;/label&gt; &lt;textarea maxlength=&quot;10&quot; minlength=&quot;1&quot;&gt;&lt;/textarea&gt;&lt;!--文本域--&gt; &lt;!--maxlength 字符输入的最大长度--&gt; &lt;br&gt; &lt;label&gt;姓名&lt;/label&gt;&lt;input type=&quot;text&quot;&gt; &lt;br&gt; &lt;label&gt;手机&lt;/label&gt;&lt;input type=&quot;text&quot;&gt; &lt;br&gt; &lt;label&gt;密码&lt;/label&gt;&lt;input type=&quot;password&quot;&gt;&lt;/form&gt; radio 单选按钮 name=”ok”（name的值相同情况下）同时给到input type=”radio”，表示单选只能选中其中的一个 lable描述表单元素功能 type 类型 name 名字 cheked 选中 单独写checked也可以达到选中的效果 &lt;input type=&quot;checkbox&quot;&gt;checkbox 多选按钮 textarea 文本域 &lt;textarea maxlength=&quot;10&quot; minlength=&quot;1&quot;&gt;&lt;/textarea&gt; maxlength字符输入的最大长度 table表格 &lt;caption&gt;标题&lt;/caption&gt; &lt;thead&gt;表头&lt;/thead&gt; tr&gt;th（标题单元格，th加粗居中） &lt;tfoot&gt; 表尾 tr&gt;th（普通单元格） tr&gt;td（普通单元格，td不加粗不居中） tbody 表身 tr&gt;th（普通单元格） thead和tfoot分别有一个 tbody可以有多个tfoot一般放置在thead的后面，为了防止tbody中的内容过多，tfoot加载过慢的情况，但是虽然书写位置在前面，在页面中显示的时候，这部分依然在整个表格的最后面如果table用来搭建结构，我们只需写tr和td 123456789101112&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"标签语义化","slug":"CSS标签语义化","date":"2017-06-30T08:11:33.000Z","updated":"2017-08-16T15:32:38.255Z","comments":true,"path":"2017/06/30/CSS标签语义化/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS标签语义化/","excerpt":"","text":"标签语义化的重要性/为什么要遵循标签语义化：合理的标签做合理的事情 1、重要的内容，要放在语义重要的标签中，利于SEO优化(搜索引擎榨取),利于SEO优化(也就是搜索引擎的抓取，搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重); 浏览器会按照每个标签的意义去解析这个标签中的内容:h1–&gt;这是一个大标题，意义很重要，搜索引擎会重点抓取这个里面的内容 p–&gt;段落 浏览器在展现这一部分的时候，会独立成一块，让网页结构更加清晰，给用户更好的浏览体验 2、在没有css样式的时候，页面也可以整齐的显示效果 3、更好的支持各种终端，例如无障碍阅读和有声小说等； 4、利于团队协作和后期维护 日常工作中怎样遵循标签语义化： 1、尽量减少使用无意义标签，例如span和div； 2、尽量不使用标签本身的css属性，例如b、font、s等标签，如果需要这些样式，那么使用css样式来进行添加； 3、在需要强调的部分，使用strong、em，但是样式尽量使用css样式来描述； 4、表格搭建时，使用`表格头部 表格身体 表格尾部； 5、列表搭建时，使用无序列表 有序列表 定义列表；` 国家评比一个网站的关键点：访问量（流量/点击量）","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML标签分类","slug":"HTML标签分类","date":"2017-06-30T08:09:06.000Z","updated":"2018-02-10T11:43:48.836Z","comments":true,"path":"2017/06/30/HTML标签分类/","link":"","permalink":"http://yoursite.com/2017/06/30/HTML标签分类/","excerpt":"","text":"html标签分类 html标签又叫做html元素，它分为块级元素和内联元素（也可以叫做行内元素），都是html规范中的概念。 块级元素 块级元素是指本身属性为display:block;的元素。因为它自身的特点，我们通常使用块级元素来进行大布局（大结构）的搭建 块级元素的特点： 独占一行，每一个块级元素都会从新的一行重新开始，从上到下排布 可以直接控制宽度、高度以及盒子模型的相关css属性 在不设置宽度的情况下，块级元素的宽度是它父级元素内容的宽度 在不设置高度的情况下，块级元素的高度是它本身内容的高度 常用的块级元素: div 常用块级容器，也是css layout的主要标签 h1 大标题 h2 副标题 h3 三级标题 h4 四级标题 h5 五级标题 h6 六级标题12345678910标题：&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;h$&#123;$级标题&#125;*6+tab生成：&lt;h1&gt;1级标题&lt;/h1&gt;&lt;h2&gt;2级标题&lt;/h2&gt;&lt;h3&gt;3级标题&lt;/h3&gt;&lt;h4&gt;4级标题&lt;/h4&gt;&lt;h5&gt;5级标题&lt;/h5&gt;&lt;h6&gt;6级标题&lt;/h6&gt; hr 水平分隔线 menu 菜单列表 ol 有序列表 li列表项 123456789有序列表&lt;ol&gt; &lt;li&gt;盗天仙图&lt;/li&gt; &lt;li&gt;名侦探&lt;/li&gt; &lt;li&gt;鬼吹灯&lt;/li&gt; &lt;li&gt;盗墓笔记&lt;/li&gt; &lt;li&gt;名侦探&lt;/li&gt; &lt;li&gt;鬼吹灯&lt;/li&gt;&lt;/ol&gt; ul 无序列表 li列表项 123456789无序列表&lt;ul&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;有保证&lt;/b&gt;&lt;/span&gt;:先学习考试后入学&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;有实力&lt;/b&gt;&lt;/span&gt;:专注JS培训七年铸就传奇就业,平均工资超12K&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;有深度&lt;/b&gt;&lt;/span&gt;:结合的大学算法和数据结构的基础课&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;重原生&lt;/b&gt;&lt;/span&gt;:狠练原生代码,原生JS+Node才是王道&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;重应用&lt;/b&gt;&lt;/span&gt;:PC+移动端+H5+CSS3+node的前后台全栈项目&lt;/li&gt; &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;√&lt;b&gt;重未来&lt;/b&gt;&lt;/span&gt;:app开发,微信开发,angular,es6,前沿技术&lt;/li&gt;&lt;/ul&gt; dl 定义列表 dt 定义术语 dd定义描述 table 表格 p 段落1234567891011&lt;div class=&quot;poem&quot;&gt;&lt;h4&gt;早发白帝城&lt;/h4&gt;&lt;h5&gt;作者：李白&lt;/h5&gt;&lt;p&gt;朝辞白帝彩云间，&lt;br&gt; 千里江陵一日还。&lt;br&gt; 两岸猿声啼不尽，&lt;br&gt; 轻舟已过万重山。&lt;br&gt; &lt;img src=&quot;timg.jpg&quot; alt=&quot;李白&quot;&gt;&lt;/p&gt;&lt;/div&gt; 123456789&lt;div&gt; &lt;h4 align=&quot;center&quot;&gt;早发白帝城&lt;/h4&gt; &lt;h5 align=&quot;center&quot;&gt;作者：李白&lt;/h5&gt; &lt;p align=&quot;center&quot;&gt;朝辞白帝彩云间，&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;千里江陵一日还。&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;两岸猿声啼不尽，&lt;/p&gt; &lt;p align=&quot;center&quot;&gt;轻舟已过万重山。&lt;/p&gt; &lt;img src=&quot;timg.jpg&quot; alt=&quot;李白&quot;&gt;&lt;/div&gt; form 交互表单 内联元素 内联元素是指本身属性为display:inline;的元素。因为它自身的特点，我们通常使用块级元素来进行文字、小图标（小结构）的搭建。 内联元素的特点： 和其他内联元素从左到右在一行显示 2.不能直接控制宽度、高度以及盒子模型的相关css属性，但是直接设置内外边距的左右值是可以的 3.内联元素的宽高是由本身内容的大小决定（文字、图片等） 4.内联元素只能容纳文本或者其他内联元素（此处请注意，不要在内联元素中嵌套块级元素） 常用的内联元素: span 常用内联容器，定义文本内区块 a 锚点 文本设置类: b 加粗 strong 加粗强调 i 斜体 em 斜体强调 s 中划线（不推荐使用） strike 中划线 del 文档中已被删除的文本 big 大字体文本、small小字体文本） small 小字体文本 br 强制换行 u 下划线 textarea 多行文本输入框 input 输入框 select 下拉列表 label（input 元素定义标注/标记）、img sub 下标 sup 上标","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML基本结构","slug":"HTML基本结构","date":"2017-06-30T07:59:54.000Z","updated":"2017-09-09T12:23:51.210Z","comments":true,"path":"2017/06/30/HTML基本结构/","link":"","permalink":"http://yoursite.com/2017/06/30/HTML基本结构/","excerpt":"","text":"html的基本结构123456789101112&lt;!DOCTYPE html&gt;文档声明：必须放在html文件的第一行；如果没有文档声明会触发浏览器的怪异模式&lt;html&gt;html元素：告知浏览器，我是一个html文件 &lt;head&gt; head元素：文档的头部，一般放在文档头部的内容不会显示在浏览器的可视区内 &lt;meta charset=&quot;utf-8&quot;&gt;规定一个语法 必须放在head的第一部分 &lt;title&gt;标题，显示在浏览器的页卡位置，title中的内容也会被seo抓取&lt;/title&gt; &lt;body&gt;供用户浏览的所有内容，标签、图片、文本、视频···&lt;/body&gt; &lt;/head&gt;&lt;/html&gt; 一个html文件也叫做一个网页，可以称作是一个文档(document) 这个文档从html元素开始，一致向下分支延伸，像一颗大树一样，所以我们将html元素叫做这个文档的根元素 &lt;!DOCTYPE html&gt;html5的文档声明 作用：定义这个文档类型，浏览器先识别这句话，会按照定义的类型去解析这个文档 html5的文档声明，那么浏览器就会按照html5的规则解析整个页面`&lt;!DOCTYPE HTML PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;html4版本的文档声明` 所有高版本都会向下兼容，所以在以后的工作中，我们直接将文档声明写错html5就可以了 文档声明必须写在html文件的第一行 文档声明不区分大小写 如果html文件没有文档声明，会触发浏览器的怪异模式 文档声明不是一个html标签 1.html元素此元素告知浏览器其自身是一个html元素是由开始和结束标签组成的，html文件里面所有的内容都会放在这个这个元素内 2.head元素- 整个文档的头部，head元素自带隐藏功能，display:none;里面的内容不会隐藏，只不过一般放置在head元素中的其他元素和内容也是自带隐藏功能的，例如link、script、meta··· - `&lt;script&gt;&lt;/script&gt;与head标签一样具有隐藏功能，写在其内的内容在网页不显示` 3.&lt;meta charset=&quot;UTF-8&quot;&gt;4.&lt;meta&gt;规定了html文档的元信息 charset=”UTF-8” 文档的编码 UTF-8 国际通用编码 gbk 国标 gb2312 国标 name=”keyword” content=”关键词” name=”keyword” content=”HTML5J5…” SEO优化有关 SEO搜索引擎&lt;meta name=&quot;keyword&quot; content=&quot;关键词&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;勿忘初心,方得始终&quot;&gt; 5.title元素 html文档名称 一个页面只有一个title元素放文字 显示在浏览器的页卡（页头）位置6.link标签 &lt;link href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; rel=&quot;shortcut icon&quot;&gt; 图标让设计师生成 一般整个图片放在整个项目的根目录下 显示在浏览器页卡位置，title内容之前 &lt;link rel=&quot;stylesheet&quot; herf=&quot;url&quot; type=&quot;texe/css&quot;&gt; 引入一个外部的css文件 rel不能缺少 stylesheet样式表 type可以省略 但是建议写全 7.body元素 定义整个文档的主体部分，所有展示给用户的内容都要放在这个元素中 body中有常用的html元素（div、ul），文本内容、音频、视频、图片、表单1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UIF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS的引入方式","slug":"CSS的引入方式","date":"2017-06-30T07:27:20.000Z","updated":"2017-08-16T15:22:11.645Z","comments":true,"path":"2017/06/30/CSS的引入方式/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS的引入方式/","excerpt":"","text":"css如何在html中使用（html引入css的四种方法） 行内式：直接写在标签内，通过标签属性style引入 媒介：style属性&lt;style type=&quot;text/css&quot;&gt;选择器{}&lt;/style&gt;12&lt;div style=&quot;css属性名:属性值；&quot;&gt;&lt;/div&gt;&lt;img style=&quot;css属性名:属性值；&quot;alt=&quot;&quot;&gt; css想要生效，html中必须有这个元素才可以 内嵌式（内联式）:将css代码写在style元素内，通过css选择器选择html元素，将css样式添加个这个元素 媒介：style标签+选择器 style这个元素一般放在head元素内 style元素：盛装css样式12345&lt;style&gt;div&#123;height:100px;&#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 外联式（外链式）：将css代码单独放置在一个css文件中，再通过link标签将这个css文件引入到html文件中 媒介：link标签+选择器1&lt;link rel=&quot;stylesheet&quot; herf=&quot;css文件链接地址&quot; type=&quot;text/css&quot;&gt; css这个文件中不能出现标签 导入式：都是引入一个单独的css文件 媒介：@import”css文件链接地址”; 当有多个css文件的时候，可以使用导入式先导入到一个css文件中，再用外链式link外链进html文件 @import”css文件链接地址”;既不是html标签，也不是css属性，他是一条声明语句 这条语句必须写在style元素内,或者css文件内 这条语句必须在所在文件内的第一行 外链式和导入式的差别： link和@import虽然都是引入外部的css文件，但是他们是由天差地别的区别的 1) link是html标签，@import完全是css提供的方式，要写在css文件或者style标签中。 2) 他们的加载顺序也是有区别的，当一个页面被加载的时候，link引用的css文件会被同时加载，而@import引入的css文件会等页面全部下载完后再加载。 3) 当使用javascript控制DOM去改变css样式的时候，只能使用link标签，因为import是不能被DOM控制的。 在工作中常用的引入方式是外链式 四种引入方式的权重（一个html元素最终加载的css样式是谁决定的） 有行内式的时候，听行内的 在选择器相同的情况下，谁最后加载就听谁的 外链式和内嵌式一般都放在head元素内 CSS层叠样式表 css的作用： 给html文档添加静态或者动态的样式 css和html如何融合到一起 在css文件中如何选择一个html元素，将样式添加给这个元素","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS常用选择器","slug":"CSS常用选择器","date":"2017-06-30T07:14:52.000Z","updated":"2017-08-21T08:15:50.083Z","comments":true,"path":"2017/06/30/CSS常用选择器/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS常用选择器/","excerpt":"","text":"CSS选择器 因为html和css分离，那么就出现一个问题，如何选择一个元素，将样式添加给这个元素–&gt;css选择器 选择器是css属性和html元素的连接桥梁，通过正确的选择器来找到想要操作的元素，添加一定的样式。 选择器{} 1.语法选择器{key:value;key:value;} 可以批量选择选择器名称相同的元素 通过选择器类型不同，可以选择不同的html元素 2.CSS基础选择器分类1) 标签选择器 1-1).说明:直接使用元素标签进行选择 例如：&lt;p&gt;&lt;/p&gt; p{color:red;} 1-2).权重:11234&lt;style&gt;h1&#123;color:red;&#125;&lt;/style&gt;&lt;h1&gt;标签选择器&lt;/h1&gt; 2) 类选择器 2-1).说明: 1).将html元素的class标签属性值当作选择器使用，需要在这个属性值前面加一个“.” 2).通过元素的类名，来选择元素，一个元素可以有多个类名，都代表这个元素 3).类名是元素class属性中的属性值，例如(下例中的sum即为类名) 12&lt;p class=&apos;sum&apos;&gt;&lt;/p&gt;&lt;style&gt;.sum&#123;&#125;&lt;/style&gt; 4).一个html元素可以有多个css属性值（可以有多个类名，每一个类名之间用空格隔开） 5).类名可以重复使用 2-2).权重:10 类选择器最前方一定要有点,例如:123456&lt;style&gt;.title&#123;color:red;&#125;&lt;/style&gt;&lt;h1 class=&quot;title title1&quot;&gt;标签选择器&lt;/h1&gt;&lt;h1 class=&quot;title&quot;&gt;标签选择器&lt;/h1&gt;//以上class属性名为title中的文字颜色都讲被设置为红色 3) id选择器 3-1).说明: 1).一个html元素，id属性值只能用一次，id在html中具有唯一性 2).类选择器最前方一定要有# 3).通过元素的id名，来选择元素 4).类名是元素id属性中的属性值(title/title1)，例如:12345&lt;style&gt;#title&#123;color:red;&#125;&lt;/style&gt;&lt;h1 id=&quot;title title1&quot;&gt;id选择器&lt;/h1&gt;&lt;h1 id=&quot;title&quot;&gt;错误的，不识别&lt;/h1&gt; 3-2).权重:100 总结(根据权重)： 标签选择器相当于人的姓名,类选择器相当于人的名字,id选择器相当于身份证号码,是独一无二的。 4) 通配符选择器 4-1). 说明: 1).通过*匹配全部html元素，包括根元素 2).一般不使用，因为全部匹配耗性能 3)语法:*{}1*&#123;key:value&#125; 4-2). 权重&lt;1,可被覆盖 5) 并集选择器 5-1).说明: 1). 你可以对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。用逗号将需要分组的选择器分开。在下面的例子中，我们对所有的标题元素进行了分组。所有的标题元素都是绿色的。 例如：1h1,h2,h3,h4,h5,h6&#123;color:green;&#125; 6) 属性选择器 6-1).说明: 1). 对带有指定属性的 HTML 元素设置样式，可以为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。 下面的例子为带有 title 属性的所有元素设置样式：123[title]&#123; color:red; &#125; 2). 利用标签的属性名和属性值来选择html元素 3). 属性选择器在使用的时候，如果一个元素有两个类名，那么是不生效的。 4). 属性选择器我们一般不会使用class,因为class可以直接使用类选择器12345&lt;!--有多少种方法只获取div?--&gt; /*如果class值有两个，不能这样使用*/&lt;style&gt;[class=div1]&#123;&#125;;&lt;/style&gt;&lt;div class=&quot;div1 p1&quot; id=&quot;div2&quot;&gt;&lt;/div&gt;&lt;p class=&quot;p1&quot;&gt;&lt;/p&gt; 6-2). 语法： [标签属性名]{} [标签属性名=属性值]{}123456789&lt;style&gt;h1[title]&#123;&#125; //交集选择器//权重:标签+属性的权重=11[type]&#123;&#125;//权重：10[type=text]&#123;&#125;//权重:10&lt;/style&gt;&lt;a href=&quot;&quot; title=&quot;&quot;&gt;link&lt;/a&gt; 6-3). 权重:10 7)属性和值选择器 7-1). 说明: 1). 下面的例子为 title=”xx” 的所有元素设置样式： 1234[title=xx] &#123; border:5px solid blue; &#125; 2). 设置表单的样式 12345678input[type=&quot;text&quot;]&#123; width:150px; display:block; margin-bottom:10px; background-color:yellow; font-family: Verdana, Arial;&#125; 8)分组选择器 8-1).作用(应用场景): 1). 同一份css样式，可以一次性的添加给多个不同的html元素 8-2).语法： 选择器1,选择器2,选择器3{};例如:12.box,li,.p1&#123;color: red&#125;.box&#123;color:green&#125; 8-3).权重 1)分组选择器将不同的html分为一组，权重计算的时候都是独立计算，不会叠加。 9)交集选择器 9-1).一个元素具有两个属性(两种属性同属一个元素的时候)，可以使用交集选择器来进行元素的准确选择 9-2).组成选择器的两部分，必须属于同一个 反例(错误用法): 123&lt;style&gt;h1.p1&#123;&#125; //--&gt;什么都选择不到&lt;/style&gt;&lt;p class=&quot;p1&quot;&gt;&lt;/p&gt;&lt;h1&gt;&lt;/h1&gt; 正例(正确用法): 123456789&lt;p class=&apos;name1 name2&apos; id=&apos;id1&apos;&gt;&lt;/p&gt;&lt;style&gt;//第一种:p.name1&#123;&#125;//第二种:p#id1&#123;&#125;//第三种:.name1.name2&#123;&#125;&lt;/style&gt; 使用解说(正确用法): 1.组合选择器之间没有任何的符号和空格 2.标签选择器和其他选择器组合的时候，标签选择器要放在前面 3.交集选择器是两个选择器组合在一起，可以是1)标签和类名,2)标签和属性选择器,3)标签和id,4)两个类选择器。 9-3). 作用 精确查找元素，增加选择器的权重1234567891011121314151617181920212223242526&lt;style&gt;h1&#123;&#125;//标签选择器 权重:1[title]&#123;&#125;//属性选择器 权重:10[title=xx]&#123;&#125;//属性选择器 权重:10h2[title]&#123;&#125;//交集选择器 权重:11h2[title=xx]&#123;&#125;//交集选择器 权重:11&lt;/style&gt;&lt;h1 title=&quot;xx&quot;&gt;&lt;/h1&gt;&lt;h2 title=&quot;xx&quot;&gt;&lt;/h2&gt;&lt;style&gt;p.p1&#123;&#125;//交集选择器 权重:11&lt;/style&gt;&lt;p class=&quot;p1&quot;&gt;&lt;/p&gt;&lt;style&gt;.p1.p2&#123;&#125;//交集选择器 权重:20&lt;/style&gt;&lt;p class=&quot;p1 p2&quot;&gt;&lt;/p&gt; 10)子集选择器 10-1). 说明: 1). 与后代选择器相比，子元素选择器只能选择作为某元素子元素的元素。 2). 父级选择器是用来确定范围的， 3). 子级选择器才是我们要添加样式的那个元素 4). 子级选择器必须是紧邻的父子关系 10-2). 语法: 父级选择器&gt;子级选择器 10-3). 权重 所有选择器之和 1234567&lt;style&gt;ul&gt;li&#123;color:red;&#125;//选择ul下的li 权重:2&lt;/style&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 11)后代选择器(派生选择器) 11-1). 说明: 1). 在一个根元素的范围内，查找到它的后代元素 2). 后代选择器在写的时候尽量控制在３个左右 3). 选择器过多浪费性能，不建议使用 11-2). 举例: 1). html结构： 1234&lt;ol&gt; &lt;li&gt;&lt;strong&gt;我是斜体字。这是因为 strong 元素位于 li 元素内。&lt;/strong&gt; &lt;/li&gt;&lt;/ol&gt; 2). 列表中的 strong 元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器： 1234li strong &#123; font-style: italic; font-weight: normal; &#125; 3). 后代选择器在写的时候尽量控制在３个左右,选择器过多浪费性能: 12345678910&lt;style&gt;.div ul span&#123;&#125;&lt;/style&gt;&lt;div class=&quot;div&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;只选择这个span元素&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 11-3). 语法: 祖辈选择器 要查找的后代选择器{};(中间用空格连接) 12)相邻兄弟选择器 12-1). 说明: 1). 相邻兄弟选择器可选择紧接在另一元素后的元素，且二者有相同父元素。 2). 通过各个元素选择弟弟选择器,两个选择器之间用“+”连接;例如: h1 + p {margin-top:50px;} 12-2).语法: 哥哥选择器+弟弟选择器{};123456789101112&lt;style&gt; .list1+li&#123;color:red;&#125; //22222变为红色 .list3+li&#123;color:green;&#125; //4444变为绿色&lt;/style&gt;&lt;ul&gt; &lt;li class=&quot;list1&quot;&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li class=&quot;list3&quot;&gt;33333&lt;/li&gt; &lt;li&gt;4444&lt;/li&gt;&lt;/ul&gt; 12-3).权重:选择器之和 13)伪类选择器 13-1).说明: 1). 给一个元素添加某种状态 例如:鼠标经过时/获取焦点时/鼠标点击时 13-2). 权重:10 13-3).举例: 1). a标签 CSS 伪类用于向某些选择器添加特殊的效果 12345678910111213&lt;style&gt; a:link &#123;color: #FF0000&#125; /* 未访问的链接 是默认状态*/ a:visited &#123;color: #00FF00&#125; /* 已访问的链接 鼠标点击后的状态*/ a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 鼠标经过的状态*/ a:active &#123;color: #0000FF&#125; /* 选定的链接 鼠标点击的状态*/&lt;/style&gt;&lt;a href=&quot;javascript:void (0)&quot;&gt;最初形态&lt;/a&gt;&lt;a href=&quot;javascript:void 0&quot;&gt;赛亚人形态&lt;/a&gt;&lt;a href=&quot;javascript:&quot;&gt;超级赛亚人形态&lt;/a&gt; 2). input标签 1234567&lt;style&gt; .input&#123;border: 1px solid gainsboro&#125; .input:hover&#123;border-color: gray&#125; .input:focus&#123;border-color: blue&#125; /*input:focus 鼠标聚焦后的状态，input独有的属性*/&lt;/style&gt;&lt;input type=&quot;text&quot; class=&quot;input&quot;&gt; 14)CSS 伪元素 14-1). 说明: 1). 通过css代码向指定元素内添加假的（html中不存在的）元素 14-2). 举例: CSS 伪元素用于向某些选择器设置特殊效果 1)before “before”会出现在div所有内容之前 “:before”伪元素可以在元素的内容前面插入新内容。 下面的例子在每个 &lt;h1&gt; 元素前面插入内容:’我是一个伪元素’： 1234h1:before &#123; content:&apos;我是一个伪元素&apos;; &#125; 2)after 会出现在div所有内容之后使用伪元素的时候要保证两个前提 2-1)要有display这个属性 2-2)要有content这个属性，这个属性的属性值可以为空，但是引号不能少(content:&quot;&quot;): 12345678910111213141516171819202122&lt;style&gt; div&#123; width: 300px; height: 300px; background-color: red; &#125; div:before&#123; display: block; content: &quot;我是before&quot;; font-size: 40px; color: white; &#125; div:after&#123; display: block; content: &quot;我是aftre&quot;; font-size: 40px; color: blue; &#125;&lt;/style&gt;&lt;div&gt; &lt;span&gt;我是span&lt;/span&gt;&lt;/div&gt; 网页显示：“伪元素选择器” 注意1.选择器的查找机制 选择器的查找机制是从右向左,例如:123456&lt;style&gt;.div ul li&#123;&#125;&lt;!-- 第一步选择这个文档中所有的li第二步选择哪些li是ul下面的第三步选择哪些li是ul下面，ul还是.div1下面的 --&gt;&lt;/style&gt; 2.选择器的组成最好不要超过三个3.后代选择器没有必要将每一层元素都写出来，只写那些关键节点即可(具有代表性的)","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS中常用的HTML元素及标签","slug":"CSS中常用的HTML元素及标签","date":"2017-06-30T06:35:23.000Z","updated":"2017-08-16T15:32:09.916Z","comments":true,"path":"2017/06/30/CSS中常用的HTML元素及标签/","link":"","permalink":"http://yoursite.com/2017/06/30/CSS中常用的HTML元素及标签/","excerpt":"","text":"常用的HTML标签总结 div 无意义标签，用来区分网页大模块，例如网页头部、主题内容、尾部&lt;div&gt;无意义元素，用它来区分网页大模块&lt;/div&gt;123456789banner&lt;div&gt;区分模块 &lt;a href=&quot;http://www.baidu.com&quot;&gt; &lt;img src=&quot;pic.jpg&quot; alt=&quot;备注/描述&quot;&gt; &lt;/a&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;&quot; alt=&quot;图片加载出问题了&quot; width=&quot;100px&quot; height=&quot;100px&quot;&gt; &lt;/a&gt;&lt;/div&gt; span 无意义标签,用来描述行内某个小模块 p &lt;p&gt;段落&lt;/p&gt; ul li 无序列表 ol li 有序列表 b 加粗 strong 加粗,浏览器解析的时候,有强调作用 body 身体,网页主体部分 （内容在浏览器可视区显示） a 超链接,描点123点击元素可以进行跳转的&lt;a href=&quot;链接路径&quot; target=&quot;_blank&quot;&gt;珠峰培训&lt;/a&gt;&lt;a href=&quot;pic.jpg&quot; target=&quot;_blank&quot;&gt;珠峰培训&lt;/a&gt; img 插入图片12&lt;img src=&quot;图片路径&quot; alt=&quot;备注/描述&quot;&gt;&lt;img src=&quot;pic.jpg&quot; alt=&quot;备注/描述&quot;&gt; i 作用：斜体 em 强调 作用：*斜体 h1-h6 标题 dl-dt-dd定义列表 常用在新闻标题和摘要 dt 定义标题 dd 定义描述 一个dt可以多个dd进行描述 标签 标签（由尖括号和关键字组成的超文本） 关键字（就是普通文本），在编辑html这门语言的时候，相关组织将这些文本归纳到了一定的规则中，是他有了特殊的含义和作用 标签的分类：开始标签、结束标签、空标签 12345678&lt;开始标签&gt;&lt;空标签 /&gt;&lt;div&gt;&lt;/div&gt;&lt;b&gt;&lt;/b&gt;&lt;strong&gt;&lt;/strong&gt;&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;···&lt;/结束标签&gt; 标签属性：用来描述标签功能的，一般写在开始标签中，跟在标签名的后面，用空格隔开，一个标签可以有很多标签属性，每一个属性都用空格隔开 12&lt;开始标签 属性名=&quot;属性值&quot; 属性名1=&quot;属性值&quot;&gt;&lt;结束标签&gt;&lt;img src=&quot;url&quot; alt=&quot;备注&quot; /&gt; html标签 html标签HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。 标签不会出现在页面中，只有标签中的内容才会显示在页面上 ：也就是&lt;html&gt;此处为内容&lt;/html&gt; 标签不区分大小写，但是推荐使用小写 ：(X)HTML 版本中强制使用小写，这样更加严谨 标签分为闭合标签和空标签 ：闭合标签是指由开始标签和结束标签组成的一对标签，这种标签允许嵌套和承载内容，例如：&lt;html&gt;&lt;/html&gt;、&lt;p&gt;&lt;/p&gt;；空标签是没有内容的标签，在开始标签中自动闭合，例如：&lt;img /&gt;、&lt;br /&gt;、&lt;hr /&gt;等 元素 由标签（开始和结束标签中有内容）和内容组成，元素中内容可以为空，一个空标签也叫做一个元素 12&lt;div&gt;content&lt;/div&gt;--&gt;div元素&lt;img src=&quot;url&quot; alt=&quot;备注&quot; /&gt;--&gt;img元素 标签属性经过html的进化，舍弃了有关样式的标签属性，保留功能的标签属性 例如舍弃width bgcolor align，这些样式描述都放在css里面 保留alt title src href··· iframe标签在引入其他文件的时候，必须写宽度和高度","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"“前端三层”","slug":"“前端三层”","date":"2017-06-30T06:26:17.000Z","updated":"2017-09-09T12:22:08.765Z","comments":true,"path":"2017/06/30/“前端三层”/","link":"","permalink":"http://yoursite.com/2017/06/30/“前端三层”/","excerpt":"","text":"前端三层 html结构 是直接被浏览器解析加载 CSS样式 是在html结构之上去装点网站 javascript 交互 动态效果/数据交互 基础知识 网页 网页是构成网站的基本元素，通俗来讲，一个html文件就是一个网页 网站 是由很多个网页组成的，共同为一个目标服务的网页集合 站群（流水线统一化管理） 由很多网站组成的，为同一个公司服务。 例如整个百度下所属的子公司都有自己的网站。例如：百度搜索/糯米/音乐/手机助手/百度金融等组成的就是一个站群。 HTTP（超文本传输协议） HyperText Transfer Protocol 在万维网上提供一种发布和接收HTML页面（网页）的方法。 eg：http://www.baidu.com 404服务器无响应 步骤: 输入网址，建立链接，建立客户端和服务端的连接。 发送请求信息：客户端发送一个请求给服务器 发送相应信息：服务器找到请求后，给予相应的响应信息 关闭连接：客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接 服务器 服务器，是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。 在网络环境下，根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，WEB服务器等。 防篡改：WEB端服务器一旦受到攻击，在0.0n秒做出反应，将内网服务器中的内容，马上覆盖在WEB服务器上。 负载均衡：平均WEB服务器压力，将用户访问进行分流。 vpn：用来翻墙，有指定账号就可以通过这个产品进行内网访问。 浏览器 浏览器是指可以显示网页服务器或者文件系统的HTML文件（标准通用标记语言的一个应用）内容，并让用户与这些文件交互的一种软件。 html，css，js都是运行在这个软件中，浏览器是一个工厂，html/css/js是工人和原料。 IE6–&gt;IE7（很快淘汰）–&gt;IE8(时间较长，稳定性好)–&gt;IE9(半年到一年)–&gt;IE10–&gt;IE11–&gt;IE11–&gt;IE(Edge) 最好用的浏览器–&gt;谷歌 网页的基本组成 HTML:是网页的骨架,支撑起血肉(文字,图片,音视频等) CSS:表皮和衣服、化妆品 javascript：动态和交互 HTML（超文本标记语言） 网页本身就是一种文本文件（除了文字再无其他），只有通过特定的标记描述，那些普通文本才能在浏览器中正常显示。 在页面中如果遇到图片、音视频的时候，如何用文本描述，需要用超文本进行引入才可以正常显示。 HTML文件的特点： 浏览器根据标记来解析和描述内容（从html的第一行开始向下），如果遇到错误，浏览器不会指出也不会报错，会跳过此处继续加载，编辑人员需要根据显示效果去分析哪里出错误了——html不会报错 HTML的兼容问题： 因为浏览器是由不同厂商生产的，所以对html的解析有分歧，产生了页面效果显示不一致的情况，我们将这个问题叫做兼容问题。 超文本（标签） 标签语法： 由成对的尖括号和关键字组成，叫做标签。 关键字（标签名）：是已经规范过的，不是自己随便制造的。 例如：&lt;div&gt; , &lt;/h2&gt; , &lt;img/&gt; 标签属性 属性提供了这个元素的更多信息，语法：由属性名和属性值组成（键值对 key=”value”） 1234&lt;span style=&quot;font-family:宋体;&quot; title=&quot;标题&quot;&gt;span是标签名style是标签属性名&quot;font-family:宋体;标签属性值 一个标签可以由多个标签属性，每一个属性之间用空格隔开 标签的分类: 开始标签 &lt;div&gt; 结束标签 &lt;/div&gt; 自闭合标签(空标签) &lt;br/&gt; HTML元素 可以将元素理解成一个容器，容器中放置的就是 由标签和内容组成的，叫做元素。 &lt;div&gt;此处是内容&lt;/div&gt; 元素分类 由开始标签和结束标签组成的元素，可以进行嵌套（一个元素包着另一个元素），元素中可以添加内容，只有一个空标签，只能进行功能的添加，例如img元素 标签和元素是用来标记和描述内容的，所以这些标签和元素用户是看不到的，用户只能看到这个元素的内容。","categories":[],"tags":[{"name":"前端常识","slug":"前端常识","permalink":"http://yoursite.com/tags/前端常识/"}]},{"title":"DOS基本命令大全","slug":"DOS基本命令大全","date":"2017-06-20T06:41:46.000Z","updated":"2017-09-09T12:24:13.677Z","comments":true,"path":"2017/06/20/DOS基本命令大全/","link":"","permalink":"http://yoursite.com/2017/06/20/DOS基本命令大全/","excerpt":"","text":"基本命令 1、列出文件 ls 参数 目录名 例: 看看驱动目录下有什么:ls /System/Library/Extensions 参数 -w 显示中文，-l 详细信息， -a 包括隐藏文件 2、转换目录 cd 例：想到驱动目录下溜达一圈 cd /System/Library/Extensions 3、建立新目录 mkdir 目录名 例：在驱动目录下建一个备份目录 backup mkdir /System/Library/Extensions/backup 在桌面上建一个备份目录 backup mkdir /User/用户名/Desktop/backup 4、拷贝文件 cp 参数 源文件 目标文件 例：想把桌面的Natit.kext 拷贝到驱动目录中 cp -R /User/用户名/Desktop/Natit.kext /System/Library/Extensions 参数R表示对目录进行递归操作，kext在图形界面下看起来是个文件，实际上是个文件夹。 把驱动目录下的所有文件备份到桌面backup cp -R /System/Library/Extensions/* /User/用户名/Desktop/backup 5、删除文件 rm 参数 文件 例：想删除驱动的缓存 rm -rf /System/Library/Extensions.kextcache rm -rf /System/Library/Extensions.mkext 参数－rf 表示递归和强制，千万要小心使用，如果执行了 rm -rf / 你的系统就全没了 6、移动文件 mv 文件 例：想把AppleHDA.Kext 移到桌面 mv /System/Library/Extensions/AppleHDA.kext /User/用户名/Desktop 想把AppleHDA.Kext 移到备份目录中 mv /System/Library/Extensions/AppleHDA.kext /System/Library/Extensions/backup 7、文本编辑 nano 文件名 例：编辑natit Info.plist nano /System/Library/Extensions/Natit.kext/Info.plist 目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la 文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename 选择操作 命令名 功能描述 使用举例 head 显示文件的最初几行 head -20 filename tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 diff 比较并显示两个文件的差异 diff file1 file2 sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142 时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.NET.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftpftp.sp.net.edu.cn rcp 在本地主机与远程主机 之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的 几条命令及编号 history r 重复执行最近执行过的 某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir df /tmp 显示文件系统的总空间和可用空间 w 显示当前系统活动的总信息","categories":[],"tags":[{"name":"前端常识","slug":"前端常识","permalink":"http://yoursite.com/tags/前端常识/"}]},{"title":"Canvas动态案例","slug":"canvas动态案例","date":"2017-06-09T10:17:02.000Z","updated":"2017-09-09T12:26:32.983Z","comments":true,"path":"2017/06/09/canvas动态案例/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas动态案例/","excerpt":"","text":"12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;draw&quot; width=&quot;220&quot; height=&quot;320&quot; style=&quot;background-color: skyblue&quot;&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); var img=new Image; img.src=&apos;walkingdead.png&apos;;//添加图片地址 img.onload=function()&#123;//图片上有10张小图横着排列 var width=this.width/10; var height=this.height; var i=0; window.setInterval(function()&#123; cvs.clearRect(0,0,draw.width,draw.height);//清除上一个图片 cvs.drawImage(img,i*width,0,width,height,0,0,width,height); if(i==9)&#123; i=0 &#125;else&#123;i++;&#125; &#125;,200); &#125;&lt;/script&gt;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之8图形组合","slug":"canvas之8图形组合","date":"2017-06-09T09:41:16.000Z","updated":"2017-09-09T12:26:32.938Z","comments":true,"path":"2017/06/09/canvas之8图形组合/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之8图形组合/","excerpt":"","text":"图形组合 cvs.globalCompositeOperation=type; type的值: 1.source-over 默认值 覆盖 在原来的图形上绘制新图 新图在上 2.source-out 显示新图的非交集部分 3.source-in 显示新图和图形的交集，颜色是新图的颜色 4.source-atop 显示旧图和交集部分 交集是新图颜色 5.destination-over 在原来图形的下面绘制新图 旧图在上 6.destination-out 显示旧图的非交集部分 7.destination-in 显示交集 颜色是旧图颜色 8.destination-atop 显示新图和交集部分 交集是旧图颜色 9.lighter:全部显示 交集部分是叠加颜色 10.xor:显示新旧图的非交集部分 11.copy 只显示新图 案例1:在原来的图形上绘制新图 新图在上 12345678910var draw=document.getElementById(&apos;draw&apos;);var cvs=draw.getContext(&apos;2d&apos;);function draw1()&#123; cvs.fillStyle=&apos;gold&apos;; cvs.fillRect(10,10,100,100); cvs.globalCompositeOperation=&apos;source-over&apos;; cvs.fillStyle=&apos;pink&apos;; cvs.fillRect(50,50,100,100);&#125;draw1();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之7变形","slug":"canvas之7变形","date":"2017-06-09T09:19:54.000Z","updated":"2017-09-09T12:26:32.953Z","comments":true,"path":"2017/06/09/canvas之7变形/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之7变形/","excerpt":"","text":"平移translate(x,y);x:坐标原点向x轴平移的距离y:坐标原点向y轴平移的距离 案例 1234567891011121314function draw1()&#123; cvs.fillStyle=&apos;skyblue&apos;; //设置填充颜色天空蓝 cvs.fillRect(0,0,200,100); //矩形左上角坐标0,0 宽200px 高100px cvs.translate(50,50); //设置平移 坐标原点向x轴(向右)平移50px 坐标原点向y轴(向下)偏移50px //--&gt;这个平移只会对后面的矩形造成影响 不会影响前面的 cvs.fillStyle=&apos;pink&apos;; //设置填充颜色粉色 cvs.fillRect(0,0,180,80); //矩形左上角坐标0,0 宽180px 高80px&#125;draw1(); 缩放 vas.scale(x0,y0);x0:x轴按照x0的比例缩放y0:y轴按照x0的比例缩放 案例 12345678function draw2()&#123; cvs.scale(1,2);//设置缩放 x轴不变 y轴是之前的2倍 cvs.fillStyle=&apos;plum&apos;;//设置填充样式为颜色填充 cvs.fillRect(0,0,200,100); //矩形左上角坐标0,0 宽200px 高100px //--&gt;那么转化后的矩形宽200px 高200px&#125;draw2(); 3.旋转 vas.rotate(angle); angle:坐标轴转的角度 他是一个弧度(和画圆的计算是一样的) 案例 123456function draw3()&#123; cvs.rotate(Math.PI/4);//设置旋转 旋转角度为45度 cvs.fillStyle=&apos;lightblue&apos;; cvs.fillRect(100,100,200,100);&#125;draw3(); 注意：平移、缩放、旋转都是对原始坐标（画布）操作的 例如:1234567function draw3()&#123; cvs.translate(200,0);//此时的原点已经变到200,0的位置 cvs.rotate(Math.PI/4);//设置旋转 旋转角度为45度 cvs.fillStyle=&apos;lightblue&apos;; cvs.fillRect(100,100,200,100);&#125;draw3();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之6绘制图片","slug":"canvas之6绘制图片","date":"2017-06-09T08:51:59.000Z","updated":"2017-09-09T12:26:32.922Z","comments":true,"path":"2017/06/09/canvas之6绘制图片/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之6绘制图片/","excerpt":"","text":"绘图 cvs.drawImage(Image,x,y,w,h); Image 就是可以放在DOM中的真实图片，可以动态创建，也可以获取页面上的 x,y 图片放入画布,在画布左上角的坐标 w,h 绘制图片的宽高 案例:将图片放在画布上 123456789function draw1()&#123; var img=new Image;//动态创建一个img img.src=&apos;default.gif&apos;;//添加图片链接 img.onload=function()&#123;//如果图片地址真实存在 执行这个函数 cvs.drawImage(this,0,100,100,90); //将图片放在画布上 图片左上角的坐标0,100 图片宽100px 高90px &#125;&#125;draw1(); cvs.drawImage(img_elem,sx,sy,sw,sh,dx,dy,dw,dh); sx,sy 图片左上角的坐标 sw,sh 矩形区域的宽高 用来截取图片 dx,dy 截取出来放在画布canvas上的坐标 dw,dh 画在canvas上的宽高 总结: sw,sy,sx,sy 是用来截取图片的过程 dx,dy,dw,dh 把截取出来的图片放在canvas上的过程 案例:截取图片 123456789 function draw2()&#123; var img=new Image;//动态创建一个img img.src=&apos;1.jpg&apos;;//添加图片链接 img.onload=function()&#123;//如果图片地址真实存在 执行这个函数 cvs.drawImage(this,480,150,440,410,0,0,200,200); //this就是img 将图片放在画布上 需要截取的图片在原图片左上角的坐标480,150 截取图片的大小为440px*410px 截取出来的图片放入画布的坐标0,0 截取出来的图片画在画布canvas的宽200px 高200px &#125; &#125;// draw2(); 设置平铺 cvs.creatPattern(image,type) Image 就是可以放在DOM中的真实图片，可以动态创建，也可以获取页面上的 type: no-repeat 不平铺 repeat 全方向平铺 repeat-x x轴方向平铺 repeat-y y轴方向平铺 案例 123456789101112function draw3()&#123; var img=new Image; img.src=&apos;default.gif&apos;; img.onload=function()&#123; var rep=cvs.createPattern(this,&apos;repeat&apos;);//设置图片平铺 cvs.fillStyle=rep;//设置填充样式为图片平铺 cvs.fillRect(0,0,draw.width,draw.height); //draw.width画布的宽 draw.height画布的高 //设置填充矩形 矩形左上角坐标0,0 矩形的宽为画布的宽 矩形的高为画布的高 &#125;&#125;//draw3();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之4渐变","slug":"canvas之4渐变","date":"2017-06-09T06:56:44.000Z","updated":"2017-09-09T12:26:33.011Z","comments":true,"path":"2017/06/09/canvas之4渐变/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之4渐变/","excerpt":"","text":"1.线性渐变 var CLG=cvs.createLinearGradient(x0,y0,x1,y1); x0:渐变开始的x坐标 y0:渐变开始的y坐标 x1:渐变结束的x坐标 y1:渐变结束的y坐标 CLG.addColorStop(n,m); n:设置颜色的偏移量 m:颜色 例如: 12345678910111213function draw1()&#123; var CLG=cvs.createLinearGradient(0,0,200,200); //创建一个线性渐变 渐变开始的坐标0,0 渐变结束的坐标200,200 (即从左上角到右下角渐变) CLG.addColorStop(0,&apos;red&apos;);//设置渐变的偏移量0% 颜色红色 CLG.addColorStop(0.25,&apos;yellow&apos;);//设置渐变的偏移量25% 颜色黄色 CLG.addColorStop(0.5,&apos;skyblue&apos;);//设置渐变的偏移量50% 颜色天空蓝 CLG.addColorStop(0.75,&apos;orange&apos;);//设置渐变的偏移量75% 颜色橘黄 CLG.addColorStop(1,&apos;pink&apos;);//设置渐变的偏移量100% 颜色粉色 cvs.fillStyle=CLG;//设置填充样式是线性渐变 cvs.fillRect(0,0,200,200);//设置填充矩形 左上角坐标0,0 宽200px 高200px cvs.fill();//设置样式为填充样式&#125;draw1(); 2.径向渐变(发散性渐变) cvs.createRadialGradient(x0,y0,x1,y1,r1); x0:发散渐变开始中心的x坐标 y0：发散渐变开始中心的y坐标 r0:发散渐变开始的半径 x1:发散渐变结束中心的x坐标 y1：发散渐变结束中心的y坐标 r1:发散渐变结束的半径 例如:1234567891011121314function draw2()&#123; var CRG=cvs.createRadialGradient(200,200,200,200,200,10); //创建一个径向/发散性渐变 渐变开始的坐标200,200 渐变开始的半径200px 渐变结束的坐标200,200 渐变结束的半径10px CRG.addColorStop(0,&apos;purple&apos;); CRG.addColorStop(0.2,&apos;yellow&apos;); CRG.addColorStop(0.4,&apos;pink&apos;); CRG.addColorStop(0.6,&apos;lightblue&apos;); CRG.addColorStop(0.8,&apos;skyblue&apos;); CRG.addColorStop(1,&apos;white&apos;); cvs.fillStyle=CRG;//设置填充样式是径向渐变 cvs.fillRect(100,100,200,200); //设置填充矩形 左上角坐标100,100 宽200px 高200px&#125;draw2();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之3绘制矩形","slug":"canvas之3绘制矩形","date":"2017-06-09T05:07:19.000Z","updated":"2017-09-09T12:26:32.991Z","comments":true,"path":"2017/06/09/canvas之3绘制矩形/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之3绘制矩形/","excerpt":"","text":"cvs.fillRect(x,y,w,h); –&gt; 填充矩形 x,y 是这个矩形左上角的坐标 w,h 是这个矩形的宽高 cvs.strokeRect(x,y,w,h); –&gt; 带边框的矩形 x,y 是这个矩形左上角的坐标 w,h 是这个矩形的宽高 注意:如果设置边框 边框一半在里面一半在外面 cvs.clearRect(x,y,w,h); –&gt; 清除填充图的某一部分，清除的还是一个矩形 x,y 是这个矩形左上角的坐标 w,h 是这个矩形的宽高案例 案例1 12345678910function draw1()&#123; //填充矩形 cvs.fillStyle=&apos;#fccdda&apos;;//画之前填充颜色 cvs.fillRect(10,20,100,50);//设置填充矩形,矩形的左上角坐标为10,20 宽100px 高50px //边框矩形 cvs.strokeStyle=&apos;red&apos;;//设置边框的矩形边框颜色 cvs.lineWidth=20;//设置边框宽度20px cvs.strokeRect(150,20,100,50);//设置边框矩形， 矩形的左上角坐标为150,20 宽100px 高50px&#125;draw1(); 案例2 12345678910111213function draw2()&#123;//清除填充图的某一部分，清除的还是一个矩形cvs.clearRect(x,y,w,h) cvs.fillStyle=&apos;orange&apos;; //画之前填充颜色 cvs.fillRect(20,100,300,100); //设置填充矩形,矩形左上角坐标为20,100 宽300px 高100px cvs.clearRect(140,140,60,60); //清除填充图的矩形 清除的这个矩形左上角坐标140,140 宽60px 高60px cvs.clearRect(20,100,40,40); //清除填充图的矩形 清除的这个矩形左上角坐标20,100 宽40px 高40px cvs.clearRect(280,100,40,40); //清除填充图的矩形 清除的这个矩形左上角坐标280,100 宽40px 高40px&#125;draw2();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之5绘制文本","slug":"canvas之5绘制文本","date":"2017-06-09T04:55:35.000Z","updated":"2017-09-09T12:26:33.005Z","comments":true,"path":"2017/06/09/canvas之5绘制文本/","link":"","permalink":"http://yoursite.com/2017/06/09/canvas之5绘制文本/","excerpt":"","text":"1.阴影 cvs.shadowOffsetX//阴影的横向偏移量，默认值是0 cvs.shadowOffsetY//阴影的纵向偏移量，默认值是0 cvs.shadowColor//阴影的颜色 cvs.shadowBlur//阴影的模糊范围（值越大越模糊） 案例 123456789function draw1()&#123; cvs.shadowColor=&apos;#000fff&apos;;//设置阴影颜色 cvs.shadowOffsetX=30;//设置阴影的横向偏移量30px cvs.shadowOffsetY=20;//设置阴影的纵向偏移量20px cvs.shadowBlur=20;//设置阴影的模糊范围20px cvs.fillStyle=&apos;#449fdb&apos;;//设置填充的样式为颜色填充 cvs.fillRect(50,50,100,100);//设置填充矩形 左上角坐标50,50 宽100px 高100px&#125;draw1(); 2.绘制文本 设置字体样式 cvs.font=’字体大小font-size 字体样式font-family’ 水平对齐方式 cvs.textAlign(start,end,right,center); 垂直对齐方式 cvs.textBaseline=’’ 属性值:top,middle,hangle,bottom,alphabetic,ideographic 计算文本长度 var text=’dfbzbh’ console.log(cvs.measureText(text));//width:40.453125 填充文字 cvs.fillText(text,x,y,maxWidth); 1) text:文本内容 2) x:文字起始点的横坐标 3) y:文字起始点的纵坐标 绘制文字轮廓 cvs.strokeText(text,x,y,maxWidth); 1) text:文本内容 2) x:文字起始点的横坐标 3) y:文字起始点的纵坐标 案例1 12345678910function draw1()&#123; cvs.shadowColor=&apos;#000fff&apos;;//设置阴影颜色 cvs.shadowOffsetX=30;//设置阴影的横向偏移量30px cvs.shadowOffsetY=20;//设置阴影的纵向偏移量20px cvs.shadowBlur=20;//设置阴影的模糊范围20px cvs.fillStyle=&apos;#449fdb&apos;;//设置填充的样式为颜色填充 cvs.fillRect(50,50,100,100); //设置填充矩形 左上角坐标50,50 宽100px 高100px &#125; draw1(); 案例2 1234567891011121314151617function draw2()&#123; var text=&apos;hellow word&apos;;//设置文本内容 cvs.fillStyle=&apos;yellow&apos;;//设置填充样式颜色 cvs.font=&apos;40px verdana&apos;;//设置字体样式 cvs.textAlign=&apos;start&apos;;//设置字体的水平对齐方式 cvs.textBaseline=&apos;top&apos;;//设置字体的垂直对齐方式 cvs.fillText(text,10,10); //设置填充文字 文本内容text 文本起始点坐标10,10 var length=cvs.measureText(text); //获取文本宽度(长度)length console.dir(length); //TextMetrics--&gt;width:241.171875 //==&gt;length.width字体的宽度 cvs.fillText(&quot;字体长度为&quot;+length.width,10,60); //设置填充文字(通过字符串拼接方式) 文本起始点坐标10,60&#125;draw2(); 案例3:文本线性渐变 123456789101112131415161718192021222324function draw3()&#123; var CLG=cvs.createLinearGradient(0,0,300,100); //创建一个线性渐变 渐变开始的坐标0,0 渐变结束的坐标300,100 CLG.addColorStop(0,&apos;skyblue&apos;);//设置渐变的偏移量0% 天空蓝 CLG.addColorStop(0.25,&apos;plum&apos;);//设置渐变的偏移量25% 紫色 CLG.addColorStop(0.5,&apos;lightblue&apos;);//设置渐变的偏移量50% 蓝 CLG.addColorStop(0.75,&apos;skyblue&apos;);//设置渐变的偏移量75% 天空蓝 CLG.addColorStop(1,&apos;plum&apos;);//设置渐变的偏移量100% 紫色 var text=&apos;hellow word&apos;;//设置文本内容 cvs.fillStyle=CLG;//设置填充样式是线性渐变 cvs.shadowOffsetX=5;//设置阴影的横向偏移量5px cvs.shadowOffsetY=4;//设置阴影的纵向偏移量4px cvs.shadowColor=&apos;#ffb6c1&apos;;//设置阴影的颜色 cvs.shadowBlur=5;//设置阴影的模糊度 cvs.font=&apos;40px cursive&apos;;//设置字体样式 cvs.textAlign=&apos;top&apos;;//设置字体的水平对齐方式 cvs.fillText(text,50,150); //设置填充文字text 文本起始点坐标50,150 var width=cvs.measureText(text).width;//获取文本宽度(长度)length cvs.fillText(&quot;字体长度为：&quot;+width,10,200); //设置填充文字(通过字符串拼接方式) 文本起始点坐标10,200 &#125; draw3(); 案例4:文本径向渐变 123456789101112131415161718function draw4()&#123; var CRG=cvs.createLinearGradient(0,0,600,0,0,20); //创建一个径向渐变 渐变开始的坐标0,0 开始渐变的半径600px 渐变结束的坐标0,0 渐变结束的半径20px CRG.addColorStop(0,&apos;pink&apos;); CRG.addColorStop(0.25,&apos;skyblue&apos;); CRG.addColorStop(0.5,&apos;yellow&apos;); CRG.addColorStop(0.75,&apos;plum&apos;); CRG.addColorStop(1,&apos;skyblue&apos;); var text=&apos;I WANT EAT&apos;; cvs.fillStyle=CRG;//设置填充样式是径向渐变 cvs.font=&apos;80px simsun&apos;;//设置字体样式 cvs.textAlign=&apos;start&apos;;//设置文本横向对齐方式 cvs.textBaseline=&apos;top&apos;;//设置文本纵向对齐方式 cvs.shadowColor=&apos;lightblue&apos;;//设置阴影颜色 cvs.shadowBlur=10;//设置阴影的模糊范围10px cvs.fillText(text,10,10);//设置填充文字text 文本起始点坐标10,10&#125;draw4();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之2画圆","slug":"canvas之2画圆","date":"2017-06-08T11:56:51.000Z","updated":"2017-09-09T12:26:32.970Z","comments":true,"path":"2017/06/08/canvas之2画圆/","link":"","permalink":"http://yoursite.com/2017/06/08/canvas之2画圆/","excerpt":"","text":"cvs.arc(x,y,radius,startAngle,endAngle,anticlokwise); x,y 圆心坐标 radius半径r startAngle 起始角 以弧度计算(钟表的3点钟方向是0度,也就是x轴的正方向是0度,默认是顺时针) endAngle 结束角 anticlokwise 是否逆时针 默认值false false表示顺时针 案例 案例1:边框半圆 123456789function draw1()&#123;//边框圆 cvs.strokeStyle=&apos;#ffa50&apos;;//设置笔触样式(边框样式)颜色 cvs.beginPath();//开始一个路径 cvs.arc(500,500,100,0,Math.PI);//圆心坐标是500,500，半径是100px，起始角为0度，结束角为180度 cvs.closePath();//结束路径 cvs.lineWidth=10;//边框宽度为10px cvs.stroke();//绘制图形以边框样式绘制&#125;draw1(); 案例2:同心圆 12345678910111213141516171819202122function draw2()&#123; cvs.fillStyle=&apos;orange&apos;; cvs.beginPath(); //开始一个新的路径 cvs.arc(200,200,60,Math.PI/2,2*Math.PI); //圆心坐标是(200,200),半径为60px,起始角为90度,结束角为360度 cvs.closePath(); //结束一个路径 cvs.fill(); //绘制图形以填充样式绘制 cvs.strokeStyle=&apos;yellow&apos;; //设置 笔触样式(边框样式) 为黄色 cvs.lineWidth=40; //边框的宽度为40px cvs.beginPath(); //开始一个新的路径 cvs.arc(200,200,80,0,2*Math.PI); //圆心坐标是(200,200),半径为80px,起始角度为0度,结束角度为360度 cvs.closePath();//结束一个路径 cvs.stroke();//绘制图形以边框样式绘制&#125;draw2(); 案例3:每次调用fill绘制填充图的时候，会把当次路径的起始点和结束点分别连接，填充闭合部分(如果想让每个路径互不干扰 一定要记得写结束路径–&gt;关闭路径) 12345678910111213function draw3()&#123; cvs.strokeStyle=&apos;pink&apos;;//设置笔触样式(边框样式)颜色为粉色 cvs.beginPath();//开始一个路径 cvs.lineWidth=2;//边框的宽度为2px cvs.arc(100,100,100,0,Math.PI);//圆心坐标是100,100,半径为100,起始角度为0度,结束角度为180度 cvs.closePath();//结束一个路径 cvs.stroke();//绘制图形以边框样式绘制 cvs.fillStyle=&apos;gray&apos;;//设置填充颜色为灰色 cvs.arc(300,300,80,0,Math.PI/2);//圆心坐标是300,300，半径是80px，起始角度为0，结束角度为90度 cvs.closePath(); cvs.fill();&#125;draw3();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"Canvas之1绘制线条的有关属性和步骤","slug":"canvas之1绘制线条的有关属性和步骤","date":"2017-06-08T11:44:17.000Z","updated":"2017-09-09T12:26:33.022Z","comments":true,"path":"2017/06/08/canvas之1绘制线条的有关属性和步骤/","link":"","permalink":"http://yoursite.com/2017/06/08/canvas之1绘制线条的有关属性和步骤/","excerpt":"","text":"&lt;canvas id=&quot;&quot; width=&quot;&quot; height=&quot;&quot;&gt;&lt;/canvas&gt;canvas :H5标签 在页面上绘制图形用的（通常称他画布）canvas只是一个容器，我们用js脚本来控制他&lt;canvas id=&quot;draw&quot; width=&quot;600&quot; height=&quot;500&quot; style=&quot;border: 1px solid #ccc;&quot;&gt;&lt;/canvas&gt; 绘制线条的有关属性和步骤 1.相关属性 1.填充的样式 cvs.fillStyle --&gt;fillStyle`填充样式 cvs.strokeStyle --&gt;strokeStyle笔触样式 主要用来画边框的 cvs.lineWidth --&gt; 边框的宽度 2.绘制图形有两种方式 cvs.fill(); --&gt; 填充样式 cvs.stroke(); --&gt; 边框样式 3.颜色值的四种书写方式 1).颜色名 –&gt;”red” 2).十六进制 –&gt;”#fff” 3).三色值 –&gt;rgb(0,0,0) 4).四色值 –&gt;rgba(0,0,0,0.3) 4.坐标: 1.)以画布为基准,距离画布的上边是y坐标值(top值),距离画布的左边是x坐标值(left值); cvs.moveTo(x,y); –&gt; 起始点坐标 cvs.lineTo(x,y); –&gt; 结束点的坐标 如果没有moveTo就把上一个挨着的lineTo作为起始坐标 例如:假如第一个不是moveTo而是lineTo,那么lineTo就是其实坐标 5.开始和关闭一个路径 cvs.beginPath(); –&gt; 开始一个新的路径 cvs.closePath(); –&gt; 关闭当前路径 注意:加上.closePath会自动闭合 会自动连接起始坐标和结束坐标 6.canvas中的圆角 1).设置线条交汇处的样式 cvs.lineJoin 他有三个属性： 1).尖角miter 2).斜角bevel 3).圆角round 2).设置一条线段两端点的样式 lineCap焦点样式 1)平的butt(默认值) 2.)圆角round 3.)方角square 2.步骤及案例 步骤1.获取出canvas标签,例如:var draw=document.getElementById(&#39;draw&#39;); 步骤2.设置绘制环境–2d 平面图,例如: 12var cvs=draw.getContext(&apos;2d&apos;);//cvs 这个就是你的画板 接下来就可以在cvs上进行绘制 步骤3 案例1:线段 123456789101112function draw1()&#123;var draw=document.getElementById(&apos;draw&apos;);var cvs=draw.getContext(&apos;2d&apos;);cvs.beginPath();cvs.moveTo(50,50);cvs.lineTo(150,50);cvs.closePath();cvs.strokeStyle=&apos;#800080&apos;;cvs.lineWidth=5;cvs.stroke();//以边框的形式显示&#125;draw1(); 案例2:等腰直角三角形 12345678910111213function draw2()&#123; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); cvs.beginPath(); cvs.lineTo(80,120); cvs.lineTo(80,240); cvs.lineTo(200,240); cvs.closePath(); cvs.strokeStyle=&apos;ec568c&apos;; cvs.lineWidth=10; cvs.stroke();&#125;draw2(); 案例3:圆角矩形 12345678910111213function draw3()&#123; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); cvs.beginPath(); cvs.lineCap=&apos;round&apos;; cvs.lineTo(50,50); cvs.lineTo(250,50); cvs.closePath();//关闭就没有圆角效果 cvs.lineWidth=100; cvs.strokeStyle=&apos;#896446&apos;; cvs.stroke();&#125;draw3(); 案例4:圆角三角形 1234567891011121314function draw4()&#123; var draw=document.getElementById(&apos;draw&apos;); var cvs=draw.getContext(&apos;2d&apos;); cvs.beginPath(); cvs.lineJoin=&apos;round&apos;;//设置圆角 cvs.moveTo(200,100); cvs.lineTo(100,250); cvs.lineTo(300,250); cvs.closePath(); cvs.lineWidth=50; cvs.strokeStyle=&apos;#896446&apos;; cvs.stroke();&#125;draw4();","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]}]}